{"origin_topic": "检查一个数是否为质数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_prime_number(input_value):\n    if input_value <= 1:\n        return False\n    else:\n        divisor = 2\n        while divisor < input_value:\n            if input_value % divisor == 0:\n                return False\n            divisor = divisor + 1\n        return True", "output": "from typing import Union\n\n\ndef is_prime(number: Union[int, float]) -> bool:\n    \"\"\"Check if a given number is a prime number.\n    \n    A prime number is a natural number greater than 1 that has no positive\n    divisors other than 1 and itself.\n    \n    Args:\n        number: The number to check for primality. Can be integer or float,\n                but will be converted to integer for the check.\n    \n    Returns:\n        True if the number is prime, False otherwise.\n    \n    Examples:\n        >>> is_prime(7)\n        True\n        >>> is_prime(10)\n        False\n        >>> is_prime(1)\n        False\n        >>> is_prime(2)\n        True\n    \"\"\"\n    # Convert to integer if float, but maintain original value for checks\n    if isinstance(number, float):\n        if not number.is_integer():\n            return False\n        number = int(number)\n    \n    # Prime numbers must be greater than 1\n    if number <= 1:\n        return False\n    \n    # 2 is the only even prime number\n    if number == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if number % 2 == 0:\n        return False\n    \n    # Check odd divisors only, up to the square root of the number\n    max_divisor = int(number ** 0.5) + 1\n    for divisor in range(3, max_divisor, 2):\n        if number % divisor == 0:\n            return False\n    \n    return True"}
{"origin_topic": "统计一个句子中的单词数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_words_in_sentence(a):\n    b = 0\n    x = 0\n    while x < len(a):\n        if a[x] != ' ':\n            while x < len(a) and a[x] != ' ':\n                x = x + 1\n            b = b + 1\n        else:\n            while x < len(a) and a[x] == ' ':\n                x = x + 1\n    return b", "output": "def count_words_in_sentence(sentence: str) -> int:\n    \"\"\"Count the number of words in a sentence.\n    \n    Words are defined as sequences of non-space characters separated by one or\n    more spaces. Leading and trailing spaces are ignored.\n    \n    Args:\n        sentence: The input string to count words from.\n        \n    Returns:\n        The number of words in the sentence.\n        \n    Examples:\n        >>> count_words_in_sentence(\"Hello world\")\n        2\n        >>> count_words_in_sentence(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words_in_sentence(\"\")\n        0\n        >>> count_words_in_sentence(\"   \")\n        0\n    \"\"\"\n    word_count = 0\n    index = 0\n    \n    while index < len(sentence):\n        # Skip non-space characters (a word)\n        if sentence[index] != ' ':\n            # Move index to the end of the current word\n            while index < len(sentence) and sentence[index] != ' ':\n                index += 1\n            word_count += 1\n        else:\n            # Skip consecutive spaces\n            while index < len(sentence) and sentence[index] == ' ':\n                index += 1\n                \n    return word_count"}
{"origin_topic": "按字典的值对字典进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(input_dict):\n    result_list = []\n    for key_item in input_dict:\n        result_list.append((key_item, input_dict[key_item]))\n    for i in range(len(result_list)):\n        for j in range(len(result_list) - 1):\n            if result_list[j][1] > result_list[j + 1][1]:\n                temp = result_list[j]\n                result_list[j] = result_list[j + 1]\n                result_list[j + 1] = temp\n    output_dict = {}\n    for pair in result_list:\n        output_dict[pair[0]] = pair[1]\n    return output_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary values\n\ndef sort_dict_by_value(input_dict: Dict[str, T]) -> Dict[str, T]:\n    \"\"\"\n    Sort a dictionary by its values in ascending order.\n    \n    This function creates a new dictionary with the same key-value pairs\n    as the input, but sorted by the values in ascending order. The sorting\n    is stable and preserves the original key-value relationships.\n    \n    Args:\n        input_dict: A dictionary with string keys and comparable values.\n        \n    Returns:\n        A new dictionary with the same key-value pairs, sorted by values\n        in ascending order.\n        \n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n        \n    Raises:\n        TypeError: If dictionary values are not comparable.\n    \"\"\"\n    # Convert dictionary items to list of tuples for sorting\n    items = list(input_dict.items())\n    \n    # Sort items by value using Python's built-in sort\n    # This is more efficient than bubble sort and uses less code\n    sorted_items = sorted(items, key=lambda item: item[1])\n    \n    # Convert sorted items back to dictionary\n    # Python 3.7+ preserves insertion order, so the sorted order is maintained\n    sorted_dict = dict(sorted_items)\n    \n    return sorted_dict"}
{"origin_topic": "将句子中的每个单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split()\n    d = []\n    for e in c:\n        f = \"\"\n        for g in range(len(e)):\n            if g == 0:\n                h = e[g].upper()\n                f = f + h\n            else:\n                i = e[g].lower()\n                f = f + i\n        d.append(f)\n    j = \" \".join(d)\n    return j", "output": "def format_title_case(text: str) -> str:\n    \"\"\"将字符串转换为标题格式（每个单词首字母大写，其余小写）。\n    \n    该函数将输入字符串按空格分割为单词，对每个单词进行首字母大写处理，\n    然后将处理后的单词重新组合为字符串。\n    \n    Args:\n        text: 需要转换的原始字符串\n        \n    Returns:\n        转换后的标题格式字符串\n        \n    Examples:\n        >>> format_title_case(\"hello world\")\n        'Hello World'\n        >>> format_title_case(\"PYTHON programming\")\n        'Python Programming'\n    \"\"\"\n    words = text.split()\n    formatted_words = []\n    \n    for word in words:\n        # 将单词首字母大写，其余字母小写\n        formatted_word = word[0].upper() + word[1:].lower() if word else \"\"\n        formatted_words.append(formatted_word)\n    \n    return \" \".join(formatted_words)"}
{"origin_topic": "将字符串中的所有数字提取出来并求和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    for c in b:\n        if c.isdigit():\n            x.append(c)\n        else:\n            continue\n    y = 0\n    for d in x:\n        y = y + int(d)\n    return y", "output": "from typing import List, Union\n\n\ndef sum_digits_in_string(input_string: str) -> int:\n    \"\"\"计算字符串中所有数字字符的数值总和。\n    \n    遍历输入字符串，识别数字字符（0-9），将其转换为整数后累加求和。\n    忽略所有非数字字符。\n    \n    Args:\n        input_string: 包含数字字符的输入字符串\n        \n    Returns:\n        字符串中所有数字字符的数值总和\n        \n    Examples:\n        >>> sum_digits_in_string(\"a1b2c3\")\n        6\n        >>> sum_digits_in_string(\"hello123\")\n        6\n        >>> sum_digits_in_string(\"no digits\")\n        0\n    \"\"\"\n    # 提取字符串中的所有数字字符\n    digit_characters: List[str] = [\n        char for char in input_string if char.isdigit()\n    ]\n    \n    # 将数字字符转换为整数并求和\n    total_sum: int = sum(int(digit) for digit in digit_characters)\n    \n    return total_sum"}
{"origin_topic": "检查字符串是否为回文", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    l = 0\n    r = len(s) - 1\n    while l < r:\n        if s[l] != s[r]:\n            return False\n        l = l + 1\n        r = r - 1\n    return True", "output": "def is_palindrome(string: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\n    \n    A palindrome is a string that reads the same forwards and backwards.\n    This function uses a two-pointer approach to compare characters from\n    both ends of the string, moving towards the center.\n    \n    Args:\n        string: The input string to check for palindrome property.\n        \n    Returns:\n        True if the string is a palindrome, False otherwise.\n        \n    Examples:\n        >>> is_palindrome(\"racecar\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"a\")\n        True\n        >>> is_palindrome(\"\")\n        True\n    \"\"\"\n    left_index = 0\n    right_index = len(string) - 1\n    \n    while left_index < right_index:\n        if string[left_index] != string[right_index]:\n            return False\n        left_index += 1\n        right_index -= 1\n    \n    return True"}
{"origin_topic": "将字符串转换为驼峰命名法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split('_')\n    d = []\n    for e in c:\n        if e:\n            f = e[0].upper() + e[1:].lower()\n            d.append(f)\n    g = ''.join(d)\n    if g:\n        h = g[0].lower() + g[1:]\n        return h\n    else:\n        return ''", "output": "def to_camel_case(input_string: str) -> str:\n    \"\"\"Convert snake_case string to camelCase.\n    \n    Args:\n        input_string: A string in snake_case format (e.g., 'hello_world_example')\n    \n    Returns:\n        A string in camelCase format (e.g., 'helloWorldExample'). Returns empty string\n        for empty input or strings containing only underscores.\n    \n    Examples:\n        >>> to_camel_case('hello_world')\n        'helloWorld'\n        >>> to_camel_case('HELLO_WORLD')\n        'helloWorld'\n        >>> to_camel_case('_hello_world_')\n        'helloWorld'\n        >>> to_camel_case('')\n        ''\n    \"\"\"\n    if not input_string:\n        return ''\n    \n    words = input_string.split('_')\n    capitalized_words = []\n    \n    for word in words:\n        if not word:\n            continue\n        \n        # Capitalize first letter, lowercase the rest\n        processed_word = word[0].upper() + word[1:].lower()\n        capitalized_words.append(processed_word)\n    \n    if not capitalized_words:\n        return ''\n    \n    # Join all capitalized words\n    pascal_case = ''.join(capitalized_words)\n    \n    # Convert first character to lowercase for camelCase\n    camel_case = pascal_case[0].lower() + pascal_case[1:]\n    \n    return camel_case"}
{"origin_topic": "实现一个函数，将字符串中的元音字母替换为'*'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    v = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    r = ''\n    for c in s:\n        flag = False\n        for vc in v:\n            if c == vc:\n                flag = True\n                break\n        if flag:\n            r = r + '*'\n        else:\n            r = r + c\n    return r", "output": "def mask_vowels(input_string: str) -> str:\n    \"\"\"Replaces all vowels in the input string with asterisks.\n    \n    Both lowercase and uppercase vowels (a, e, i, o, u) are replaced with '*'.\n    All other characters remain unchanged.\n    \n    Args:\n        input_string: The string to process.\n    \n    Returns:\n        A new string with all vowels replaced by '*'.\n    \n    Examples:\n        >>> mask_vowels(\"Hello World\")\n        'H*ll* W*rld'\n        >>> mask_vowels(\"Python\")\n        'Pyth*n'\n        >>> mask_vowels(\"AEIOU\")\n        '*****'\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result_chars = []\n    \n    for character in input_string:\n        if character in vowels:\n            result_chars.append('*')\n        else:\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "反转字符串并保持原大小写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = list(a)\n    x = []\n    for i in range(len(b)):\n        x.append(b[len(b) - 1 - i])\n    y = []\n    for j in range(len(a)):\n        if a[j].isupper():\n            y.append(x[j].upper())\n        else:\n            y.append(x[j].lower())\n    return ''.join(y)", "output": "def reverse_and_normalize_case(input_string: str) -> str:\n    \"\"\"Reverses a string and normalizes character case based on original positions.\n    \n    The function reverses the input string, then adjusts the case of each character\n    in the reversed string to match the case pattern of the original string.\n    Characters in positions where the original had uppercase become uppercase in\n    the reversed result, and positions with lowercase become lowercase.\n    \n    Args:\n        input_string: The string to be processed.\n        \n    Returns:\n        A new string that is the reverse of the input, with case normalized\n        according to the original string's case pattern.\n        \n    Examples:\n        >>> reverse_and_normalize_case(\"HelloWorld\")\n        'DLROwOLLEh'\n        >>> reverse_and_normalize_case(\"PyThOn\")\n        'NoHtYp'\n    \"\"\"\n    # Create a reversed version of the input string\n    reversed_chars = list(reversed(input_string))\n    \n    # Build the result by applying case normalization based on original positions\n    result_chars = []\n    for original_index, original_char in enumerate(input_string):\n        reversed_char = reversed_chars[original_index]\n        \n        if original_char.isupper():\n            result_chars.append(reversed_char.upper())\n        else:\n            result_chars.append(reversed_char.lower())\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将字符串按单词反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    for x in s:\n        if x == ' ':\n            if b != '':\n                a.append(b)\n                b = ''\n        else:\n            b = b + x\n    if b != '':\n        a.append(b)\n    c = []\n    d = len(a)\n    e = d - 1\n    while e >= 0:\n        c.append(a[e])\n        e = e - 1\n    g = ''\n    for h in c:\n        g = g + h + ' '\n    if len(g) > 0:\n        g = g[:-1]\n    return g", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    Multiple spaces are treated as a single delimiter.\n    \n    Args:\n        sentence: The input string containing words to be reversed.\n        \n    Returns:\n        A string with words in reverse order, separated by single spaces.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  multiple   spaces   between   words  \")\n        'words between spaces multiple'\n    \"\"\"\n    words = []\n    current_word = []\n    \n    # Parse words from the sentence\n    for char in sentence:\n        if char == ' ':\n            if current_word:\n                words.append(''.join(current_word))\n                current_word = []\n        else:\n            current_word.append(char)\n    \n    # Add the last word if it exists\n    if current_word:\n        words.append(''.join(current_word))\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join words with single spaces\n    return ' '.join(reversed_words)"}
{"origin_topic": "将字符串按单词反转顺序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    for x in s:\n        if x == ' ':\n            if b != '':\n                a.append(b)\n                b = ''\n        else:\n            b = b + x\n    if b != '':\n        a.append(b)\n    c = []\n    d = len(a) - 1\n    while d >= 0:\n        c.append(a[d])\n        d = d - 1\n    e = ''\n    for y in range(len(c)):\n        e = e + c[y]\n        if y != len(c) - 1:\n            e = e + ' '\n    return e", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"反转句子中的单词顺序并返回。\n    \n    该函数将输入句子按单词分割，反转单词顺序，然后重新组合成字符串。\n    连续的空格会被视为单个分隔符，句子前后的空格会被忽略。\n    \n    Args:\n        sentence: 输入的句子字符串\n        \n    Returns:\n        单词顺序反转后的新句子\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  Python  is   great  \")\n        'great is Python'\n    \"\"\"\n    words = []\n    current_word = []\n    \n    # 遍历字符构建单词列表\n    for char in sentence:\n        if char == ' ':\n            if current_word:  # 当前单词结束\n                words.append(''.join(current_word))\n                current_word = []\n        else:\n            current_word.append(char)\n    \n    # 处理最后一个单词（如果存在）\n    if current_word:\n        words.append(''.join(current_word))\n    \n    # 反转单词列表\n    reversed_words = words[::-1]\n    \n    # 用单个空格连接反转后的单词\n    return ' '.join(reversed_words)"}
{"origin_topic": "判断一个字符串是否为回文", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    l = 0\n    r = len(s) - 1\n    while l < r:\n        if s[l] != s[r]:\n            return False\n        l = l + 1\n        r = r - 1\n    return True", "output": "def is_palindrome(text: str) -> bool:\n    \"\"\"Check if a string is a palindrome.\n    \n    A palindrome is a string that reads the same forwards and backwards,\n    ignoring spaces, punctuation, and capitalization. This implementation\n    uses a two-pointer approach for O(n) time complexity and O(1) space.\n    \n    Args:\n        text: The string to check for palindrome property.\n    \n    Returns:\n        True if the string is a palindrome, False otherwise.\n    \n    Examples:\n        >>> is_palindrome(\"racecar\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"a\")\n        True\n        >>> is_palindrome(\"\")\n        True\n    \"\"\"\n    left_index = 0\n    right_index = len(text) - 1\n    \n    while left_index < right_index:\n        if text[left_index] != text[right_index]:\n            return False\n        left_index += 1\n        right_index -= 1\n    \n    return True"}
{"origin_topic": "将字符串按空格分割成单词列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(x):\n    y = []\n    z = \"\"\n    for i in range(len(x)):\n        if x[i] != \" \":\n            z = z + x[i]\n        else:\n            if z != \"\":\n                y.append(z)\n                z = \"\"\n    if z != \"\":\n        y.append(z)\n    return y", "output": "def split_string_by_spaces(input_string: str) -> list[str]:\n    \"\"\"将字符串按空格分割为单词列表，忽略连续空格。\n    \n    该函数遍历输入字符串，将非空格字符累积为单词，遇到空格时\n    将累积的单词添加到结果列表中。连续空格会被忽略。\n    \n    Args:\n        input_string: 需要分割的字符串\n        \n    Returns:\n        分割后的单词列表，不包含空字符串\n        \n    Examples:\n        >>> split_string_by_spaces(\"hello world\")\n        ['hello', 'world']\n        >>> split_string_by_spaces(\"  multiple   spaces  here  \")\n        ['multiple', 'spaces', 'here']\n    \"\"\"\n    words: list[str] = []\n    current_word: str = \"\"\n    \n    for character in input_string:\n        if character != \" \":\n            current_word += character\n        else:\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n    \n    # 处理末尾可能存在的单词\n    if current_word:\n        words.append(current_word)\n    \n    return words"}
{"origin_topic": "将给定的秒数转换为小时、分钟和秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = a % 3600\n    y = x // 60\n    z = x % 60\n    result = (b, y, z)\n    return result", "output": "def convert_seconds(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"将总秒数转换为小时、分钟、秒的元组。\n\n    该函数将给定的总秒数分解为小时、分钟和秒的整数部分，\n    遵循时间转换的标准规则（1小时=3600秒，1分钟=60秒）。\n\n    Args:\n        total_seconds: 需要转换的总秒数，应为非负整数。\n\n    Returns:\n        包含三个整数的元组 (hours, minutes, seconds)，分别表示：\n        - hours: 完整的小时数\n        - minutes: 剩余的完整分钟数\n        - seconds: 剩余的秒数\n\n    Examples:\n        >>> convert_seconds(3665)\n        (1, 1, 5)\n        >>> convert_seconds(3600)\n        (1, 0, 0)\n        >>> convert_seconds(59)\n        (0, 0, 59)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    \n    return hours, minutes, seconds"}
{"origin_topic": "将秒数转换为小时、分钟、秒格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = a % 3600\n    y = x // 60\n    z = x % 60\n    result = (b, y, z)\n    return result", "output": "def convert_seconds(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"将总秒数转换为小时、分钟、秒的元组。\n    \n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）\n    \n    Returns:\n        包含三个整数的元组：(小时, 分钟, 秒)\n    \n    Examples:\n        >>> convert_seconds(3661)\n        (1, 1, 1)\n        >>> convert_seconds(7200)\n        (2, 0, 0)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    \n    return hours, minutes, seconds"}
{"origin_topic": "将秒数转换为小时、分钟、秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = a % 3600\n    c = x // 60\n    d = x % 60\n    e = b\n    f = c\n    g = d\n    h = e\n    i = f\n    j = g\n    k = h\n    l = i\n    m = j\n    n = k\n    o = l\n    p = m\n    q = n\n    r = o\n    s = p\n    t = q\n    u = r\n    v = s\n    w = t\n    y = u\n    z = v\n    aa = w\n    bb = y\n    cc = z\n    dd = aa\n    ee = bb\n    ff = cc\n    gg = dd\n    hh = ee\n    ii = ff\n    jj = gg\n    kk = hh\n    ll = ii\n    mm = jj\n    nn = kk\n    oo = ll\n    pp = mm\n    qq = nn\n    rr = oo\n    ss = pp\n    tt = qq\n    uu = rr\n    vv = ss\n    ww = tt\n    xx = uu\n    yy = vv\n    zz = ww\n    aaa = xx\n    bbb = yy\n    ccc = zz\n    ddd = aaa\n    eee = bbb\n    fff = ccc\n    ggg = ddd\n    hhh = eee\n    iii = fff\n    jjj = ggg\n    kkk = hhh\n    lll = iii\n    mmm = jjj\n    nnn = kkk\n    ooo = lll\n    ppp = mmm\n    qqq = nnn\n    rrr = ooo\n    sss = ppp\n    ttt = qqq\n    uuu = rrr\n    vvv = sss\n    www = ttt\n    xxx = uuu\n    yyy = vvv\n    zzz = www\n    aaaa = xxx\n    bbbb = yyy\n    cccc = zzz\n    dddd = aaaa\n    eeee = bbbb\n    ffff = cccc\n    gggg = dddd\n    hhhh = eeee\n    iiii = ffff\n    jjjj = gggg\n    kkkk = hhhh\n    llll = iiii\n    mmmm = jjjj\n    nnnn = kkkk\n    oooo = llll\n    pppp = mmmm\n    qqqq = nnnn\n    rrrr = oooo\n    ssss = pppp\n    tttt = qqqq\n    uuuu = rrrr\n    vvvv = ssss\n    wwww = tttt\n    xxxx = uuuu\n    yyyy = vvvv\n    zzzz = wwww\n    aaaaa = xxxx\n    bbbbb = yyyy\n    ccccc = zzzz\n    ddddd = aaaaa\n    eeeee = bbbbb\n    fffff = ccccc\n    ggggg = ddddd\n    hhhhh = eeeee\n    iiiii = fffff\n    jjjjj = ggggg\n    kkkkk = hhhhh\n    lllll = iiiii\n    mmmmm = jjjjj\n    nnnnn = kkkkk\n    ooooo = lllll\n    ppppp = mmmmm\n    qqqqq = nnnnn\n    rrrrr = ooooo\n    sssss = ppppp\n    ttttt = qqqqq\n    uuuuu = rrrrr\n    vvvvv = sssss\n    wwwww = ttttt\n    xxxxx = uuuuu\n    yyyyy = vvvvv\n    zzzzz = wwwww\n    aaaaaa = xxxxx\n    bbbbbb = yyyyy\n    cccccc = zzzzz\n    dddddd = aaaaaa\n    eeeeee = bbbbbb\n    ffffff = cccccc\n    gggggg = dddddd\n    hhhhhh = eeeeee\n    iiiiii = ffffff\n    jjjjjj = gggggg\n    kkkkkk = hhhhhh\n    llllll = iiiiii\n    mmmmmm = jjjjjj\n    nnnnnn = kkkkkk\n    oooooo = llllll\n    pppppp = mmmmmm\n    qqqqqq = nnnnnn\n    rrrrrr = oooooo\n    ssssss = pppppp\n    tttttt = qqqqqq\n    uuuuuu = rrrrrr\n    vvvvvv = ssssss\n    wwwwww = tttttt\n    xxxxxx = uuuuuu\n    yyyyyy = vvvvvv\n    zzzzzz = wwwwww\n    aaaaaaa = xxxxxx\n    bbbbbbb = yyyyyy\n    ccccccc = zzzzzz\n    ddddddd = aaaaaaa\n    eeeeeee = bbbbbbb\n    fffffff = ccccccc\n    ggggggg = ddddddd\n    hhhhhhh = eeeeeee\n    iiiiiii = fffffff\n    jjjjjjj = ggggggg\n    kkkkkkk = hhhhhhh\n    lllllll = iiiiiii\n    mmmmmmm = jjjjjjj\n    nnnnnnn = kkkkkkk\n    ooooooo = lllllll\n    ppppppp = mmmmmmm\n    qqqqqqq = nnnnnnn\n    rrrrrrr = ooooooo\n    sssssss = ppppppp\n    ttttttt = qqqqqqq\n    uuuuuuu = rrrrrrr\n    vvvvvvv = sssssss\n    wwwwwww = ttttttt\n    xxxxxxx = uuuuuuu\n    yyyyyyy = vvvvvvv\n    zzzzzzz = wwwwwww\n    aaaaaaaa = xxxxxxx\n    bbbbbbbb = yyyyyyy\n    cccccccc = zzzzzzz\n    dddddddd = aaaaaaaa\n    eeeeeeee = bbbbbbbb\n    ffffffff = cccccccc\n    gggggggg = dddddddd\n    hhhhhhhh = eeeeeeee\n    iiiiiiii = ffffffff\n    jjjjjjjj = gggggggg\n    kkkkkkkk = hhhhhhhh\n    llllllll = iiiiiiii\n    mmmmmmmm = jjjjjjjj\n    nnnnnnnn = kkkkkkkk\n    oooooooo = llllllll\n    pppppppp = mmmmmmmm\n    qqqqqqqq = nnnnnnnn\n    rrrrrrrr = oooooooo\n    ssssssss = pppppppp\n    tttttttt = qqqqqqqq\n    uuuuuuuu = rrrrrrrr\n    vvvvvvvv = ssssssss\n    wwwwwwww = tttttttt\n    xxxxxxxx = uuuuuuuu\n    yyyyyyyy = vvvvvvvv\n    zzzzzzzz = wwwwwwww\n    aaaaaaaaa = xxxxxxxx\n    bbbbbbbbb = yyyyyyyy\n    ccccccccc = zzzzzzzz\n    ddddddddd = aaaaaaaaa\n    eeeeeeeee = bbbbbbbbb\n    fffffffff = ccccccccc\n    ggggggggg = ddddddddd\n    hhhhhhhhh = eeeeeeeee\n    iiiiiiiii = fffffffff\n    jjjjjjjjj = ggggggggg\n    kkkkkkkkk = hhhhhhhhh\n    lllllllll = iiiiiiiii\n    mmmmmmmmm = jjjjjjjjj\n    nnnnnnnnn = kkkkkkkkk\n    ooooooooo = lllllllll\n    ppppppppp = mmmmmmmmm\n    qqqqqqqqq = nnnnnnnnn\n    rrrrrrrrr = ooooooooo\n    sssssssss = ppppppppp\n    ttttttttt = qqqqqqqqq\n    uuuuuuuuu = rrrrrrrrr\n    vvvvvvvvv = sssssssss\n    wwwwwwwww = ttttttttt\n    xxxxxxxxx = uuuuuuuuu\n    yyyyyyyyy = vvvvvvvvv\n    zzzzzzzzz = wwwwwwwww\n    aaaaaaaaaa = xxxxxxxxx\n    bbbbbbbbbb = yyyyyyyyy\n    cccccccccc = zzzzzzzzz\n    dddddddddd = aaaaaaaaaa\n    eeeeeeeeee = bbbbbbbbbb\n    ffffffffff = cccccccccc\n    gggggggggg = dddddddddd\n    hhhhhhhhhh = eeeeeeeeee\n    iiiiiiiiii = ffffffffff\n    jjjjjjjjjj = gggggggggg\n    kkkkkkkkkk = hhhhhhhhhh\n    llllllllll = iiiiiiiiii\n    mmmmmmmmmm = jjjjjjjjjj\n    nnnnnnnnnn = kkkkkkkkkk\n    oooooooooo = llllllllll\n    pppppppppp = mmmmmmmmmm\n    qqqqqqqqqq = nnnnnnnnnn\n    rrrrrrrrrr = oooooooooo\n    ssssssssss = pppppppppp\n    tttttttttt = qqqqqqqqqq\n    uuuuuuuuuu = rrrrrrrrrr\n    vvvvvvvvvv = ssssssssss\n    wwwwwwwwww = tttttttttt\n    xxxxxxxxxx = uuuuuuuuuu\n    yyyyyyyyyy = vvvvvvvvvv\n    zzzzzzzzzz = wwwwwwwwww\n    return xxxxxxxxxx, yyyyyyyyyy, zzzzzzzzzz", "output": "def convert_seconds(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"\n    Convert seconds to hours, minutes, and seconds.\n    \n    Args:\n        total_seconds: Total number of seconds to convert.\n        \n    Returns:\n        A tuple containing (hours, minutes, seconds).\n        \n    Examples:\n        >>> convert_seconds(3665)\n        (1, 1, 5)\n        >>> convert_seconds(3600)\n        (1, 0, 0)\n        >>> convert_seconds(59)\n        (0, 0, 59)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    \n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    \n    return hours, minutes, seconds"}
{"origin_topic": "将字符串中的单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b.split():\n        e = ''\n        for f in range(len(d)):\n            if f == 0:\n                e = e + d[f].upper()\n            else:\n                e = e + d[f].lower()\n        c.append(e)\n    return ' '.join(c)", "output": "def capitalize_words(text: str) -> str:\n    \"\"\"Capitalize the first letter of each word in a string.\n    \n    Args:\n        text: Input string containing words to capitalize.\n        \n    Returns:\n        String with each word capitalized (first letter uppercase, rest lowercase).\n        \n    Example:\n        >>> capitalize_words(\"hello world\")\n        'Hello World'\n        >>> capitalize_words(\"PYTHON programming\")\n        'Python Programming'\n    \"\"\"\n    capitalized_words = []\n    \n    for word in text.split():\n        capitalized_word = ''\n        \n        for index, character in enumerate(word):\n            if index == 0:\n                capitalized_word += character.upper()\n            else:\n                capitalized_word += character.lower()\n                \n        capitalized_words.append(capitalized_word)\n        \n    return ' '.join(capitalized_words)"}
{"origin_topic": "将字符串中的单词顺序反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    for x in s:\n        if x == ' ':\n            if b != '':\n                a.append(b)\n                b = ''\n        else:\n            b = b + x\n    if b != '':\n        a.append(b)\n    c = []\n    d = len(a)\n    e = d - 1\n    while e >= 0:\n        c.append(a[e])\n        e = e - 1\n    g = ''\n    h = 0\n    while h < len(c):\n        g = g + c[h]\n        if h != len(c) - 1:\n            g = g + ' '\n        h = h + 1\n    return g", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n\n    Words are defined as sequences of non-space characters separated by spaces.\n    Multiple spaces are treated as a single delimiter. Leading and trailing\n    spaces are ignored.\n\n    Args:\n        sentence: The input string containing words to be reversed.\n\n    Returns:\n        A new string with words in reverse order, separated by single spaces.\n\n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  multiple   spaces   between   words  \")\n        'words between spaces multiple'\n    \"\"\"\n    words = []\n    current_word = []\n    \n    # Parse words from the sentence\n    for char in sentence:\n        if char == ' ':\n            if current_word:\n                words.append(''.join(current_word))\n                current_word = []\n        else:\n            current_word.append(char)\n    \n    # Add the last word if present\n    if current_word:\n        words.append(''.join(current_word))\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join reversed words with single spaces\n    return ' '.join(reversed_words)"}
{"origin_topic": "按字典值对字典进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(input_dict):\n    sorted_items = []\n    for key, value in input_dict.items():\n        sorted_items.append((key, value))\n    for i in range(len(sorted_items)):\n        for j in range(len(sorted_items) - 1):\n            if sorted_items[j][1] > sorted_items[j + 1][1]:\n                temp = sorted_items[j]\n                sorted_items[j] = sorted_items[j + 1]\n                sorted_items[j + 1] = temp\n    result_dict = {}\n    for item in sorted_items:\n        result_dict[item[0]] = item[1]\n    return result_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary values\n\ndef sort_dict_by_value(input_dict: Dict[str, T]) -> Dict[str, T]:\n    \"\"\"Sorts a dictionary by its values in ascending order.\n    \n    This function creates a new dictionary with the same key-value pairs as the\n    input dictionary, but sorted by the values in ascending order. The sorting\n    is stable and uses bubble sort algorithm.\n    \n    Args:\n        input_dict: A dictionary with string keys and comparable values.\n        \n    Returns:\n        A new dictionary with the same key-value pairs, sorted by values in\n        ascending order.\n        \n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n        \n    Note:\n        For production use, consider using Python's built-in sorted() function\n        with itemgetter() for better performance with large dictionaries.\n    \"\"\"\n    # Convert dictionary items to a list of tuples\n    items_list = list(input_dict.items())\n    \n    # Sort using bubble sort (preserving original implementation logic)\n    for outer_index in range(len(items_list)):\n        for inner_index in range(len(items_list) - 1):\n            current_item = items_list[inner_index]\n            next_item = items_list[inner_index + 1]\n            \n            if current_item[1] > next_item[1]:\n                # Swap items if current value is greater than next value\n                items_list[inner_index], items_list[inner_index + 1] = \\\n                    items_list[inner_index + 1], items_list[inner_index]\n    \n    # Convert sorted list back to dictionary\n    sorted_dict = {}\n    for key, value in items_list:\n        sorted_dict[key] = value\n        \n    return sorted_dict"}
{"origin_topic": "将给定的分钟数转换为小时和分钟", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_minutes(a):\n    b = 0\n    while a >= 60:\n        a = a - 60\n        b = b + 1\n    x = a\n    result = (b, x)\n    return result", "output": "def convert_minutes_to_hours_and_minutes(total_minutes: int) -> tuple[int, int]:\n    \"\"\"\n    Convert total minutes to a tuple of (hours, remaining_minutes).\n\n    This function takes an integer representing total minutes and returns a tuple\n    where the first element is the number of full hours and the second element\n    is the remaining minutes (0-59).\n\n    Args:\n        total_minutes: The total number of minutes to convert. Must be non-negative.\n\n    Returns:\n        A tuple containing (hours, remaining_minutes).\n\n    Raises:\n        ValueError: If total_minutes is negative.\n\n    Examples:\n        >>> convert_minutes_to_hours_and_minutes(125)\n        (2, 5)\n        >>> convert_minutes_to_hours_and_minutes(60)\n        (1, 0)\n        >>> convert_minutes_to_hours_and_minutes(45)\n        (0, 45)\n    \"\"\"\n    if total_minutes < 0:\n        raise ValueError(\"total_minutes must be non-negative\")\n\n    hours = total_minutes // 60\n    remaining_minutes = total_minutes % 60\n    \n    return hours, remaining_minutes"}
{"origin_topic": "移除字符串开头和结尾的空白字符", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    x = 0\n    while x < len(a):\n        if a[x] != \" \" and a[x] != \"\\t\" and a[x] != \"\\n\":\n            break\n        x = x + 1\n    y = len(a) - 1\n    while y >= 0:\n        if a[y] != \" \" and a[y] != \"\\t\" and a[y] != \"\\n\":\n            break\n        y = y - 1\n    z = x\n    while z <= y:\n        b = b + a[z]\n        z = z + 1\n    return b", "output": "def strip_custom(text: str) -> str:\n    \"\"\"Removes leading and trailing whitespace characters from a string.\n\n    This function mimics the behavior of Python's built-in str.strip() method,\n    removing spaces, tabs, and newlines from both ends of the input string.\n\n    Args:\n        text: The input string from which to remove whitespace.\n\n    Returns:\n        A new string with leading and trailing whitespace removed.\n        If the input string is empty or contains only whitespace, an empty\n        string is returned.\n\n    Example:\n        >>> strip_custom(\"  hello world\\\\t\\\\n\")\n        'hello world'\n    \"\"\"\n    if not text:\n        return \"\"\n\n    # Find first non-whitespace character from the start\n    start_index = 0\n    while start_index < len(text):\n        char = text[start_index]\n        if char not in (\" \", \"\\t\", \"\\n\"):\n            break\n        start_index += 1\n\n    # Find first non-whitespace character from the end\n    end_index = len(text) - 1\n    while end_index >= 0:\n        char = text[end_index]\n        if char not in (\" \", \"\\t\", \"\\n\"):\n            break\n        end_index -= 1\n\n    # If start_index > end_index, the string contains only whitespace\n    if start_index > end_index:\n        return \"\"\n\n    # Extract the substring without leading/trailing whitespace\n    return text[start_index:end_index + 1]"}
{"origin_topic": "将秒数转换为小时、分钟和秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = a % 3600\n    y = x // 60\n    z = x % 60\n    result = (b, y, z)\n    return result", "output": "def convert_seconds(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"将总秒数转换为小时、分钟、秒的元组。\n\n    Args:\n        total_seconds: 要转换的总秒数（非负整数）。\n\n    Returns:\n        包含三个整数的元组 (hours, minutes, seconds)。\n\n    Examples:\n        >>> convert_seconds(3661)\n        (1, 1, 1)\n        >>> convert_seconds(7200)\n        (2, 0, 0)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n\n    return hours, minutes, seconds"}
{"origin_topic": "计算一个数字的阶乘", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 1\n    x = 1\n    while x <= a:\n        b = b * x\n        x = x + 1\n    return b", "output": "def factorial(number: int) -> int:\n    \"\"\"Calculate the factorial of a non-negative integer.\n\n    The factorial of a non-negative integer n is the product of all positive\n    integers less than or equal to n. For example: 5! = 5 × 4 × 3 × 2 × 1 = 120.\n\n    Args:\n        number: A non-negative integer for which to calculate the factorial.\n\n    Returns:\n        The factorial of the input number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    result = 1\n    current_multiplier = 1\n    \n    while current_multiplier <= number:\n        result *= current_multiplier\n        current_multiplier += 1\n    \n    return result"}
{"origin_topic": "计算一个句子中的单词数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    y = 0\n    z = 0\n    while z < len(b):\n        if b[z] != ' ':\n            y = 1\n        else:\n            if y == 1:\n                x = x + 1\n                y = 0\n        z = z + 1\n    if y == 1:\n        x = x + 1\n    return x", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a given string.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    Multiple consecutive spaces are treated as a single word separator.\n    \n    Args:\n        text: The input string to count words from.\n        \n    Returns:\n        The number of words in the input string.\n        \n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n    \"\"\"\n    word_count = 0\n    in_word = False\n    \n    for character in text:\n        if character != ' ':\n            # We're inside a word\n            in_word = True\n        else:\n            # We've encountered a space\n            if in_word:\n                # We just finished a word\n                word_count += 1\n                in_word = False\n    \n    # Handle case where text ends with a word (no trailing space)\n    if in_word:\n        word_count += 1\n        \n    return word_count"}
{"origin_topic": "生成斐波那契数列的前n项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def generate_fibonacci_sequence(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    else:\n        a = 0\n        b = 1\n        x = [a, b]\n        for i in range(2, n):\n            c = a + b\n            x.append(c)\n            a = b\n            b = c\n        return x", "output": "from typing import List\n\n\ndef generate_fibonacci_sequence(sequence_length: int) -> List[int]:\n    \"\"\"Generates the first n numbers of the Fibonacci sequence.\n\n    The Fibonacci sequence is defined as:\n    F(0) = 0, F(1) = 1, and F(n) = F(n-1) + F(n-2) for n > 1.\n\n    Args:\n        sequence_length: The number of Fibonacci numbers to generate.\n            Must be a non-negative integer.\n\n    Returns:\n        A list containing the first `sequence_length` Fibonacci numbers.\n        Returns an empty list if `sequence_length` <= 0.\n        Returns [0] if `sequence_length` == 1.\n\n    Raises:\n        ValueError: If `sequence_length` is negative.\n    \"\"\"\n    if sequence_length < 0:\n        raise ValueError(\"sequence_length must be non-negative\")\n\n    if sequence_length == 0:\n        return []\n\n    if sequence_length == 1:\n        return [0]\n\n    # Initialize the first two Fibonacci numbers\n    previous, current = 0, 1\n    fibonacci_sequence = [previous, current]\n\n    # Generate subsequent Fibonacci numbers\n    for _ in range(2, sequence_length):\n        next_number = previous + current\n        fibonacci_sequence.append(next_number)\n        previous, current = current, next_number\n\n    return fibonacci_sequence"}
{"origin_topic": "检查一个数是否为素数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_prime_number(input_value):\n    if input_value <= 1:\n        return False\n    else:\n        divisor = 2\n        while divisor < input_value:\n            if input_value % divisor == 0:\n                return False\n            divisor = divisor + 1\n        return True", "output": "def is_prime(number: int) -> bool:\n    \"\"\"Check if a given integer is a prime number.\n    \n    A prime number is a natural number greater than 1 that has no positive\n    divisors other than 1 and itself.\n    \n    Args:\n        number: The integer to check for primality.\n        \n    Returns:\n        True if the number is prime, False otherwise.\n        \n    Raises:\n        TypeError: If input is not an integer.\n        \n    Examples:\n        >>> is_prime(2)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(17)\n        True\n        >>> is_prime(1)\n        False\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(f\"Expected integer, got {type(number).__name__}\")\n    \n    # Numbers less than 2 are not prime\n    if number < 2:\n        return False\n    \n    # 2 is the only even prime number\n    if number == 2:\n        return True\n    \n    # Even numbers greater than 2 are not prime\n    if number % 2 == 0:\n        return False\n    \n    # Check odd divisors up to sqrt(number)\n    max_divisor = int(number ** 0.5) + 1\n    for divisor in range(3, max_divisor, 2):\n        if number % divisor == 0:\n            return False\n    \n    return True"}
{"origin_topic": "统计一段文本中每个单词出现的频率", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_words(text):\n    a = text.split()\n    b = {}\n    for x in a:\n        if x not in b:\n            b[x] = 1\n        else:\n            b[x] = b[x] + 1\n    return b", "output": "from typing import Dict, List\n\n\ndef count_words(text: str) -> Dict[str, int]:\n    \"\"\"Count the frequency of each word in the given text.\n    \n    Args:\n        text: Input string to analyze.\n        \n    Returns:\n        Dictionary mapping each word to its frequency count.\n        \n    Examples:\n        >>> count_words(\"hello world hello\")\n        {'hello': 2, 'world': 1}\n    \"\"\"\n    words: List[str] = text.split()\n    word_counts: Dict[str, int] = {}\n    \n    for word in words:\n        if word not in word_counts:\n            word_counts[word] = 1\n        else:\n            word_counts[word] += 1\n            \n    return word_counts"}
{"origin_topic": "检查一个数字是否为水仙花数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_number(num):\n    if num < 100 or num > 999:\n        return False\n    else:\n        a = num // 100\n        b = (num % 100) // 10\n        c = num % 10\n        if a ** 3 + b ** 3 + c ** 3 == num:\n            return True\n        else:\n            return False", "output": "def is_armstrong_number(number: int) -> bool:\n    \"\"\"Check if a given integer is a three-digit Armstrong number.\n\n    An Armstrong number (also known as narcissistic number) of three digits\n    is an integer where the sum of the cubes of its digits equals the number itself.\n\n    Args:\n        number: The integer to check.\n\n    Returns:\n        True if the number is a three-digit Armstrong number, False otherwise.\n\n    Examples:\n        >>> is_armstrong_number(153)\n        True\n        >>> is_armstrong_number(370)\n        True\n        >>> is_armstrong_number(371)\n        True\n        >>> is_armstrong_number(407)\n        True\n        >>> is_armstrong_number(123)\n        False\n        >>> is_armstrong_number(9999)\n        False\n    \"\"\"\n    # Validate three-digit range\n    if not 100 <= number <= 999:\n        return False\n\n    # Extract individual digits\n    hundreds_digit = number // 100\n    tens_digit = (number % 100) // 10\n    units_digit = number % 10\n\n    # Calculate sum of cubes of digits\n    sum_of_cubes = (\n        hundreds_digit ** 3 + tens_digit ** 3 + units_digit ** 3\n    )\n\n    # Check Armstrong number condition\n    return sum_of_cubes == number"}
{"origin_topic": "统计一段文本中每个单词的频率", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_words(text):\n    a = text.split()\n    b = {}\n    for x in a:\n        if x not in b:\n            b[x] = 1\n        else:\n            b[x] = b[x] + 1\n    c = {}\n    for y in b:\n        c[y] = b[y]\n    return c", "output": "from typing import Dict\n\n\ndef count_words(text: str) -> Dict[str, int]:\n    \"\"\"Count the frequency of each word in the given text.\n    \n    Args:\n        text: Input string containing words to be counted.\n    \n    Returns:\n        Dictionary mapping each word to its frequency count.\n    \n    Example:\n        >>> count_words(\"hello world hello\")\n        {'hello': 2, 'world': 1}\n    \"\"\"\n    words = text.split()\n    word_counts: Dict[str, int] = {}\n    \n    for word in words:\n        if word not in word_counts:\n            word_counts[word] = 1\n        else:\n            word_counts[word] += 1\n    \n    return word_counts"}
{"origin_topic": "将字符串中的单词按字母顺序排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split()\n    d = []\n    for e in c:\n        d.append(e)\n    f = []\n    for g in d:\n        h = list(g)\n        i = []\n        for j in h:\n            i.append(j)\n        k = sorted(i)\n        l = ''.join(k)\n        f.append(l)\n    m = sorted(f)\n    n = ' '.join(m)\n    return n", "output": "from typing import List\n\n\ndef sort_word_characters(text: str) -> str:\n    \"\"\"Sorts characters within each word and returns sorted words alphabetically.\n    \n    This function takes a string, splits it into words, sorts the characters\n    within each word alphabetically, then sorts the resulting words alphabetically\n    and joins them back into a string.\n    \n    Args:\n        text: Input string containing words to process.\n        \n    Returns:\n        A string where each word's characters are sorted alphabetically,\n        and all words are sorted alphabetically.\n        \n    Examples:\n        >>> sort_word_characters(\"hello world\")\n        'ehllo dlorw'\n        >>> sort_word_characters(\"python code\")\n        'hnopty cdeo'\n    \"\"\"\n    # Split input text into individual words\n    words: List[str] = text.split()\n    \n    # Sort characters within each word\n    sorted_words: List[str] = []\n    for word in words:\n        sorted_characters: List[str] = sorted(word)\n        sorted_word: str = ''.join(sorted_characters)\n        sorted_words.append(sorted_word)\n    \n    # Sort the words alphabetically\n    alphabetically_sorted_words: List[str] = sorted(sorted_words)\n    \n    # Join sorted words back into a single string\n    result: str = ' '.join(alphabetically_sorted_words)\n    \n    return result"}
{"origin_topic": "将句子中的单词顺序反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = s.split()\n    c = len(b)\n    d = c - 1\n    while d >= 0:\n        e = b[d]\n        a.append(e)\n        d = d - 1\n    g = ' '.join(a)\n    return g", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n    \n    Words are defined as sequences of characters separated by whitespace.\n    The function preserves the original whitespace between words.\n    \n    Args:\n        sentence: The input string containing words to be reversed.\n        \n    Returns:\n        A new string with words in reverse order.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"Python is great\")\n        'great is Python'\n    \"\"\"\n    words = sentence.split()\n    reversed_words = []\n    \n    # Iterate from the last word to the first\n    for i in range(len(words) - 1, -1, -1):\n        reversed_words.append(words[i])\n    \n    return ' '.join(reversed_words)"}
{"origin_topic": "计算1到n之间所有奇数的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_odd_sum_up_to_n(n):\n    result = 0\n    for current_number in range(1, n + 1):\n        if current_number % 2 != 0:\n            result = result + current_number\n    return result", "output": "def calculate_odd_sum_up_to_n(n: int) -> int:\n    \"\"\"计算从1到n（包含）的所有奇数的和。\n    \n    该函数通过遍历从1到n的所有整数，累加其中的奇数来计算结果。\n    时间复杂度为O(n)，空间复杂度为O(1)。\n    \n    Args:\n        n: 正整数，表示计算范围的上限（包含）。\n        \n    Returns:\n        从1到n的所有奇数的和。\n        \n    Raises:\n        ValueError: 如果n小于1。\n        \n    Examples:\n        >>> calculate_odd_sum_up_to_n(5)\n        9  # 1 + 3 + 5 = 9\n        >>> calculate_odd_sum_up_to_n(10)\n        25  # 1 + 3 + 5 + 7 + 9 = 25\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n必须为正整数\")\n    \n    odd_sum = 0\n    for number in range(1, n + 1):\n        if number % 2 != 0:\n            odd_sum += number\n    \n    return odd_sum"}
{"origin_topic": "将句子中每个单词的首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b.split()\n    for e in d:\n        f = ''\n        for g in range(len(e)):\n            if g == 0:\n                h = e[g].upper()\n                f = f + h\n            else:\n                i = e[g].lower()\n                f = f + i\n        c.append(f)\n    j = ' '.join(c)\n    return j", "output": "def capitalize_words(sentence: str) -> str:\n    \"\"\"Capitalizes the first letter of each word in a sentence.\n    \n    Converts the first character of each word to uppercase and the remaining\n    characters to lowercase, preserving word boundaries.\n    \n    Args:\n        sentence: The input string containing words to be capitalized.\n        \n    Returns:\n        A new string with each word capitalized.\n        \n    Examples:\n        >>> capitalize_words('hello world')\n        'Hello World'\n        >>> capitalize_words('PYTHON programming')\n        'Python Programming'\n    \"\"\"\n    capitalized_words = []\n    words = sentence.split()\n    \n    for word in words:\n        # Capitalize first letter, lowercase the rest\n        processed_word = word[0].upper() + word[1:].lower()\n        capitalized_words.append(processed_word)\n    \n    return ' '.join(capitalized_words)"}
{"origin_topic": "检查一个数字是否为素数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_prime_number(input_value):\n    if input_value <= 1:\n        return False\n    for divisor in range(2, input_value):\n        if input_value % divisor == 0:\n            return False\n    return True", "output": "from typing import Union\n\n\ndef is_prime(number: Union[int, float]) -> bool:\n    \"\"\"Check if a given number is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive\n    divisors other than 1 and itself.\n\n    Args:\n        number: The number to check for primality. Will be converted to int\n                if it's a float.\n\n    Returns:\n        True if the number is prime, False otherwise.\n\n    Raises:\n        ValueError: If the input is not a positive integer or convertible float.\n\n    Examples:\n        >>> is_prime(7)\n        True\n        >>> is_prime(10)\n        False\n        >>> is_prime(1)\n        False\n    \"\"\"\n    # Convert to int if float is provided\n    if isinstance(number, float):\n        if not number.is_integer():\n            raise ValueError(\"Input must be an integer or whole number float\")\n        number = int(number)\n    \n    # Validate input is a positive integer\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    # Handle edge cases\n    if number <= 1:\n        return False\n    if number <= 3:\n        return True\n    if number % 2 == 0 or number % 3 == 0:\n        return False\n    \n    # Optimized divisor check: only check up to sqrt(number)\n    # and skip even numbers and multiples of 3\n    max_divisor = int(number ** 0.5) + 1\n    for divisor in range(5, max_divisor, 6):\n        if number % divisor == 0 or number % (divisor + 2) == 0:\n            return False\n    \n    return True"}
{"origin_topic": "检查一个年份是否为闰年", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_year(a):\n    if a % 4 == 0:\n        if a % 100 == 0:\n            if a % 400 == 0:\n                return True\n            else:\n                return False\n        else:\n            return True\n    else:\n        return False", "output": "def is_leap_year(year: int) -> bool:\n    \"\"\"判断给定年份是否为闰年。\n    \n    根据格里高利历闰年规则：\n    1. 能被4整除但不能被100整除的年份为闰年\n    2. 能被400整除的年份为闰年\n    \n    Args:\n        year: 需要判断的年份，必须为整数\n        \n    Returns:\n        True 如果是闰年，否则返回 False\n        \n    Raises:\n        TypeError: 如果输入不是整数\n        \n    Examples:\n        >>> is_leap_year(2000)\n        True\n        >>> is_leap_year(1900)\n        False\n        >>> is_leap_year(2024)\n        True\n    \"\"\"\n    if not isinstance(year, int):\n        raise TypeError(f\"年份必须是整数，但收到 {type(year).__name__}\")\n    \n    # 闰年判断逻辑\n    divisible_by_4 = year % 4 == 0\n    divisible_by_100 = year % 100 == 0\n    divisible_by_400 = year % 400 == 0\n    \n    return divisible_by_4 and (not divisible_by_100 or divisible_by_400)"}
{"origin_topic": "将分钟数转换为小时和分钟", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a // 60\n    x = a % 60\n    if b == 0:\n        if x == 0:\n            return 0, 0\n        else:\n            return 0, x\n    else:\n        if x == 0:\n            return b, 0\n        else:\n            return b, x", "output": "def convert_seconds_to_minutes_and_seconds(total_seconds: int) -> tuple[int, int]:\n    \"\"\"\n    Convert total seconds into minutes and remaining seconds.\n\n    This function takes an integer representing total seconds and returns a tuple\n    where the first element is the number of whole minutes and the second element\n    is the remaining seconds.\n\n    Args:\n        total_seconds: An integer representing the total number of seconds to convert.\n\n    Returns:\n        A tuple containing two integers: (minutes, seconds).\n\n    Examples:\n        >>> convert_seconds_to_minutes_and_seconds(125)\n        (2, 5)\n        >>> convert_seconds_to_minutes_and_seconds(60)\n        (1, 0)\n        >>> convert_seconds_to_minutes_and_seconds(45)\n        (0, 45)\n        >>> convert_seconds_to_minutes_and_seconds(0)\n        (0, 0)\n    \"\"\"\n    minutes = total_seconds // 60\n    seconds = total_seconds % 60\n    \n    return minutes, seconds"}
{"origin_topic": "将摄氏度转换为华氏度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b * 9\n    d = c / 5\n    e = d + 32\n    f = e\n    g = f\n    h = g\n    i = h\n    j = i\n    k = j\n    l = k\n    m = l\n    n = m\n    o = n\n    p = o\n    q = p\n    r = q\n    s = r\n    t = s\n    u = t\n    v = u\n    w = v\n    x = w\n    y = x\n    z = y\n    aa = z\n    bb = aa\n    cc = bb\n    dd = cc\n    ee = dd\n    ff = ee\n    gg = ff\n    hh = gg\n    ii = hh\n    jj = ii\n    kk = jj\n    ll = kk\n    mm = ll\n    nn = mm\n    oo = nn\n    pp = oo\n    qq = pp\n    rr = qq\n    ss = rr\n    tt = ss\n    uu = tt\n    vv = uu\n    ww = vv\n    xx = ww\n    yy = xx\n    zz = yy\n    aaa = zz\n    bbb = aaa\n    ccc = bbb\n    ddd = ccc\n    eee = ddd\n    fff = eee\n    ggg = fff\n    hhh = ggg\n    iii = hhh\n    jjj = iii\n    kkk = jjj\n    lll = kkk\n    mmm = lll\n    nnn = mmm\n    ooo = nnn\n    ppp = ooo\n    qqq = ppp\n    rrr = qqq\n    sss = rrr\n    ttt = sss\n    uuu = ttt\n    vvv = uuu\n    www = vvv\n    xxx = www\n    yyy = xxx\n    zzz = yyy\n    aaaa = zzz\n    bbbb = aaaa\n    cccc = bbbb\n    dddd = cccc\n    eeee = dddd\n    ffff = eeee\n    gggg = ffff\n    hhhh = gggg\n    iiii = hhhh\n    jjjj = iiii\n    kkkk = jjjj\n    llll = kkkk\n    mmmm = llll\n    nnnn = mmmm\n    oooo = nnnn\n    pppp = oooo\n    qqqq = pppp\n    rrrr = qqqq\n    ssss = rrrr\n    tttt = ssss\n    uuuu = tttt\n    vvvv = uuuu\n    wwww = vvvv\n    xxxx = wwww\n    yyyy = xxxx\n    zzzz = yyyy\n    aaaaa = zzzz\n    return aaaaa", "output": "def celsius_to_fahrenheit(celsius: float) -> float:\n    \"\"\"Convert temperature from Celsius to Fahrenheit.\n    \n    Formula: (Celsius × 9/5) + 32 = Fahrenheit\n    \n    Args:\n        celsius: Temperature in degrees Celsius\n        \n    Returns:\n        Temperature in degrees Fahrenheit\n        \n    Examples:\n        >>> celsius_to_fahrenheit(0)\n        32.0\n        >>> celsius_to_fahrenheit(100)\n        212.0\n    \"\"\"\n    return (celsius * 9 / 5) + 32"}
{"origin_topic": "将二维列表扁平化为一维列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def flatten_list(a):\n    b = []\n    for x in a:\n        if isinstance(x, list):\n            for y in x:\n                b.append(y)\n        else:\n            b.append(x)\n    return b", "output": "from typing import List, Any, Iterable\n\n\ndef flatten_nested_list(nested_list: List[Any]) -> List[Any]:\n    \"\"\"Flattens a one-level nested list into a single-level list.\n\n    This function takes a list that may contain both individual elements and\n    sublists, and returns a new list where all elements from sublists are\n    moved to the top level.\n\n    Examples:\n        >>> flatten_nested_list([1, [2, 3], 4])\n        [1, 2, 3, 4]\n        >>> flatten_nested_list([[1, 2], [3, 4]])\n        [1, 2, 3, 4]\n        >>> flatten_nested_list([1, 2, 3])\n        [1, 2, 3]\n\n    Args:\n        nested_list: A list containing elements and/or sublists to be flattened.\n            Note: Only one level of nesting is supported.\n\n    Returns:\n        A new list with all elements at the top level.\n\n    Raises:\n        TypeError: If the input is not a list.\n    \"\"\"\n    if not isinstance(nested_list, list):\n        raise TypeError(f\"Expected list, got {type(nested_list).__name__}\")\n\n    flattened_result: List[Any] = []\n    \n    for element in nested_list:\n        if isinstance(element, list):\n            # Extend the result list with all elements from the sublist\n            flattened_result.extend(element)\n        else:\n            # Append individual elements directly\n            flattened_result.append(element)\n    \n    return flattened_result"}
{"origin_topic": "将摄氏温度转换为华氏温度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a * 9\n    c = b / 5\n    d = c + 32\n    e = d * 1\n    return e", "output": "def celsius_to_fahrenheit(celsius: float) -> float:\n    \"\"\"Convert temperature from Celsius to Fahrenheit.\n    \n    Formula: (Celsius * 9/5) + 32\n    \n    Args:\n        celsius: Temperature in degrees Celsius.\n        \n    Returns:\n        Temperature in degrees Fahrenheit.\n        \n    Examples:\n        >>> celsius_to_fahrenheit(0)\n        32.0\n        >>> celsius_to_fahrenheit(100)\n        212.0\n    \"\"\"\n    # Apply the conversion formula: (C * 9/5) + 32\n    fahrenheit = (celsius * 9 / 5) + 32\n    return fahrenheit"}
{"origin_topic": "将秒数转换为小时、分钟、秒的格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = a % 3600\n    y = x // 60\n    z = x % 60\n    result = (b, y, z)\n    return result", "output": "def convert_seconds(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"将总秒数转换为小时、分钟、秒的元组。\n\n    该函数将给定的总秒数分解为小时、分钟和秒的整数部分，\n    遵循标准的时间转换规则（1小时=3600秒，1分钟=60秒）。\n\n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）。\n\n    Returns:\n        一个包含三个整数的元组 (hours, minutes, seconds)，\n        分别表示小时、分钟和秒。\n\n    Examples:\n        >>> convert_seconds(3665)\n        (1, 1, 5)\n        >>> convert_seconds(45)\n        (0, 0, 45)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n\n    return hours, minutes, seconds"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if b.count('@') == 1:\n        c = b.split('@')\n        if len(c) == 2:\n            d = c[0]\n            e = c[1]\n            if d and e:\n                if '.' in e:\n                    f = e.split('.')\n                    if len(f) >= 2:\n                        g = True\n                        for h in f:\n                            if not h:\n                                g = False\n                        if g:\n                            i = True\n                            for j in b:\n                                if not (j.isalnum() or j in '._-@'):\n                                    i = False\n                            if i:\n                                if b[0].isalnum() and b[-1].isalnum():\n                                    x = True\n    return x", "output": "\"\"\"Email address validation module.\n\nThis module provides a function to validate email addresses based on\nbasic syntax rules.\n\"\"\"\n\nimport re\nfrom typing import Union\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Validates an email address based on basic syntax rules.\n\n    The function checks:\n    1. Exactly one '@' symbol exists\n    2. Both local part and domain are non-empty\n    3. Domain contains at least one '.'\n    4. All domain parts are non-empty\n    5. Contains only allowed characters (alphanumeric, '.', '_', '-', '@')\n    6. Starts and ends with alphanumeric characters\n\n    Args:\n        email: The email address string to validate.\n\n    Returns:\n        True if the email address passes all validation checks, False otherwise.\n\n    Examples:\n        >>> is_valid_email('user@example.com')\n        True\n        >>> is_valid_email('invalid@email')\n        False\n        >>> is_valid_email('@example.com')\n        False\n    \"\"\"\n    # Check for exactly one '@' symbol\n    if email.count('@') != 1:\n        return False\n\n    # Split into local part and domain\n    local_part, domain = email.split('@')\n\n    # Ensure both parts are non-empty\n    if not local_part or not domain:\n        return False\n\n    # Check domain contains at least one dot\n    if '.' not in domain:\n        return False\n\n    # Split domain into parts and ensure all are non-empty\n    domain_parts = domain.split('.')\n    if len(domain_parts) < 2 or any(not part for part in domain_parts):\n        return False\n\n    # Validate allowed characters\n    allowed_chars_pattern = re.compile(r'^[a-zA-Z0-9._\\-@]+$')\n    if not allowed_chars_pattern.match(email):\n        return False\n\n    # Ensure email starts and ends with alphanumeric characters\n    if not (email[0].isalnum() and email[-1].isalnum()):\n        return False\n\n    return True"}
{"origin_topic": "将字符串中的所有数字相加", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    for c in b:\n        if c.isdigit():\n            d = int(c)\n            x = x + d\n        else:\n            continue\n    return x", "output": "from typing import Iterable\n\n\ndef sum_digits_in_string(string: str) -> int:\n    \"\"\"计算字符串中所有数字字符的数值总和。\n\n    遍历输入字符串中的每个字符，如果字符是数字（0-9），则将其转换为整数并累加。\n    非数字字符将被忽略。\n\n    Args:\n        string: 包含数字字符的输入字符串。\n\n    Returns:\n        字符串中所有数字字符的数值总和。如果字符串中没有数字，则返回0。\n\n    Examples:\n        >>> sum_digits_in_string(\"a1b2c3\")\n        6\n        >>> sum_digits_in_string(\"hello\")\n        0\n        >>> sum_digits_in_string(\"123\")\n        6\n    \"\"\"\n    total = 0\n    for character in string:\n        if character.isdigit():\n            digit_value = int(character)\n            total += digit_value\n    return total"}
{"origin_topic": "验证邮箱地址的简单格式（包含'@'和'.'）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(email_string):\n    result_flag = False\n    if email_string is not None:\n        if isinstance(email_string, str):\n            if len(email_string) > 0:\n                at_symbol_present = False\n                dot_symbol_present = False\n                for individual_character in email_string:\n                    if individual_character == '@':\n                        at_symbol_present = True\n                    if individual_character == '.':\n                        dot_symbol_present = True\n                if at_symbol_present == True and dot_symbol_present == True:\n                    result_flag = True\n                else:\n                    result_flag = False\n            else:\n                result_flag = False\n        else:\n            result_flag = False\n    else:\n        result_flag = False\n    return result_flag", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"Check if the given string is a valid email address format.\n    \n    This function performs basic email format validation by checking:\n    1. The input is a non-empty string\n    2. Contains both '@' and '.' characters\n    \n    Note: This is a basic validation and does not check RFC compliance or\n    domain existence. For production use, consider using a dedicated\n    email validation library.\n    \n    Args:\n        email: The email address string to validate. Can be None.\n        \n    Returns:\n        True if the email format is valid, False otherwise.\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid-email\")\n        False\n        >>> is_valid_email(None)\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    # Early return for invalid inputs\n    if not isinstance(email, str) or not email:\n        return False\n    \n    # Check for required characters\n    has_at_symbol = '@' in email\n    has_dot_symbol = '.' in email\n    \n    return has_at_symbol and has_dot_symbol"}
{"origin_topic": "判断一个年份是否为闰年", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_year(x):\n    if x % 4 == 0:\n        if x % 100 == 0:\n            if x % 400 == 0:\n                return True\n            else:\n                return False\n        else:\n            return True\n    else:\n        return False", "output": "def is_leap_year(year: int) -> bool:\n    \"\"\"Determines if a given year is a leap year.\n\n    A leap year occurs:\n    - Every year divisible by 4,\n    - Except years divisible by 100,\n    - Unless they are also divisible by 400.\n\n    Args:\n        year: The year to check. Must be a positive integer.\n\n    Returns:\n        True if the year is a leap year, False otherwise.\n\n    Raises:\n        ValueError: If the input year is not a positive integer.\n    \"\"\"\n    if not isinstance(year, int) or year <= 0:\n        raise ValueError(\"Year must be a positive integer.\")\n\n    divisible_by_4 = year % 4 == 0\n    divisible_by_100 = year % 100 == 0\n    divisible_by_400 = year % 400 == 0\n\n    return divisible_by_4 and (not divisible_by_100 or divisible_by_400)"}
{"origin_topic": "检查一个字符串是否以元音开头和结尾", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(a):\n    b = a.lower()\n    x = False\n    if len(b) > 0:\n        if b[0] in 'aeiou':\n            if b[-1] in 'aeiou':\n                x = True\n            else:\n                x = False\n        else:\n            x = False\n    else:\n        x = False\n    return x", "output": "def check_string_starts_and_ends_with_vowel(text: str) -> bool:\n    \"\"\"检查字符串是否以元音字母开头和结尾（不区分大小写）。\n\n    该函数检查给定的字符串是否同时满足以下条件：\n    1. 非空字符串\n    2. 第一个字符是元音字母（a, e, i, o, u）\n    3. 最后一个字符是元音字母（a, e, i, o, u）\n\n    Args:\n        text: 要检查的输入字符串。\n\n    Returns:\n        True 如果字符串非空且以元音字母开头和结尾，否则返回 False。\n\n    Examples:\n        >>> check_string_starts_and_ends_with_vowel(\"apple\")\n        True\n        >>> check_string_starts_and_ends_with_vowel(\"Orange\")\n        True\n        >>> check_string_starts_and_ends_with_vowel(\"banana\")\n        False\n        >>> check_string_starts_and_ends_with_vowel(\"\")\n        False\n    \"\"\"\n    if not text:\n        return False\n\n    normalized_text = text.lower()\n    vowels = set('aeiou')\n    \n    return (normalized_text[0] in vowels and \n            normalized_text[-1] in vowels)"}
{"origin_topic": "将字符串中的元音字母替换为'*'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    v = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    r = ''\n    for c in s:\n        t = False\n        for vc in v:\n            if c == vc:\n                t = True\n                break\n        if t:\n            r = r + '*'\n        else:\n            r = r + c\n    return r", "output": "def replace_vowels_with_asterisk(input_string: str) -> str:\n    \"\"\"Replaces all vowel characters in a string with asterisks.\n    \n    Both lowercase and uppercase vowels (a, e, i, o, u) are replaced with '*'.\n    All other characters remain unchanged.\n    \n    Args:\n        input_string: The string to process.\n        \n    Returns:\n        A new string with all vowels replaced by '*'.\n        \n    Examples:\n        >>> replace_vowels_with_asterisk(\"Hello World\")\n        'H*ll* W*rld'\n        >>> replace_vowels_with_asterisk(\"Python\")\n        'Pyth*n'\n        >>> replace_vowels_with_asterisk(\"AEIOU\")\n        '*****'\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result_chars = []\n    \n    for character in input_string:\n        if character in vowels:\n            result_chars.append('*')\n        else:\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "移除字符串中的所有空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(x):\n    y = \"\"\n    for a in x:\n        if a != \" \":\n            y = y + a\n    return y", "output": "def remove_spaces(input_string: str) -> str:\n    \"\"\"Removes all space characters from the input string.\n\n    This function iterates through each character in the input string and\n    concatenates only non-space characters to build the output string.\n\n    Args:\n        input_string: The string from which spaces will be removed.\n\n    Returns:\n        A new string containing all characters from the input string\n        except space characters.\n\n    Example:\n        >>> remove_spaces(\"hello world\")\n        'helloworld'\n        >>> remove_spaces(\"  test  string  \")\n        'teststring'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character != \" \":\n            result += character\n    return result"}
{"origin_topic": "验证邮箱地址格式是否合法（简单规则：包含@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = False\n    d = 0\n    e = 0\n    for f in b:\n        if f == '@':\n            d = d + 1\n        if f == '.':\n            e = e + 1\n    if d == 1:\n        if e >= 1:\n            g = b.split('@')\n            h = g[0]\n            i = g[1]\n            if len(h) > 0:\n                if len(i) > 0:\n                    j = i.split('.')\n                    if len(j) > 1:\n                        k = j[-1]\n                        if len(k) > 0:\n                            c = True\n    return c", "output": "from typing import Union\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"验证电子邮件地址的基本格式是否有效。\n    \n    执行基本的电子邮件格式验证，检查：\n    1. 包含且仅包含一个 '@' 符号\n    2. '@' 前后都有非空内容\n    3. 域名部分至少包含一个 '.' 符号\n    4. 顶级域名（最后一个 '.' 后的部分）非空\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果电子邮件地址符合基本格式要求则返回 True，否则返回 False\n        \n    Examples:\n        >>> is_valid_email('user@example.com')\n        True\n        >>> is_valid_email('invalid.email')\n        False\n        >>> is_valid_email('user@.com')\n        False\n    \"\"\"\n    # 统计 '@' 和 '.' 的数量\n    at_count = 0\n    dot_count = 0\n    \n    for char in email:\n        if char == '@':\n            at_count += 1\n        elif char == '.':\n            dot_count += 1\n    \n    # 基本格式检查\n    if at_count != 1:\n        return False\n    \n    if dot_count < 1:\n        return False\n    \n    # 分割本地部分和域名部分\n    try:\n        local_part, domain_part = email.split('@')\n    except ValueError:\n        return False\n    \n    # 检查本地部分和域名部分是否非空\n    if not local_part or not domain_part:\n        return False\n    \n    # 分割域名部分并检查顶级域名\n    domain_parts = domain_part.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    top_level_domain = domain_parts[-1]\n    if not top_level_domain:\n        return False\n    \n    return True"}
{"origin_topic": "将时间从秒转换为小时、分钟、秒格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_time(a):\n    b = 0\n    x = 0\n    while a >= 3600:\n        a = a - 3600\n        b = b + 1\n    while a >= 60:\n        a = a - 60\n        x = x + 1\n    return b, x, a", "output": "def convert_seconds_to_hms(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"将总秒数转换为小时、分钟、秒的元组。\n\n    该函数将输入的总秒数分解为小时、分钟和秒的整数部分，\n    遵循标准的时间转换规则（1小时=3600秒，1分钟=60秒）。\n\n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）。\n\n    Returns:\n        包含三个整数的元组 (hours, minutes, seconds)，分别表示：\n        - hours: 完整的小时数\n        - minutes: 完整的分钟数（0-59）\n        - seconds: 剩余的秒数（0-59）\n\n    Examples:\n        >>> convert_seconds_to_hms(3665)\n        (1, 1, 5)\n        >>> convert_seconds_to_hms(59)\n        (0, 0, 59)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    \n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    \n    return hours, minutes, seconds"}
{"origin_topic": "计算斐波那契数列前n项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_fibonacci_sequence_up_to_n_terms(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    else:\n        a = 0\n        b = 1\n        x = [a, b]\n        for i in range(2, n):\n            c = a + b\n            x.append(c)\n            a = b\n            b = c\n        return x", "output": "from typing import List\n\n\ndef generate_fibonacci_sequence(term_count: int) -> List[int]:\n    \"\"\"Generates a Fibonacci sequence with the specified number of terms.\n\n    The Fibonacci sequence starts with 0 and 1. Each subsequent term is the\n    sum of the two preceding terms.\n\n    Args:\n        term_count: The number of terms to generate in the sequence.\n            Must be a non-negative integer.\n\n    Returns:\n        A list containing the first `term_count` Fibonacci numbers.\n        Returns an empty list if `term_count` is 0.\n\n    Raises:\n        ValueError: If `term_count` is negative.\n\n    Examples:\n        >>> generate_fibonacci_sequence(0)\n        []\n        >>> generate_fibonacci_sequence(1)\n        [0]\n        >>> generate_fibonacci_sequence(5)\n        [0, 1, 1, 2, 3]\n    \"\"\"\n    if term_count < 0:\n        raise ValueError(\"term_count must be non-negative\")\n\n    if term_count == 0:\n        return []\n    if term_count == 1:\n        return [0]\n    if term_count == 2:\n        return [0, 1]\n\n    sequence = [0, 1]\n    previous_term, current_term = 0, 1\n\n    for _ in range(2, term_count):\n        next_term = previous_term + current_term\n        sequence.append(next_term)\n        previous_term, current_term = current_term, next_term\n\n    return sequence"}
{"origin_topic": "将给定的摄氏温度转换为华氏温度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a * 9\n    b = b / 5\n    b = b + 32\n    x = b\n    return x", "output": "def celsius_to_fahrenheit(celsius: float) -> float:\n    \"\"\"Convert temperature from Celsius to Fahrenheit.\n\n    Args:\n        celsius: Temperature in degrees Celsius.\n\n    Returns:\n        Temperature in degrees Fahrenheit.\n\n    Formula:\n        Fahrenheit = (Celsius × 9/5) + 32\n    \"\"\"\n    fahrenheit = celsius * 9 / 5 + 32\n    return fahrenheit"}
{"origin_topic": "将字符串中的所有单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b.split():\n        e = ''\n        for f in range(len(d)):\n            if f == 0:\n                e = e + d[f].upper()\n            else:\n                e = e + d[f].lower()\n        c.append(e)\n    return ' '.join(c)", "output": "def capitalize_words(text: str) -> str:\n    \"\"\"Capitalize the first letter of each word and lowercase the rest.\n    \n    Args:\n        text: Input string containing words separated by whitespace.\n        \n    Returns:\n        String with each word capitalized (first letter uppercase, rest lowercase).\n        \n    Examples:\n        >>> capitalize_words('hello world')\n        'Hello World'\n        >>> capitalize_words('PYTHON programming')\n        'Python Programming'\n    \"\"\"\n    capitalized_words = []\n    \n    for word in text.split():\n        # Capitalize first character, lowercase the rest\n        processed_word = word[0].upper() + word[1:].lower()\n        capitalized_words.append(processed_word)\n    \n    return ' '.join(capitalized_words)"}
{"origin_topic": "验证邮箱地址格式（包含'@'和'.'）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    if '@' in a:\n        x = a.split('@')\n        if len(x) > 1:\n            y = x[1]\n            if '.' in y:\n                z = y.split('.')\n                if len(z) > 1:\n                    for i in z:\n                        if i != '':\n                            b = True\n                        else:\n                            b = False\n                            break\n    return b", "output": "def is_valid_email_domain(email: str) -> bool:\n    \"\"\"验证电子邮件地址的域名部分是否有效。\n    \n    域名有效性规则：\n    1. 必须包含'@'符号\n    2. '@'后必须有内容\n    3. 域名必须包含至少一个'.'\n    4. 域名各部分不能为空\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果域名部分有效则返回True，否则返回False\n        \n    Examples:\n        >>> is_valid_email_domain('user@example.com')\n        True\n        >>> is_valid_email_domain('user@example')\n        False\n        >>> is_valid_email_domain('user@.com')\n        False\n        >>> is_valid_email_domain('user@example..com')\n        False\n    \"\"\"\n    # 检查是否包含@符号\n    if '@' not in email:\n        return False\n    \n    # 分割用户名和域名部分\n    parts = email.split('@')\n    if len(parts) < 2:\n        return False\n    \n    domain = parts[1]\n    \n    # 检查域名是否包含点号\n    if '.' not in domain:\n        return False\n    \n    # 分割域名各部分并验证\n    domain_parts = domain.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    # 检查域名各部分是否非空\n    for part in domain_parts:\n        if not part:\n            return False\n    \n    return True"}
{"origin_topic": "验证邮箱地址格式是否有效", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    if not isinstance(b, str):\n        return False\n    x = len(b)\n    if x == 0:\n        return False\n    y = b.find('@')\n    if y == -1:\n        return False\n    if y == 0:\n        return False\n    if y == x - 1:\n        return False\n    z = b.find('.', y)\n    if z == -1:\n        return False\n    if z == y + 1:\n        return False\n    if z == x - 1:\n        return False\n    p = b.split('@')\n    if len(p) != 2:\n        return False\n    q = p[1].split('.')\n    if len(q) < 2:\n        return False\n    r = p[0]\n    if len(r) == 0:\n        return False\n    s = q[-1]\n    if len(s) == 0:\n        return False\n    if len(s) < 2:\n        return False\n    for t in r:\n        if not (t.isalnum() or t in ['.', '_', '-']):\n            return False\n    for u in p[1]:\n        if not (u.isalnum() or u in ['.', '-']):\n            return False\n    return True", "output": "\"\"\"Email validation module.\n\nThis module provides a function to validate email addresses according to\nbasic email format requirements.\n\"\"\"\n\nimport re\nfrom typing import Union\n\n\ndef is_valid_email(email: Union[str, bytes]) -> bool:\n    \"\"\"Validates if the given input is a properly formatted email address.\n\n    This function performs basic email format validation including:\n    - Must be a string\n    - Must contain exactly one '@' character\n    - Local part (before '@') must not be empty\n    - Domain part (after '@') must contain at least one '.'\n    - Top-level domain must be at least 2 characters\n    - Local part can contain alphanumeric characters and [., _, -]\n    - Domain part can contain alphanumeric characters and [., -]\n\n    Args:\n        email: The email address to validate. Can be string or bytes.\n\n    Returns:\n        True if the email address is valid, False otherwise.\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email\")\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    # Convert bytes to string if necessary\n    if isinstance(email, bytes):\n        email = email.decode('utf-8')\n    \n    # Ensure input is a string\n    if not isinstance(email, str):\n        return False\n    \n    # Check for empty string\n    if not email:\n        return False\n    \n    # Split email into local and domain parts\n    if '@' not in email:\n        return False\n    \n    local_part, domain_part = email.split('@', 1)\n    \n    # Validate local part\n    if not local_part:\n        return False\n    \n    # Validate domain part\n    if not domain_part:\n        return False\n    \n    # Domain must contain at least one dot\n    if '.' not in domain_part:\n        return False\n    \n    # Split domain into subdomains and TLD\n    domain_parts = domain_part.split('.')\n    \n    # Must have at least domain and TLD\n    if len(domain_parts) < 2:\n        return False\n    \n    # Validate TLD length\n    top_level_domain = domain_parts[-1]\n    if len(top_level_domain) < 2:\n        return False\n    \n    # Validate local part characters\n    # Can contain alphanumeric, dot, underscore, or hyphen\n    local_part_pattern = r'^[a-zA-Z0-9._-]+$'\n    if not re.match(local_part_pattern, local_part):\n        return False\n    \n    # Validate domain part characters\n    # Can contain alphanumeric, dot, or hyphen\n    domain_pattern = r'^[a-zA-Z0-9.-]+$'\n    if not re.match(domain_pattern, domain_part):\n        return False\n    \n    # Additional domain validation\n    # Domain parts cannot start or end with hyphen or dot\n    for part in domain_parts:\n        if not part or part.startswith('-') or part.endswith('-') or part.startswith('.') or part.endswith('.'):\n            return False\n    \n    # Local part cannot start or end with dot\n    if local_part.startswith('.') or local_part.endswith('.'):\n        return False\n    \n    # Local part cannot have consecutive dots\n    if '..' in local_part:\n        return False\n    \n    # Domain cannot have consecutive dots or hyphens\n    if '..' in domain_part or '--' in domain_part:\n        return False\n    \n    return True"}
{"origin_topic": "将字符串中的所有元音字母替换为'*'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for c in s:\n        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' or c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U':\n            r = r + '*'\n        else:\n            r = r + c\n    return r", "output": "def replace_vowels_with_asterisk(text: str) -> str:\n    \"\"\"Replaces all vowel characters (both lowercase and uppercase) with asterisks.\n    \n    Args:\n        text: The input string to process.\n        \n    Returns:\n        A new string where all vowels (a, e, i, o, u, A, E, I, O, U) \n        are replaced with '*' characters.\n        \n    Examples:\n        >>> replace_vowels_with_asterisk(\"Hello World\")\n        'H*ll* W*rld'\n        >>> replace_vowels_with_asterisk(\"AEIOU\")\n        '*****'\n        >>> replace_vowels_with_asterisk(\"\")\n        ''\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result_chars = []\n    \n    for character in text:\n        if character in vowels:\n            result_chars.append('*')\n        else:\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "检查字符串是否为回文（忽略大小写和空格）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    t = \"\"\n    for c in s:\n        if c != \" \":\n            t = t + c\n    u = t.lower()\n    v = \"\"\n    for i in range(len(u) - 1, -1, -1):\n        v = v + u[i]\n    if u == v:\n        return True\n    else:\n        return False", "output": "def is_palindrome(text: str) -> bool:\n    \"\"\"Check if a string is a palindrome ignoring case and spaces.\n    \n    A palindrome is a string that reads the same forwards and backwards.\n    This function ignores:\n    - Case (converts to lowercase)\n    - Spaces (removes all spaces)\n    \n    Args:\n        text: The input string to check.\n        \n    Returns:\n        True if the cleaned string is a palindrome, False otherwise.\n        \n    Examples:\n        >>> is_palindrome(\"A man a plan a canal Panama\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"racecar\")\n        True\n    \"\"\"\n    # Remove spaces and convert to lowercase\n    cleaned_text = \"\".join(char.lower() for char in text if char != \" \")\n    \n    # Check if the cleaned text is equal to its reverse\n    return cleaned_text == cleaned_text[::-1]"}
{"origin_topic": "将字符串中的单词反转顺序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = s.split()\n    c = len(b)\n    d = c - 1\n    while d >= 0:\n        e = b[d]\n        a.append(e)\n        d = d - 1\n    x = ' '.join(a)\n    return x", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n    \n    Words are defined as sequences of characters separated by whitespace.\n    The function preserves the original whitespace between words.\n    \n    Args:\n        sentence: Input string containing words to be reversed.\n        \n    Returns:\n        A new string with words in reverse order.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"Python is awesome\")\n        'awesome is Python'\n    \"\"\"\n    words = sentence.split()\n    reversed_words = []\n    \n    # Iterate through words in reverse order\n    for i in range(len(words) - 1, -1, -1):\n        reversed_words.append(words[i])\n    \n    return ' '.join(reversed_words)"}
{"origin_topic": "计算字符串中元音字母的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    c = 0\n    for x in s:\n        if x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U':\n            c = c + 1\n        else:\n            c = c + 0\n    return c", "output": "def count_vowels(text: str) -> int:\n    \"\"\"Count the number of vowels (both lowercase and uppercase) in a string.\n\n    Args:\n        text: The input string to analyze.\n\n    Returns:\n        The total count of vowels (a, e, i, o, u) in the input string,\n        case-insensitive.\n\n    Examples:\n        >>> count_vowels(\"Hello World\")\n        3\n        >>> count_vowels(\"Python\")\n        1\n        >>> count_vowels(\"AEIOU\")\n        5\n    \"\"\"\n    vowel_set = {'a', 'e', 'i', 'o', 'u'}\n    vowel_count = 0\n    \n    for character in text:\n        if character.lower() in vowel_set:\n            vowel_count += 1\n    \n    return vowel_count"}
{"origin_topic": "验证邮箱格式是否合法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                x = a.split('@')\n                if len(x) == 2:\n                    y = x[1].split('.')\n                    if len(y) >= 2:\n                        for z in y:\n                            if len(z) == 0:\n                                b = False\n                                break\n                        else:\n                            if len(x[0]) > 0:\n                                b = True\n    return b", "output": "from typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证字符串是否为有效的电子邮件地址格式。\n\n    验证规则：\n    1. 输入不能为None\n    2. 必须包含且仅包含一个'@'符号\n    3. '@'符号前必须有内容\n    4. '@'符号后必须包含至少一个'.'符号\n    5. 域名部分（'.'分隔的各个部分）都不能为空\n\n    Args:\n        email: 待验证的电子邮件地址字符串，可为None\n\n    Returns:\n        bool: 如果符合电子邮件格式返回True，否则返回False\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"user@com\")\n        False\n        >>> is_valid_email(None)\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    if email is None:\n        return False\n\n    if not isinstance(email, str):\n        return False\n\n    if not email:\n        return False\n\n    # 分割本地部分和域名部分\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n\n    local_part, domain_part = parts\n\n    # 验证本地部分非空\n    if not local_part:\n        return False\n\n    # 验证域名部分\n    domain_segments = domain_part.split('.')\n    if len(domain_segments) < 2:\n        return False\n\n    # 验证所有域名段都非空\n    for segment in domain_segments:\n        if not segment:\n            return False\n\n    return True"}
{"origin_topic": "将时间从秒转换为时分秒格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = b // 3600\n    y = (b % 3600) // 60\n    z = b % 60\n    if x == 0 and y == 0 and z == 0:\n        return \"0:00:00\"\n    elif x == 0 and y == 0:\n        return f\"0:00:{z:02d}\"\n    elif x == 0:\n        return f\"0:{y:02d}:{z:02d}\"\n    else:\n        return f\"{x}:{y:02d}:{z:02d}\"", "output": "def format_duration(seconds: int) -> str:\n    \"\"\"将秒数格式化为 HH:MM:SS 时间字符串。\n\n    该函数将给定的秒数转换为小时、分钟和秒，并以标准时间格式\n    (HH:MM:SS) 返回。小时部分不补零，分钟和秒部分始终以两位数显示。\n\n    参数:\n        seconds: 需要格式化的总秒数（非负整数）\n\n    返回:\n        格式化的时间字符串，格式为 H:MM:SS 或 HH:MM:SS\n\n    示例:\n        >>> format_duration(0)\n        '0:00:00'\n        >>> format_duration(65)\n        '0:01:05'\n        >>> format_duration(3661)\n        '1:01:01'\n        >>> format_duration(45296)\n        '12:34:56'\n    \"\"\"\n    hours = seconds // 3600\n    minutes = (seconds % 3600) // 60\n    remaining_seconds = seconds % 60\n\n    # 使用单个格式化字符串简化条件逻辑\n    return f\"{hours}:{minutes:02d}:{remaining_seconds:02d}\""}
{"origin_topic": "将十进制数转换为二进制字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b\n    if d == 0:\n        return \"0\"\n    while d > 0:\n        e = d % 2\n        f = e\n        c.append(f)\n        g = d // 2\n        d = g\n    h = c[::-1]\n    i = \"\"\n    for j in h:\n        k = str(j)\n        i = i + k\n    return i", "output": "def decimal_to_binary(decimal_number: int) -> str:\n    \"\"\"Convert a decimal integer to its binary string representation.\n    \n    Args:\n        decimal_number: A non-negative integer to convert to binary.\n        \n    Returns:\n        A string representing the binary equivalent of the input number.\n        \n    Raises:\n        ValueError: If the input is negative.\n        \n    Examples:\n        >>> decimal_to_binary(10)\n        '1010'\n        >>> decimal_to_binary(0)\n        '0'\n    \"\"\"\n    if decimal_number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    current_number = decimal_number\n    \n    while current_number > 0:\n        remainder = current_number % 2\n        binary_digits.append(remainder)\n        current_number //= 2\n    \n    binary_digits.reverse()\n    binary_string = \"\".join(str(digit) for digit in binary_digits)\n    \n    return binary_string"}
{"origin_topic": "将字符串按空格分割并反转单词顺序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = s.split()\n    c = len(b)\n    d = c - 1\n    while d >= 0:\n        e = b[d]\n        a.append(e)\n        d = d - 1\n    x = ' '.join(a)\n    return x", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n    \n    Words are defined as sequences of characters separated by whitespace.\n    The function preserves the original whitespace between words.\n    \n    Args:\n        sentence: The input string containing words to be reversed.\n        \n    Returns:\n        A new string with words in reverse order.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"Python is great\")\n        'great is Python'\n    \"\"\"\n    words = sentence.split()\n    reversed_words = []\n    \n    # Iterate from the last word to the first\n    for i in range(len(words) - 1, -1, -1):\n        reversed_words.append(words[i])\n    \n    return ' '.join(reversed_words)"}
{"origin_topic": "将字符串中的所有数字提取出来", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = 0\n    while d < len(b):\n        e = b[d]\n        if e.isdigit():\n            f = e\n            g = d + 1\n            while g < len(b) and b[g].isdigit():\n                f = f + b[g]\n                g = g + 1\n            c.append(f)\n            d = g\n        else:\n            d = d + 1\n    return c", "output": "from typing import List\n\n\ndef extract_consecutive_digits(input_string: str) -> List[str]:\n    \"\"\"Extracts all consecutive digit sequences from a string.\n\n    This function scans through the input string and identifies all maximal\n    sequences of consecutive digit characters. Each sequence is returned as\n    a separate string in the result list.\n\n    Examples:\n        >>> extract_consecutive_digits(\"abc123def45gh6\")\n        ['123', '45', '6']\n        >>> extract_consecutive_digits(\"no digits here\")\n        []\n        >>> extract_consecutive_digits(\"123 456 789\")\n        ['123', '456', '789']\n\n    Args:\n        input_string: The string from which to extract digit sequences.\n\n    Returns:\n        A list of strings, each representing a maximal consecutive digit\n        sequence found in the input. Returns an empty list if no digits\n        are found.\n    \"\"\"\n    digit_sequences: List[str] = []\n    current_index = 0\n\n    while current_index < len(input_string):\n        current_char = input_string[current_index]\n\n        if current_char.isdigit():\n            # Start building a digit sequence\n            digit_sequence = current_char\n            next_index = current_index + 1\n\n            # Continue while we have consecutive digits\n            while next_index < len(input_string) and input_string[next_index].isdigit():\n                digit_sequence += input_string[next_index]\n                next_index += 1\n\n            digit_sequences.append(digit_sequence)\n            current_index = next_index  # Skip past the processed digits\n        else:\n            current_index += 1\n\n    return digit_sequences"}
{"origin_topic": "将字符串中的数字提取出来并求和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    for c in b:\n        if c.isdigit():\n            x.append(c)\n        else:\n            if len(x) > 0:\n                x.append(' ')\n    d = ''.join(x)\n    e = d.split()\n    f = 0\n    for g in e:\n        h = int(g)\n        f = f + h\n    return f", "output": "from typing import List, Union\n\n\ndef sum_numbers_from_string(text: str) -> int:\n    \"\"\"Extracts and sums all integer numbers from a given string.\n    \n    This function scans the input string character by character, extracts\n    consecutive digit sequences, converts them to integers, and returns\n    their sum. Non-digit characters are treated as separators between numbers.\n    \n    Args:\n        text: The input string containing numbers and other characters.\n        \n    Returns:\n        The sum of all integer numbers found in the input string.\n        \n    Examples:\n        >>> sum_numbers_from_string(\"abc123def45gh6\")\n        174\n        >>> sum_numbers_from_string(\"1 2 3\")\n        6\n        >>> sum_numbers_from_string(\"no numbers here\")\n        0\n    \"\"\"\n    # Step 1: Extract digit sequences with spaces as separators\n    digit_buffer: List[str] = []\n    for character in text:\n        if character.isdigit():\n            digit_buffer.append(character)\n        else:\n            # Add space separator when transitioning from digits to non-digits\n            if digit_buffer:\n                digit_buffer.append(' ')\n    \n    # Step 2: Convert buffer to string and split into number strings\n    numbers_string = ''.join(digit_buffer)\n    number_strings = numbers_string.split()\n    \n    # Step 3: Convert to integers and calculate sum\n    total_sum = 0\n    for number_str in number_strings:\n        number = int(number_str)\n        total_sum += number\n    \n    return total_sum"}
{"origin_topic": "检查一个字符串是否包含所有英文字母（大小写不敏感）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(s):\n    a = s.lower()\n    b = \"abcdefghijklmnopqrstuvwxyz\"\n    c = []\n    for d in b:\n        e = False\n        for f in a:\n            if f == d:\n                e = True\n                break\n        c.append(e)\n    g = True\n    for h in c:\n        if not h:\n            g = False\n            break\n    return g", "output": "def is_pangram(s: str) -> bool:\n    \"\"\"Check if a string contains all letters of the English alphabet.\n    \n    A pangram is a sentence containing every letter of the alphabet at least once.\n    This function is case-insensitive and ignores non-alphabetic characters.\n    \n    Args:\n        s: The input string to check.\n        \n    Returns:\n        True if the string contains all letters (a-z), False otherwise.\n        \n    Examples:\n        >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n        True\n        >>> is_pangram(\"Hello World\")\n        False\n    \"\"\"\n    normalized_string = s.lower()\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    \n    # Track presence of each letter in the alphabet\n    letter_present = []\n    for letter in alphabet:\n        found = False\n        for char in normalized_string:\n            if char == letter:\n                found = True\n                break\n        letter_present.append(found)\n    \n    # Check if all letters are present\n    is_all_present = True\n    for present in letter_present:\n        if not present:\n            is_all_present = False\n            break\n    \n    return is_all_present"}
{"origin_topic": "验证邮箱地址的格式是否正确", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                x = a.split('@')\n                if len(x) == 2:\n                    y = x[0]\n                    z = x[1]\n                    if y and z:\n                        if '.' in z:\n                            w = z.split('.')\n                            if len(w) >= 2:\n                                for part in w:\n                                    if part:\n                                        continue\n                                    else:\n                                        break\n                                else:\n                                    if a.count('@') == 1:\n                                        if not a.startswith('@'):\n                                            if not a.endswith('.'):\n                                                b = True\n    return b", "output": "from typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证字符串是否为有效的电子邮件地址格式。\n    \n    验证规则：\n    1. 输入不能为None\n    2. 必须包含且仅包含一个'@'符号\n    3. '@'符号不能出现在开头\n    4. 本地部分（@前）和域名部分（@后）都不能为空\n    5. 域名部分必须包含至少一个'.'符号\n    6. 域名部分不能以'.'结尾\n    7. 域名部分的每个子域都不能为空\n    \n    Args:\n        email: 待验证的字符串，可能为None\n        \n    Returns:\n        bool: 如果字符串符合电子邮件地址格式返回True，否则返回False\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"user@.com\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    if email is None:\n        return False\n    \n    if not isinstance(email, str):\n        return False\n    \n    # 检查是否包含且仅包含一个'@'符号\n    if email.count('@') != 1:\n        return False\n    \n    # 检查'@'符号位置\n    if email.startswith('@'):\n        return False\n    \n    # 分割本地部分和域名部分\n    local_part, domain_part = email.split('@')\n    \n    # 检查本地部分和域名部分是否为空\n    if not local_part or not domain_part:\n        return False\n    \n    # 检查域名部分是否以'.'结尾\n    if domain_part.endswith('.'):\n        return False\n    \n    # 检查域名部分是否包含'.'符号\n    if '.' not in domain_part:\n        return False\n    \n    # 分割域名部分并检查每个子域\n    subdomains = domain_part.split('.')\n    if len(subdomains) < 2:\n        return False\n    \n    # 检查每个子域是否为空\n    for subdomain in subdomains:\n        if not subdomain:\n            return False\n    \n    return True"}
{"origin_topic": "将字符串转换为驼峰命名", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = False\n    for e in b:\n        if e == '_' or e == '-':\n            d = True\n        else:\n            if d:\n                c.append(e.upper())\n                d = False\n            else:\n                c.append(e.lower())\n    f = ''.join(c)\n    g = list(f)\n    if g:\n        g[0] = g[0].lower()\n    h = ''.join(g)\n    return h", "output": "def to_camel_case(input_string: str) -> str:\n    \"\"\"Convert kebab-case or snake_case strings to camelCase.\n    \n    This function transforms strings with '-' or '_' separators into camelCase\n    format. The first character is always lowercased, and each character \n    following a separator is uppercased while removing the separator.\n    \n    Examples:\n        >>> to_camel_case(\"hello-world\")\n        'helloWorld'\n        >>> to_camel_case(\"hello_world\")\n        'helloWorld'\n        >>> to_camel_case(\"hello-world_example\")\n        'helloWorldExample'\n        >>> to_camel_case(\"\")\n        ''\n    \n    Args:\n        input_string: A string that may contain '-' or '_' separators.\n    \n    Returns:\n        A camelCase version of the input string.\n    \"\"\"\n    if not input_string:\n        return \"\"\n    \n    result_chars: list[str] = []\n    capitalize_next: bool = False\n    \n    for char in input_string:\n        if char == '_' or char == '-':\n            capitalize_next = True\n        else:\n            if capitalize_next:\n                result_chars.append(char.upper())\n                capitalize_next = False\n            else:\n                result_chars.append(char.lower())\n    \n    # Ensure first character is lowercase\n    if result_chars:\n        result_chars[0] = result_chars[0].lower()\n    \n    return ''.join(result_chars)"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件格式（简单规则）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    if b is None:\n        return False\n    if not isinstance(b, str):\n        return False\n    if len(b) == 0:\n        return False\n    if b.count('@') != 1:\n        return False\n    x = b.split('@')\n    if len(x) != 2:\n        return False\n    y = x[0]\n    z = x[1]\n    if len(y) == 0:\n        return False\n    if len(z) == 0:\n        return False\n    if '.' not in z:\n        return False\n    w = z.split('.')\n    if len(w) < 2:\n        return False\n    for part in w:\n        if len(part) == 0:\n            return False\n    return True", "output": "\"\"\"Email validation module.\n\nThis module provides a function to validate email addresses based on basic\nformatting rules.\n\"\"\"\n\nfrom typing import Union\n\n\ndef is_valid_email(email: Union[str, None]) -> bool:\n    \"\"\"Validates if the given string is a properly formatted email address.\n\n    This function performs basic email format validation by checking:\n    1. Input is a non-empty string\n    2. Contains exactly one '@' character\n    3. Has non-empty local part (before '@')\n    4. Has non-empty domain part (after '@')\n    5. Domain contains at least one '.' character\n    6. All domain parts separated by '.' are non-empty\n\n    Note: This is a basic validation and does not check for:\n    - RFC compliance\n    - DNS resolution\n    - Email deliverability\n    - Special characters in local part\n    - Maximum length constraints\n\n    Args:\n        email: The email address string to validate, or None.\n\n    Returns:\n        True if the email address meets basic format requirements, False otherwise.\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email\")\n        False\n        >>> is_valid_email(None)\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    # Early return for None or non-string inputs\n    if email is None or not isinstance(email, str):\n        return False\n\n    # Check for empty string\n    if not email:\n        return False\n\n    # Must contain exactly one '@' character\n    if email.count('@') != 1:\n        return False\n\n    # Split into local and domain parts\n    local_part, domain_part = email.split('@', maxsplit=1)\n\n    # Both parts must be non-empty\n    if not local_part or not domain_part:\n        return False\n\n    # Domain must contain at least one '.' character\n    if '.' not in domain_part:\n        return False\n\n    # Split domain into subdomains and check each part\n    domain_parts = domain_part.split('.')\n    if len(domain_parts) < 2:\n        return False\n\n    # All domain parts must be non-empty\n    return all(domain_parts)"}
{"origin_topic": "检查一个字符串是否为有效的电子邮件格式（简单检查）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(x):\n    if not isinstance(x, str):\n        return False\n    if len(x) == 0:\n        return False\n    if x.count('@') != 1:\n        return False\n    a = x.split('@')\n    if len(a) != 2:\n        return False\n    b = a[0]\n    c = a[1]\n    if len(b) == 0:\n        return False\n    if len(c) == 0:\n        return False\n    if '.' not in c:\n        return False\n    d = c.split('.')\n    if len(d) < 2:\n        return False\n    for part in d:\n        if len(part) == 0:\n            return False\n    return True", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Union\n\n\ndef is_valid_email(email: Union[str, bytes]) -> bool:\n    \"\"\"Validates if the input string follows basic email format rules.\n    \n    This function performs basic email format validation by checking:\n    1. Input is a string type\n    2. Contains exactly one '@' character\n    3. Both local-part and domain are non-empty\n    4. Domain contains at least one '.' character\n    5. All domain parts separated by '.' are non-empty\n    \n    Note: This is a basic format check and does NOT validate:\n    - RFC 5322 compliance\n    - DNS resolution of domain\n    - Email deliverability\n    - Special characters in local-part\n    \n    Args:\n        email: The email address to validate. Can be string or bytes.\n        \n    Returns:\n        True if the email format is valid, False otherwise.\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email\")\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    # Convert bytes to string if necessary\n    if isinstance(email, bytes):\n        email = email.decode('utf-8', errors='ignore')\n    \n    if not isinstance(email, str):\n        return False\n    \n    if not email:\n        return False\n    \n    # Must contain exactly one '@' character\n    if email.count('@') != 1:\n        return False\n    \n    # Split into local-part and domain\n    local_part, domain = email.split('@', 1)\n    \n    # Both parts must be non-empty\n    if not local_part or not domain:\n        return False\n    \n    # Domain must contain at least one dot\n    if '.' not in domain:\n        return False\n    \n    # Split domain into parts and ensure all are non-empty\n    domain_parts = domain.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    return all(part for part in domain_parts)"}
{"origin_topic": "验证信用卡号", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    for x in str(a):\n        b.append(int(x))\n    c = []\n    for i in range(len(b) - 2, -1, -2):\n        d = b[i] * 2\n        if d > 9:\n            e = str(d)\n            f = int(e[0]) + int(e[1])\n            c.append(f)\n        else:\n            c.append(d)\n    g = 0\n    for h in range(len(b) - 1, -1, -2):\n        c.append(b[h])\n    for j in c:\n        g = g + j\n    k = g % 10\n    if k == 0:\n        return True\n    else:\n        return False", "output": "\"\"\"Luhn algorithm implementation for credit card number validation.\"\"\"\n\ndef is_valid_luhn_number(number: int) -> bool:\n    \"\"\"Validates a number using the Luhn algorithm.\n    \n    The Luhn algorithm (also known as the \"modulus 10\" algorithm) is used to\n    validate identification numbers such as credit card numbers.\n    \n    Args:\n        number: The integer to validate.\n        \n    Returns:\n        True if the number is valid according to the Luhn algorithm,\n        False otherwise.\n        \n    Example:\n        >>> is_valid_luhn_number(4539148803436467)\n        True\n        >>> is_valid_luhn_number(4539148803436468)\n        False\n    \"\"\"\n    # Convert number to list of digits\n    digits = [int(digit) for digit in str(number)]\n    \n    # Process every second digit from the right (starting from second-to-last)\n    processed_digits = []\n    for i in range(len(digits) - 2, -1, -2):\n        doubled_digit = digits[i] * 2\n        \n        if doubled_digit > 9:\n            # Sum the digits of numbers greater than 9\n            digit_sum = sum(int(d) for d in str(doubled_digit))\n            processed_digits.append(digit_sum)\n        else:\n            processed_digits.append(doubled_digit)\n    \n    # Add the remaining digits (every second digit from the right, starting from last)\n    for i in range(len(digits) - 1, -1, -2):\n        processed_digits.append(digits[i])\n    \n    # Calculate total sum\n    total_sum = sum(processed_digits)\n    \n    # Check if total sum is divisible by 10\n    return total_sum % 10 == 0"}
{"origin_topic": "计算一个数字的立方", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_cube_of_number(x):\n    a = x\n    b = a * a\n    c = b * a\n    d = c\n    result = d\n    return result", "output": "def calculate_cube_of_number(number: float) -> float:\n    \"\"\"计算给定数字的立方值。\n    \n    该函数接收一个数字作为输入，返回该数字的三次方（立方）值。\n    \n    Args:\n        number: 需要计算立方的数字\n        \n    Returns:\n        输入数字的立方值\n        \n    Raises:\n        TypeError: 如果输入不是数字类型\n        \n    Examples:\n        >>> calculate_cube_of_number(3)\n        27.0\n        >>> calculate_cube_of_number(-2)\n        -8.0\n        >>> calculate_cube_of_number(1.5)\n        3.375\n    \"\"\"\n    if not isinstance(number, (int, float)):\n        raise TypeError(f\"输入必须是数字类型，但收到 {type(number).__name__}\")\n    \n    square = number * number\n    cube = square * number\n    \n    return cube"}
{"origin_topic": "将字符串中的每个单词倒序（如'hello world'变为'olleh dlrow'）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b.split()\n    for e in d:\n        f = ''\n        g = len(e)\n        h = g - 1\n        while h >= 0:\n            f = f + e[h]\n            h = h - 1\n        c.append(f)\n    i = ' '.join(c)\n    return i", "output": "def reverse_words(text: str) -> str:\n    \"\"\"反转字符串中每个单词的字符顺序。\n    \n    该函数接收一个字符串，将其按空格分割为单词，反转每个单词的字符顺序，\n    然后将反转后的单词重新组合为字符串返回。\n    \n    Args:\n        text: 需要处理的输入字符串。\n        \n    Returns:\n        处理后的字符串，其中每个单词的字符顺序被反转。\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'olleh dlrow'\n        >>> reverse_words(\"Python programming\")\n        'nohtyP gnimmargorp'\n    \"\"\"\n    reversed_words = []\n    words = text.split()\n    \n    for word in words:\n        reversed_word = ''\n        word_length = len(word)\n        index = word_length - 1\n        \n        while index >= 0:\n            reversed_word += word[index]\n            index -= 1\n        \n        reversed_words.append(reversed_word)\n    \n    result = ' '.join(reversed_words)\n    return result"}
{"origin_topic": "统计一个文本文件中单词的数量（假设输入为字符串）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_words_in_file(a):\n    b = 0\n    x = a.split()\n    for y in x:\n        b = b + 1\n    return b", "output": "from typing import List\n\n\ndef count_words_in_file(file_content: str) -> int:\n    \"\"\"Count the number of words in a given string.\n\n    Words are defined as sequences of characters separated by whitespace.\n    This follows the same logic as Python's str.split() method.\n\n    Args:\n        file_content: The string content to analyze.\n\n    Returns:\n        The total number of words in the input string.\n\n    Examples:\n        >>> count_words_in_file(\"Hello world\")\n        2\n        >>> count_words_in_file(\"\")\n        0\n        >>> count_words_in_file(\"  multiple   spaces   \")\n        3\n    \"\"\"\n    words: List[str] = file_content.split()\n    word_count: int = len(words)\n    return word_count"}
{"origin_topic": "将字符串中的所有元音字母移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def remove_vowels_from_string(input_string):\n    vowels = \"aeiouAEIOU\"\n    result_string = \"\"\n    for character in input_string:\n        found_vowel = False\n        for vowel in vowels:\n            if character == vowel:\n                found_vowel = True\n                break\n        if not found_vowel:\n            result_string = result_string + character\n    return result_string", "output": "def remove_vowels_from_string(input_string: str) -> str:\n    \"\"\"Removes all vowels (both lowercase and uppercase) from the input string.\n    \n    Args:\n        input_string: The string from which vowels should be removed.\n        \n    Returns:\n        A new string with all vowels removed.\n        \n    Examples:\n        >>> remove_vowels_from_string(\"Hello World\")\n        'Hll Wrld'\n        >>> remove_vowels_from_string(\"Python Programming\")\n        'Pythn Prgrmmng'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    vowel_set = set(vowels)\n    result_chars = []\n    \n    for character in input_string:\n        if character not in vowel_set:\n            result_chars.append(character)\n    \n    return \"\".join(result_chars)"}
{"origin_topic": "将字符串反转（使用切片）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    x = len(a) - 1\n    while x >= 0:\n        b = b + a[x]\n        x = x - 1\n    return b", "output": "def reverse_string(input_string: str) -> str:\n    \"\"\"Reverses the order of characters in a given string.\n    \n    Args:\n        input_string: The original string to be reversed.\n        \n    Returns:\n        A new string with characters in reverse order.\n        \n    Examples:\n        >>> reverse_string(\"hello\")\n        'olleh'\n        >>> reverse_string(\"\")\n        ''\n        >>> reverse_string(\"a\")\n        'a'\n    \"\"\"\n    reversed_chars = []\n    \n    # Iterate from the last character to the first\n    for i in range(len(input_string) - 1, -1, -1):\n        reversed_chars.append(input_string[i])\n    \n    return ''.join(reversed_chars)"}
{"origin_topic": "将一个字符串中的所有空格替换为下划线", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y == \" \":\n            x = x + \"_\"\n        else:\n            x = x + y\n    return x", "output": "def replace_spaces_with_underscores(input_string: str) -> str:\n    \"\"\"Replaces all space characters with underscores in the given string.\n\n    Args:\n        input_string: The string to process. Spaces will be replaced with underscores.\n\n    Returns:\n        A new string with all spaces replaced by underscores.\n\n    Examples:\n        >>> replace_spaces_with_underscores(\"hello world\")\n        'hello_world'\n        >>> replace_spaces_with_underscores(\"multiple   spaces\")\n        'multiple___spaces'\n        >>> replace_spaces_with_underscores(\"no_spaces\")\n        'no_spaces'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character == \" \":\n            result += \"_\"\n        else:\n            result += character\n    return result"}
{"origin_topic": "对字典按值进行降序排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value_descending(input_dict):\n    sorted_items = []\n    for key, value in input_dict.items():\n        sorted_items.append((key, value))\n    for i in range(len(sorted_items)):\n        for j in range(i + 1, len(sorted_items)):\n            if sorted_items[i][1] < sorted_items[j][1]:\n                temp = sorted_items[i]\n                sorted_items[i] = sorted_items[j]\n                sorted_items[j] = temp\n    result_dict = {}\n    for item in sorted_items:\n        result_dict[item[0]] = item[1]\n    return result_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary keys\n\n\ndef sort_dict_by_value_descending(input_dict: Dict[T, Any]) -> Dict[T, Any]:\n    \"\"\"Sorts a dictionary by its values in descending order.\n\n    This function creates a new dictionary with the same key-value pairs as the\n    input dictionary, but sorted by values in descending order. The original\n    dictionary remains unchanged.\n\n    Args:\n        input_dict: The dictionary to be sorted. Values must be comparable.\n\n    Returns:\n        A new dictionary sorted by values in descending order.\n\n    Raises:\n        TypeError: If dictionary values are not comparable.\n\n    Example:\n        >>> sort_dict_by_value_descending({'a': 3, 'b': 1, 'c': 2})\n        {'a': 3, 'c': 2, 'b': 1}\n    \"\"\"\n    # Use built-in sorted function with appropriate key and reverse parameters\n    sorted_items = sorted(\n        input_dict.items(),\n        key=lambda item: item[1],\n        reverse=True\n    )\n    \n    # Convert sorted list of tuples back to dictionary\n    sorted_dict = dict(sorted_items)\n    \n    return sorted_dict"}
{"origin_topic": "将字典按值从大到小排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value_descending(input_dict):\n    result_list = []\n    for key_item in input_dict:\n        temp_pair = (key_item, input_dict[key_item])\n        result_list.append(temp_pair)\n    for i in range(len(result_list)):\n        for j in range(len(result_list) - 1):\n            if result_list[j][1] < result_list[j + 1][1]:\n                temporary_holder = result_list[j]\n                result_list[j] = result_list[j + 1]\n                result_list[j + 1] = temporary_holder\n    output_dict = {}\n    for pair in result_list:\n        output_dict[pair[0]] = pair[1]\n    return output_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary keys\n\n\ndef sort_dict_by_value_descending(input_dict: Dict[T, Any]) -> Dict[T, Any]:\n    \"\"\"Sorts a dictionary by its values in descending order.\n    \n    This function creates a new dictionary with the same key-value pairs as the\n    input, but sorted by value in descending order. For dictionaries with\n    identical values, the original insertion order is not guaranteed to be\n    preserved.\n    \n    Args:\n        input_dict: The dictionary to be sorted. Values must be comparable\n            with the less-than operator (<).\n    \n    Returns:\n        A new dictionary with key-value pairs sorted by value in descending\n        order.\n    \n    Raises:\n        TypeError: If dictionary values are not comparable.\n    \n    Example:\n        >>> sort_dict_by_value_descending({'a': 1, 'b': 3, 'c': 2})\n        {'b': 3, 'c': 2, 'a': 1}\n    \"\"\"\n    # Convert dictionary items to list of tuples\n    items = list(input_dict.items())\n    \n    # Sort items by value in descending order using bubble sort\n    for i in range(len(items)):\n        for j in range(len(items) - 1):\n            if items[j][1] < items[j + 1][1]:\n                items[j], items[j + 1] = items[j + 1], items[j]\n    \n    # Convert sorted items back to dictionary\n    sorted_dict = dict(items)\n    return sorted_dict"}
{"origin_topic": "检查一个字符串是否为回文", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(s):\n    if s == s[::-1]:\n        return True\n    else:\n        return False", "output": "def is_palindrome(text: str) -> bool:\n    \"\"\"Checks if the given string is a palindrome.\n    \n    A palindrome is a string that reads the same forwards and backwards,\n    ignoring whitespace, punctuation, and letter case.\n    \n    Args:\n        text: The string to check for palindrome property.\n        \n    Returns:\n        True if the input string is a palindrome, False otherwise.\n        \n    Examples:\n        >>> is_palindrome(\"racecar\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"A man a plan a canal Panama\")\n        False  # Note: This would require additional processing\n    \"\"\"\n    # Compare the string with its reverse\n    return text == text[::-1]"}
{"origin_topic": "计算字符串的长度（不使用len函数）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    for y in b:\n        x = x + 1\n    return x", "output": "from typing import Sequence\n\n\ndef count_elements(sequence: Sequence) -> int:\n    \"\"\"Count the number of elements in a sequence.\n\n    Args:\n        sequence: A sequence of elements to be counted.\n\n    Returns:\n        The total number of elements in the input sequence.\n\n    Examples:\n        >>> count_elements([1, 2, 3])\n        3\n        >>> count_elements('abc')\n        3\n        >>> count_elements([])\n        0\n    \"\"\"\n    element_count = 0\n    for _ in sequence:\n        element_count += 1\n    return element_count"}
{"origin_topic": "将字符串转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = d\n        if e == 'a':\n            e = 'A'\n        elif e == 'b':\n            e = 'B'\n        elif e == 'c':\n            e = 'C'\n        elif e == 'd':\n            e = 'D'\n        elif e == 'e':\n            e = 'E'\n        elif e == 'f':\n            e = 'F'\n        elif e == 'g':\n            e = 'G'\n        elif e == 'h':\n            e = 'H'\n        elif e == 'i':\n            e = 'I'\n        elif e == 'j':\n            e = 'J'\n        elif e == 'k':\n            e = 'K'\n        elif e == 'l':\n            e = 'L'\n        elif e == 'm':\n            e = 'M'\n        elif e == 'n':\n            e = 'N'\n        elif e == 'o':\n            e = 'O'\n        elif e == 'p':\n            e = 'P'\n        elif e == 'q':\n            e = 'Q'\n        elif e == 'r':\n            e = 'R'\n        elif e == 's':\n            e = 'S'\n        elif e == 't':\n            e = 'T'\n        elif e == 'u':\n            e = 'U'\n        elif e == 'v':\n            e = 'V'\n        elif e == 'w':\n            e = 'W'\n        elif e == 'x':\n            e = 'X'\n        elif e == 'y':\n            e = 'Y'\n        elif e == 'z':\n            e = 'Z'\n        c = c + e\n    return c", "output": "def convert_to_uppercase(input_string: str) -> str:\n    \"\"\"将字符串中的小写字母转换为大写字母。\n    \n    该函数遍历输入字符串，将每个小写字母转换为对应的大写字母，\n    非小写字母字符保持不变。\n    \n    Args:\n        input_string: 需要转换的输入字符串\n        \n    Returns:\n        转换后的字符串，其中所有小写字母已转换为大写字母\n        \n    Examples:\n        >>> convert_to_uppercase(\"hello123\")\n        'HELLO123'\n        >>> convert_to_uppercase(\"Hello World!\")\n        'HELLO WORLD!'\n    \"\"\"\n    result = \"\"\n    \n    for character in input_string:\n        # 使用内置的字符串方法进行大小写转换\n        result += character.upper()\n    \n    return result"}
{"origin_topic": "将字符串中的数字移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = False\n        for f in range(10):\n            if d == str(f):\n                e = True\n                break\n        if not e:\n            c = c + d\n    return c", "output": "def remove_digits(input_string: str) -> str:\n    \"\"\"Removes all digit characters from the given string.\n\n    Args:\n        input_string: The string from which digits will be removed.\n\n    Returns:\n        A new string containing all non-digit characters from the input,\n        preserving their original order.\n\n    Examples:\n        >>> remove_digits(\"abc123def456\")\n        'abcdef'\n        >>> remove_digits(\"no digits here\")\n        'no digits here'\n        >>> remove_digits(\"123456\")\n        ''\n    \"\"\"\n    result_chars = []\n    \n    for character in input_string:\n        if not character.isdigit():\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "检查一个字符串是否为数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check(x):\n    if x is None:\n        return False\n    if not isinstance(x, str):\n        return False\n    if len(x) == 0:\n        return False\n    a = x.strip()\n    if len(a) == 0:\n        return False\n    b = 0\n    c = 0\n    d = 0\n    e = 0\n    for i in range(len(a)):\n        f = a[i]\n        if f == '-' or f == '+':\n            if i != 0:\n                return False\n            if i == len(a) - 1:\n                return False\n            if b != 0:\n                return False\n            b = 1\n        elif f == '.':\n            if d != 0:\n                return False\n            if i == len(a) - 1:\n                return False\n            if i == 0:\n                return False\n            if i == 1 and (a[0] == '-' or a[0] == '+'):\n                return False\n            d = 1\n        elif f.isdigit():\n            c = 1\n        else:\n            return False\n    if c == 0:\n        return False\n    return True", "output": "\"\"\"Validation module for numeric string formats.\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_numeric_string(value: Optional[str]) -> bool:\n    \"\"\"Validates if a string represents a valid numeric format.\n    \n    The function checks if the input string conforms to a basic numeric format:\n    - Optional leading '+' or '-' sign\n    - At least one digit\n    - Optional single decimal point (not at start or end)\n    - No other characters except digits, sign, and decimal point\n    \n    Args:\n        value: The string to validate. Can be None.\n        \n    Returns:\n        True if the string is a valid numeric format, False otherwise.\n        \n    Examples:\n        >>> is_valid_numeric_string(\"123.45\")\n        True\n        >>> is_valid_numeric_string(\"-0.5\")\n        True\n        >>> is_valid_numeric_string(\"+3.14\")\n        True\n        >>> is_valid_numeric_string(\"abc\")\n        False\n        >>> is_valid_numeric_string(\"\")\n        False\n        >>> is_valid_numeric_string(\".\")\n        False\n        >>> is_valid_numeric_string(\"-.\")\n        False\n        >>> is_valid_numeric_string(None)\n        False\n    \"\"\"\n    # Early return for invalid inputs\n    if value is None:\n        return False\n    \n    if not isinstance(value, str):\n        return False\n    \n    # Remove whitespace and check if empty\n    stripped_value = value.strip()\n    if not stripped_value:\n        return False\n    \n    # State tracking variables\n    has_sign = False\n    has_digit = False\n    has_decimal_point = False\n    \n    # Iterate through each character with its index\n    for index, char in enumerate(stripped_value):\n        if char in ('-', '+'):\n            # Sign validation rules\n            if index != 0:  # Sign must be at the beginning\n                return False\n            if index == len(stripped_value) - 1:  # Sign cannot be the only character\n                return False\n            if has_sign:  # Only one sign allowed\n                return False\n            has_sign = True\n            \n        elif char == '.':\n            # Decimal point validation rules\n            if has_decimal_point:  # Only one decimal point allowed\n                return False\n            if index == 0:  # Decimal point cannot be at the start\n                return False\n            if index == len(stripped_value) - 1:  # Decimal point cannot be at the end\n                return False\n            # Decimal point cannot immediately follow a sign at position 1\n            if index == 1 and stripped_value[0] in ('-', '+'):\n                return False\n            has_decimal_point = True\n            \n        elif char.isdigit():\n            has_digit = True\n            \n        else:\n            # Invalid character encountered\n            return False\n    \n    # Must have at least one digit\n    return has_digit"}
{"origin_topic": "将字符串拆分为单词列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = 0\n    y = len(a)\n    while x < y:\n        if a[x] != ' ':\n            z = x\n            while z < y and a[z] != ' ':\n                z = z + 1\n            b.append(a[x:z])\n            x = z\n        else:\n            x = x + 1\n    return b", "output": "def split_string_by_spaces(input_string: str) -> list[str]:\n    \"\"\"Splits a string into substrings based on space characters.\n    \n    This function extracts contiguous non-space characters from the input string\n    and returns them as a list of substrings. Multiple consecutive spaces are\n    treated as a single delimiter.\n    \n    Args:\n        input_string: The string to be split. Can contain any characters.\n        \n    Returns:\n        A list of substrings from the input string, excluding all space\n        characters. Returns an empty list if the input contains no non-space\n        characters.\n        \n    Examples:\n        >>> split_string_by_spaces(\"hello world\")\n        ['hello', 'world']\n        >>> split_string_by_spaces(\"  multiple   spaces  here  \")\n        ['multiple', 'spaces', 'here']\n        >>> split_string_by_spaces(\"\")\n        []\n        >>> split_string_by_spaces(\"   \")\n        []\n    \"\"\"\n    if not input_string:\n        return []\n    \n    substrings = []\n    current_index = 0\n    string_length = len(input_string)\n    \n    while current_index < string_length:\n        # Skip leading spaces\n        if input_string[current_index] == ' ':\n            current_index += 1\n            continue\n            \n        # Find the end of the current word\n        word_end = current_index\n        while word_end < string_length and input_string[word_end] != ' ':\n            word_end += 1\n            \n        # Extract the word and add to results\n        substrings.append(input_string[current_index:word_end])\n        current_index = word_end\n    \n    return substrings"}
{"origin_topic": "找出字符串中的所有子串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def find_substrings(a):\n    b = []\n    for x in range(len(a)):\n        for y in range(x + 1, len(a) + 1):\n            c = a[x:y]\n            if c not in b:\n                b.append(c)\n    return b", "output": "from typing import List\n\n\ndef find_all_substrings(input_string: str) -> List[str]:\n    \"\"\"返回输入字符串的所有唯一子字符串。\n\n    子字符串定义为字符串中任意连续字符序列。空字符串不被视为子字符串。\n    结果列表按子字符串首次出现的起始位置和长度排序。\n\n    Args:\n        input_string: 需要提取子字符串的源字符串。\n\n    Returns:\n        包含所有唯一子字符串的列表，按首次出现的顺序排列。\n\n    Examples:\n        >>> find_all_substrings(\"abc\")\n        ['a', 'ab', 'abc', 'b', 'bc', 'c']\n        >>> find_all_substrings(\"aa\")\n        ['a', 'aa']\n    \"\"\"\n    unique_substrings: List[str] = []\n\n    for start_index in range(len(input_string)):\n        for end_index in range(start_index + 1, len(input_string) + 1):\n            substring = input_string[start_index:end_index]\n            if substring not in unique_substrings:\n                unique_substrings.append(substring)\n\n    return unique_substrings"}
{"origin_topic": "将驼峰命名转换为下划线命名", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in range(len(b)):\n        e = b[d]\n        if d > 0 and e.isupper():\n            c.append('_')\n        c.append(e.lower())\n    f = ''.join(c)\n    return f", "output": "def convert_camel_to_snake(camel_case_string: str) -> str:\n    \"\"\"Convert a camelCase string to snake_case.\n    \n    Args:\n        camel_case_string: The input string in camelCase format.\n        \n    Returns:\n        The converted string in snake_case format.\n        \n    Examples:\n        >>> convert_camel_to_snake(\"helloWorld\")\n        'hello_world'\n        >>> convert_camel_to_snake(\"MyClassName\")\n        'my_class_name'\n        >>> convert_camel_to_snake(\"HTTPRequest\")\n        'http_request'\n    \"\"\"\n    snake_chars: list[str] = []\n    \n    for index, char in enumerate(camel_case_string):\n        # Insert underscore before uppercase letters (except the first character)\n        if index > 0 and char.isupper():\n            snake_chars.append('_')\n        snake_chars.append(char.lower())\n    \n    return ''.join(snake_chars)"}
{"origin_topic": "计算字符串中每个字符的ASCII码之和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_string_value(input_string):\n    total_sum = 0\n    for each_character in input_string:\n        ascii_value = ord(each_character)\n        total_sum = total_sum + ascii_value\n    return total_sum", "output": "from typing import Union\n\n\ndef calculate_ascii_sum(text: str) -> int:\n    \"\"\"计算字符串中所有字符的ASCII码值之和。\n    \n    该函数遍历输入字符串中的每个字符，将其转换为对应的ASCII码值，\n    并累加所有字符的ASCII码值得到总和。\n    \n    Args:\n        text: 需要计算ASCII码值之和的字符串。\n    \n    Returns:\n        字符串中所有字符的ASCII码值之和。\n    \n    Raises:\n        TypeError: 如果输入不是字符串类型。\n    \n    Examples:\n        >>> calculate_ascii_sum(\"abc\")\n        294\n        >>> calculate_ascii_sum(\"\")\n        0\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(f\"期望字符串类型，但收到 {type(text).__name__}\")\n    \n    ascii_sum = 0\n    for character in text:\n        ascii_value = ord(character)\n        ascii_sum += ascii_value\n    \n    return ascii_sum"}
{"origin_topic": "计算一个数字的二进制中1的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_ones_in_binary_representation_of_a_number(n):\n    if n < 0:\n        n = abs(n)\n    a = 0\n    while n > 0:\n        b = n % 2\n        if b == 1:\n            a = a + 1\n        n = n // 2\n    if n == 0 and a == 0:\n        a = 0\n    return a", "output": "def count_set_bits(n: int) -> int:\n    \"\"\"Count the number of 1 bits in the binary representation of an integer.\n    \n    This function uses the standard bit counting algorithm by repeatedly\n    checking the least significant bit and right-shifting the number.\n    \n    Args:\n        n: The integer whose set bits are to be counted. Handles negative\n           numbers by taking their absolute value.\n    \n    Returns:\n        The number of 1 bits in the binary representation of the absolute\n        value of n.\n    \n    Examples:\n        >>> count_set_bits(5)  # binary: 101\n        2\n        >>> count_set_bits(0)  # binary: 0\n        0\n        >>> count_set_bits(-3)  # uses abs(-3) = 3, binary: 11\n        2\n    \"\"\"\n    if n < 0:\n        n = abs(n)\n    \n    count = 0\n    while n > 0:\n        # Check if the least significant bit is 1\n        if n & 1:\n            count += 1\n        # Right shift by 1 (equivalent to n // 2)\n        n >>= 1\n    \n    return count"}
{"origin_topic": "统计一段文本中的单词数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_words_in_text(a):\n    b = 0\n    x = 0\n    while x < len(a):\n        if a[x] != ' ':\n            while x < len(a) and a[x] != ' ':\n                x = x + 1\n            b = b + 1\n        else:\n            while x < len(a) and a[x] == ' ':\n                x = x + 1\n    return b", "output": "def count_words_in_text(text: str) -> int:\n    \"\"\"Counts the number of words in a given string.\n    \n    Words are defined as sequences of non-space characters separated by one or\n    more spaces. Leading, trailing, and consecutive spaces are handled correctly.\n    \n    Args:\n        text: The input string to analyze.\n    \n    Returns:\n        The number of words in the input string.\n    \n    Examples:\n        >>> count_words_in_text(\"Hello world\")\n        2\n        >>> count_words_in_text(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words_in_text(\"\")\n        0\n        >>> count_words_in_text(\"   \")\n        0\n    \"\"\"\n    word_count = 0\n    index = 0\n    \n    while index < len(text):\n        # Skip consecutive spaces\n        while index < len(text) and text[index] == ' ':\n            index += 1\n        \n        # If we found a word, count it and skip to the next space\n        if index < len(text):\n            word_count += 1\n            while index < len(text) and text[index] != ' ':\n                index += 1\n    \n    return word_count"}
{"origin_topic": "将字符串中的大小写互换", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for c in s:\n        if c.islower():\n            r = r + c.upper()\n        else:\n            if c.isupper():\n                r = r + c.lower()\n            else:\n                r = r + c\n    return r", "output": "def swap_case(input_string: str) -> str:\n    \"\"\"Swap the case of each character in the input string.\n    \n    Converts lowercase letters to uppercase and uppercase letters to lowercase.\n    Non-alphabetic characters remain unchanged.\n    \n    Args:\n        input_string: The string to process.\n        \n    Returns:\n        A new string with swapped character cases.\n        \n    Examples:\n        >>> swap_case(\"Hello World!\")\n        'hELLO wORLD!'\n        >>> swap_case(\"Python 3.9\")\n        'pYTHON 3.9'\n    \"\"\"\n    result_chars = []\n    \n    for char in input_string:\n        if char.islower():\n            result_chars.append(char.upper())\n        elif char.isupper():\n            result_chars.append(char.lower())\n        else:\n            result_chars.append(char)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将字符串中的数字提取出来", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b:\n        e = False\n        for f in range(10):\n            if d == str(f):\n                e = True\n        if e:\n            c.append(d)\n    g = \"\"\n    for h in c:\n        g = g + h\n    return g", "output": "from typing import List\n\n\ndef extract_digits_from_string(input_string: str) -> str:\n    \"\"\"Extracts all digit characters from the given string.\n\n    This function iterates through each character in the input string,\n    identifies digit characters ('0'-'9'), and returns them concatenated\n    as a single string.\n\n    Args:\n        input_string: The string from which to extract digits.\n\n    Returns:\n        A string containing only the digit characters found in the input,\n        in the order they appeared. Returns an empty string if no digits\n        are found.\n\n    Examples:\n        >>> extract_digits_from_string(\"abc123def456\")\n        '123456'\n        >>> extract_digits_from_string(\"no digits here\")\n        ''\n        >>> extract_digits_from_string(\"007\")\n        '007'\n    \"\"\"\n    digits: List[str] = []\n    \n    for character in input_string:\n        if character.isdigit():\n            digits.append(character)\n    \n    return ''.join(digits)"}
{"origin_topic": "计算一个数字的绝对值", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    if a < 0:\n        b = -a\n        return b\n    else:\n        x = a\n        return x", "output": "def absolute_value(number: float) -> float:\n    \"\"\"Return the absolute value of the input number.\n    \n    Args:\n        number: The input value for which to compute the absolute value.\n    \n    Returns:\n        The absolute value of the input number.\n    \n    Examples:\n        >>> absolute_value(-5)\n        5\n        >>> absolute_value(3)\n        3\n        >>> absolute_value(0)\n        0\n    \"\"\"\n    if number < 0:\n        return -number\n    return number"}
{"origin_topic": "计算一个数的二进制表示", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    if a == 0:\n        return \"0\"\n    b = abs(a)\n    x = []\n    while b > 0:\n        c = b % 2\n        x.append(str(c))\n        b = b // 2\n    x.reverse()\n    result = ''.join(x)\n    if a < 0:\n        result = \"-\" + result\n    return result", "output": "def integer_to_binary_string(number: int) -> str:\n    \"\"\"Converts an integer to its binary string representation.\n    \n    Args:\n        number: The integer to convert to binary.\n        \n    Returns:\n        A string representing the binary value of the input integer.\n        Negative numbers are prefixed with a minus sign.\n        Zero returns \"0\".\n        \n    Examples:\n        >>> integer_to_binary_string(10)\n        '1010'\n        >>> integer_to_binary_string(-5)\n        '-101'\n        >>> integer_to_binary_string(0)\n        '0'\n    \"\"\"\n    if number == 0:\n        return \"0\"\n    \n    absolute_value = abs(number)\n    binary_digits = []\n    \n    while absolute_value > 0:\n        remainder = absolute_value % 2\n        binary_digits.append(str(remainder))\n        absolute_value //= 2\n    \n    binary_digits.reverse()\n    binary_string = ''.join(binary_digits)\n    \n    if number < 0:\n        binary_string = \"-\" + binary_string\n    \n    return binary_string"}
{"origin_topic": "验证邮箱地址格式（简单规则）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                if '@' in a:\n                    x = a.split('@')\n                    if len(x) == 2:\n                        if len(x[0]) > 0:\n                            if len(x[1]) > 0:\n                                if '.' in x[1]:\n                                    y = x[1].split('.')\n                                    if len(y) >= 2:\n                                        for z in y:\n                                            if len(z) == 0:\n                                                b = False\n                                                break\n                                        else:\n                                            b = True\n    return b", "output": "import re\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证电子邮件地址格式是否有效。\n    \n    检查电子邮件地址是否符合基本格式要求：\n    1. 非空字符串\n    2. 包含且仅包含一个 '@' 符号\n    3. '@' 符号前有非空本地部分\n    4. '@' 符号后有非空域名部分\n    5. 域名部分至少包含一个点号，且点号分隔的部分都非空\n    \n    Args:\n        email: 待验证的电子邮件地址字符串，可为None\n        \n    Returns:\n        bool: 如果电子邮件格式有效返回True，否则返回False\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email@\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    if not email or not isinstance(email, str):\n        return False\n    \n    # 使用正则表达式进行更简洁的验证\n    email_pattern = r'^[^@]+@[^@]+\\.[^@]+$'\n    if not re.match(email_pattern, email):\n        return False\n    \n    # 验证域名部分的点号分隔部分都非空\n    _, domain = email.split('@', 1)\n    domain_parts = domain.split('.')\n    \n    # 检查所有域名部分都非空\n    return all(part for part in domain_parts)\n\n\n# 替代方案：使用更严格的RFC兼容验证\ndef is_valid_email_rfc(email: Optional[str]) -> bool:\n    \"\"\"使用RFC兼容的正则表达式验证电子邮件格式。\n    \n    这个实现遵循RFC 5322标准，提供更严格的电子邮件格式验证。\n    \n    Args:\n        email: 待验证的电子邮件地址字符串，可为None\n        \n    Returns:\n        bool: 如果电子邮件格式符合RFC标准返回True，否则返回False\n    \"\"\"\n    if not email or not isinstance(email, str):\n        return False\n    \n    # RFC 5322兼容的正则表达式（简化版）\n    rfc_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(rfc_pattern, email))"}
{"origin_topic": "按值对字典进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(input_dict):\n    sorted_items = []\n    for key, value in input_dict.items():\n        sorted_items.append((key, value))\n    for i in range(len(sorted_items)):\n        for j in range(len(sorted_items) - 1):\n            if sorted_items[j][1] > sorted_items[j + 1][1]:\n                temp = sorted_items[j]\n                sorted_items[j] = sorted_items[j + 1]\n                sorted_items[j + 1] = temp\n    result_dict = {}\n    for item in sorted_items:\n        result_dict[item[0]] = item[1]\n    return result_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary values\n\ndef sort_dict_by_value(input_dict: Dict[str, T]) -> Dict[str, T]:\n    \"\"\"\n    Sort a dictionary by its values in ascending order.\n\n    This function creates a new dictionary with the same key-value pairs as the\n    input dictionary, but sorted by the values. The sorting is performed using\n    a bubble sort algorithm (for educational purposes) and assumes the values\n    are comparable.\n\n    Args:\n        input_dict: A dictionary with string keys and comparable values.\n\n    Returns:\n        A new dictionary containing the same key-value pairs as input_dict,\n        sorted by values in ascending order.\n\n    Example:\n        >>> sort_dict_by_value({'apple': 3, 'banana': 1, 'cherry': 2})\n        {'banana': 1, 'cherry': 2, 'apple': 3}\n\n    Note:\n        This implementation uses bubble sort which has O(n²) time complexity.\n        For production use, consider using Python's built-in sorted() function.\n    \"\"\"\n    # Convert dictionary items to a list of tuples\n    items_list = list(input_dict.items())\n    \n    # Sort items using bubble sort algorithm\n    item_count = len(items_list)\n    for i in range(item_count):\n        # Last i elements are already in place\n        for j in range(item_count - i - 1):\n            if items_list[j][1] > items_list[j + 1][1]:\n                # Swap adjacent elements if they are in wrong order\n                items_list[j], items_list[j + 1] = items_list[j + 1], items_list[j]\n    \n    # Reconstruct dictionary from sorted items\n    sorted_dict: Dict[str, T] = {}\n    for key, value in items_list:\n        sorted_dict[key] = value\n    \n    return sorted_dict"}
{"origin_topic": "从文件路径字符串中提取文件名", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = b.split('/')\n    y = x[-1]\n    z = y.split('\\\\')\n    w = z[-1]\n    v = w.split('.')\n    u = v[0]\n    if len(v) > 1:\n        t = v[1]\n        s = u + '.' + t\n        return s\n    else:\n        return u", "output": "from typing import Optional\n\n\ndef extract_filename_without_path_and_extension(filepath: str) -> str:\n    \"\"\"从文件路径中提取文件名（不含路径和扩展名）。\n    \n    该函数处理包含路径分隔符（'/' 或 '\\\\'）和扩展名的文件路径，\n    返回不包含路径和扩展名的纯文件名。\n    \n    Args:\n        filepath: 完整的文件路径字符串，可能包含路径分隔符和扩展名。\n    \n    Returns:\n        不包含路径和扩展名的文件名。如果文件没有扩展名，则返回完整文件名。\n    \n    Examples:\n        >>> extract_filename_without_path_and_extension('/home/user/file.txt')\n        'file'\n        >>> extract_filename_without_path_and_extension('C:\\\\Users\\\\doc.pdf')\n        'doc'\n        >>> extract_filename_without_path_and_extension('filename')\n        'filename'\n        >>> extract_filename_without_path_and_extension('folder/name.tar.gz')\n        'name.tar'\n    \"\"\"\n    # 分割路径获取最后一部分（文件名+扩展名）\n    path_parts = filepath.split('/')\n    last_path_component = path_parts[-1]\n    \n    # 处理可能存在的反斜杠分隔符\n    backslash_parts = last_path_component.split('\\\\')\n    filename_with_extension = backslash_parts[-1]\n    \n    # 分割文件名和扩展名\n    name_parts = filename_with_extension.split('.')\n    base_filename = name_parts[0]\n    \n    # 如果有扩展名，保留第一个扩展名（处理多扩展名情况如.tar.gz）\n    if len(name_parts) > 1:\n        first_extension = name_parts[1]\n        return f'{base_filename}.{first_extension}'\n    \n    return base_filename"}
{"origin_topic": "计算字符串中数字字符的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_digits_in_string(s):\n    result = 0\n    for char in s:\n        if char == '0' or char == '1' or char == '2' or char == '3' or char == '4' or char == '5' or char == '6' or char == '7' or char == '8' or char == '9':\n            result = result + 1\n        else:\n            continue\n    return result", "output": "def count_digits_in_string(text: str) -> int:\n    \"\"\"Count the number of digit characters in a given string.\n    \n    Args:\n        text: The input string to analyze for digit characters.\n        \n    Returns:\n        The count of digit characters (0-9) found in the input string.\n        \n    Examples:\n        >>> count_digits_in_string(\"abc123\")\n        3\n        >>> count_digits_in_string(\"no digits here\")\n        0\n        >>> count_digits_in_string(\"2024-01-01\")\n        8\n    \"\"\"\n    digit_count = 0\n    for character in text:\n        if character.isdigit():\n            digit_count += 1\n    return digit_count"}
{"origin_topic": "检查字符串是否以元音开头", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    if len(s) > 0:\n        c = s[0].lower()\n        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u':\n            return True\n        else:\n            return False\n    else:\n        return False", "output": "def starts_with_vowel(text: str) -> bool:\n    \"\"\"Check if the given string starts with a vowel (case-insensitive).\n\n    Args:\n        text: The input string to check.\n\n    Returns:\n        True if the string is non-empty and starts with a vowel (a, e, i, o, u),\n        False otherwise.\n\n    Examples:\n        >>> starts_with_vowel(\"apple\")\n        True\n        >>> starts_with_vowel(\"Banana\")\n        False\n        >>> starts_with_vowel(\"\")\n        False\n        >>> starts_with_vowel(\"Orange\")\n        True\n    \"\"\"\n    if not text:\n        return False\n\n    first_char = text[0].lower()\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    return first_char in vowels"}
{"origin_topic": "将一个字符串中的单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b.split():\n        e = ''\n        for f in range(len(d)):\n            if f == 0:\n                e = e + d[f].upper()\n            else:\n                e = e + d[f]\n        c.append(e)\n    return ' '.join(c)", "output": "def capitalize_words(text: str) -> str:\n    \"\"\"Capitalize the first letter of each word in a string.\n    \n    Args:\n        text: Input string containing words to capitalize.\n        \n    Returns:\n        String with each word's first letter capitalized.\n        \n    Example:\n        >>> capitalize_words('hello world')\n        'Hello World'\n        >>> capitalize_words('python programming')\n        'Python Programming'\n    \"\"\"\n    capitalized_words = []\n    \n    for word in text.split():\n        capitalized_word = ''\n        \n        for char_index in range(len(word)):\n            if char_index == 0:\n                capitalized_word += word[char_index].upper()\n            else:\n                capitalized_word += word[char_index]\n        \n        capitalized_words.append(capitalized_word)\n    \n    return ' '.join(capitalized_words)"}
{"origin_topic": "计算一个数的绝对值", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_absolute_value_of_a_number(x):\n    if x > 0:\n        result = x\n        return result\n    elif x < 0:\n        result = -x\n        return result\n    else:\n        result = 0\n        return result", "output": "def calculate_absolute_value(number: float) -> float:\n    \"\"\"Calculate the absolute value of a given number.\n\n    The absolute value of a number is its distance from zero on the number line,\n    regardless of direction. For any real number x:\n    - If x > 0, returns x\n    - If x < 0, returns -x\n    - If x = 0, returns 0\n\n    Args:\n        number: The input value for which to compute the absolute value.\n\n    Returns:\n        The non-negative absolute value of the input number.\n\n    Examples:\n        >>> calculate_absolute_value(5.0)\n        5.0\n        >>> calculate_absolute_value(-3.5)\n        3.5\n        >>> calculate_absolute_value(0)\n        0.0\n    \"\"\"\n    if number > 0:\n        return number\n    elif number < 0:\n        return -number\n    else:\n        return 0.0"}
{"origin_topic": "将键值对列表转换为字典", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = {}\n    for x in a:\n        if len(x) == 2:\n            k = x[0]\n            v = x[1]\n            b[k] = v\n        else:\n            pass\n    return b", "output": "from typing import Dict, List, Tuple, Any, Optional\n\n\ndef create_dict_from_pairs(data: List[Tuple[Any, ...]]) -> Dict[Any, Any]:\n    \"\"\"\n    Create a dictionary from a list of tuples, using only valid key-value pairs.\n    \n    This function processes a list of tuples and creates a dictionary where:\n    - Tuples with exactly two elements are treated as key-value pairs\n    - Tuples with any other number of elements are ignored\n    \n    Args:\n        data: A list of tuples where each tuple may contain 0 or more elements.\n              Only tuples with exactly 2 elements will be processed.\n    \n    Returns:\n        A dictionary containing key-value pairs from valid tuples in the input.\n        If no valid tuples are found, returns an empty dictionary.\n    \n    Examples:\n        >>> create_dict_from_pairs([('a', 1), ('b', 2), ('c', 3, 'extra')])\n        {'a': 1, 'b': 2}\n        \n        >>> create_dict_from_pairs([('x', 'y'), ('z',)])\n        {'x': 'y'}\n    \"\"\"\n    result_dict: Dict[Any, Any] = {}\n    \n    for item in data:\n        if len(item) == 2:\n            key, value = item\n            result_dict[key] = value\n    \n    return result_dict"}
{"origin_topic": "将字符串中的空格替换为下划线", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y == \" \":\n            x = x + \"_\"\n        else:\n            x = x + y\n    return x", "output": "def replace_spaces_with_underscores(input_string: str) -> str:\n    \"\"\"Replaces all space characters with underscores in the given string.\n    \n    Args:\n        input_string: The original string containing spaces to be replaced.\n        \n    Returns:\n        A new string where all spaces are replaced with underscores.\n        \n    Examples:\n        >>> replace_spaces_with_underscores(\"hello world\")\n        'hello_world'\n        >>> replace_spaces_with_underscores(\"multiple   spaces\")\n        'multiple___spaces'\n        >>> replace_spaces_with_underscores(\"\")\n        ''\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character == \" \":\n            result += \"_\"\n        else:\n            result += character\n    return result"}
{"origin_topic": "计算字符串中单词的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = 0\n    d = 0\n    e = False\n    for f in b:\n        if f == ' ':\n            if e:\n                c = c + 1\n                e = False\n            else:\n                pass\n        else:\n            if not e:\n                e = True\n            else:\n                continue\n    if e:\n        c = c + 1\n    return c", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a given string.\n    \n    Words are defined as sequences of non-space characters separated by one or\n    more spaces. Leading and trailing spaces are ignored.\n    \n    Args:\n        text: The input string to count words from.\n    \n    Returns:\n        The number of words in the input string.\n    \n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n    \"\"\"\n    word_count = 0\n    in_word = False\n    \n    for char in text:\n        if char == ' ':\n            if in_word:\n                word_count += 1\n                in_word = False\n        else:\n            if not in_word:\n                in_word = True\n    \n    # Handle the case where the string ends with a word\n    if in_word:\n        word_count += 1\n    \n    return word_count"}
{"origin_topic": "将字符串转换为摩尔斯电码", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.',\n        'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---',\n        'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---',\n        'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-',\n        'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--',\n        'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--',\n        '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..',\n        '9': '----.', ' ': '/'\n    }\n    d = ''\n    e = b.upper()\n    for f in e:\n        if f in c:\n            g = c[f]\n            d = d + g\n            h = ' '\n            d = d + h\n        else:\n            i = ''\n            d = d + i\n    j = d.strip()\n    return j", "output": "from typing import Dict, Optional\n\n\ndef text_to_morse(text: str) -> str:\n    \"\"\"Convert text to Morse code.\n    \n    Converts alphanumeric characters and spaces to International Morse Code.\n    Non-alphanumeric characters (except spaces) are silently ignored.\n    \n    Args:\n        text: Input string to convert to Morse code.\n        \n    Returns:\n        Morse code representation of the input string, with characters\n        separated by single spaces and words separated by '/'.\n        \n    Example:\n        >>> text_to_morse(\"Hello World\")\n        '.... . .-.. .-.. --- / .-- --- .-. .-.. -..'\n    \"\"\"\n    # International Morse Code mapping\n    morse_dict: Dict[str, str] = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.',\n        'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---',\n        'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---',\n        'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-',\n        'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--',\n        'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--',\n        '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..',\n        '9': '----.', ' ': '/'\n    }\n    \n    morse_code_parts: list[str] = []\n    normalized_text: str = text.upper()\n    \n    for character in normalized_text:\n        morse_symbol: Optional[str] = morse_dict.get(character)\n        if morse_symbol:\n            morse_code_parts.append(morse_symbol)\n    \n    # Join with spaces between characters (words already separated by '/')\n    return ' '.join(morse_code_parts)"}
{"origin_topic": "从字符串中提取所有数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = \"\"\n    e = False\n    for f in b:\n        g = ord(f)\n        if g >= 48 and g <= 57:\n            d = d + f\n            e = True\n        else:\n            if e == True:\n                h = int(d)\n                c.append(h)\n                d = \"\"\n                e = False\n    if e == True:\n        i = int(d)\n        c.append(i)\n    return c", "output": "from typing import List\n\n\ndef extract_numbers_from_string(input_string: str) -> List[int]:\n    \"\"\"Extracts consecutive digit sequences from a string and returns them as integers.\n    \n    This function scans through the input string character by character, identifying\n    sequences of consecutive digits. Each digit sequence is converted to an integer\n    and collected in a list. Non-digit characters act as separators between sequences.\n    \n    Examples:\n        >>> extract_numbers_from_string(\"abc123def45gh6\")\n        [123, 45, 6]\n        >>> extract_numbers_from_string(\"no numbers here\")\n        []\n        >>> extract_numbers_from_string(\"100 200 300\")\n        [100, 200, 300]\n    \n    Args:\n        input_string: The string from which to extract number sequences.\n    \n    Returns:\n        A list of integers extracted from the input string. Returns an empty list\n        if no digit sequences are found.\n    \"\"\"\n    extracted_numbers: List[int] = []\n    current_number_string: str = \"\"\n    is_inside_number: bool = False\n    \n    for character in input_string:\n        character_code: int = ord(character)\n        \n        # Check if character is a digit (ASCII codes 48-57)\n        if 48 <= character_code <= 57:\n            current_number_string += character\n            is_inside_number = True\n        else:\n            # If we were inside a number and encountered a non-digit,\n            # finalize the current number\n            if is_inside_number:\n                extracted_numbers.append(int(current_number_string))\n                current_number_string = \"\"\n                is_inside_number = False\n    \n    # Handle any trailing number at the end of the string\n    if is_inside_number:\n        extracted_numbers.append(int(current_number_string))\n    \n    return extracted_numbers"}
{"origin_topic": "验证邮箱地址格式是否正确", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                if '@' in a:\n                    x = a.split('@')\n                    if len(x) == 2:\n                        if len(x[0]) > 0:\n                            if len(x[1]) > 0:\n                                if '.' in x[1]:\n                                    y = x[1].split('.')\n                                    if len(y) >= 2:\n                                        for z in y:\n                                            if len(z) > 0:\n                                                b = True\n                                            else:\n                                                b = False\n                                                break\n                                    else:\n                                        b = False\n                                else:\n                                    b = False\n                            else:\n                                b = False\n                        else:\n                            b = False\n                    else:\n                        b = False\n                else:\n                    b = False\n            else:\n                b = False\n        else:\n            b = False\n    else:\n        b = False\n    return b", "output": "from typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证给定的字符串是否为有效的电子邮件地址格式。\n\n    该函数检查输入字符串是否符合基本的电子邮件格式要求：\n    1. 非空字符串\n    2. 包含且仅包含一个'@'符号\n    3. '@'符号前后都有内容\n    4. 域名部分至少包含一个'.'符号\n    5. 域名各部分非空\n\n    Args:\n        email: 待验证的字符串，可以为None\n\n    Returns:\n        True表示是有效的电子邮件格式，False表示无效\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid@\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    # 基础验证：输入必须是非空字符串\n    if not isinstance(email, str) or not email:\n        return False\n\n    # 验证必须包含且仅包含一个'@'符号\n    if '@' not in email:\n        return False\n\n    local_part, domain_part = email.split('@', 1)\n    \n    # 验证'@'符号前后都有内容\n    if not local_part or not domain_part:\n        return False\n\n    # 验证域名部分包含至少一个'.'符号\n    if '.' not in domain_part:\n        return False\n\n    # 验证域名各部分非空\n    domain_parts = domain_part.split('.')\n    if len(domain_parts) < 2:\n        return False\n\n    return all(part for part in domain_parts)"}
{"origin_topic": "将字符串中的数字全部移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for c in s:\n        if c == '0':\n            continue\n        elif c == '1':\n            continue\n        elif c == '2':\n            continue\n        elif c == '3':\n            continue\n        elif c == '4':\n            continue\n        elif c == '5':\n            continue\n        elif c == '6':\n            continue\n        elif c == '7':\n            continue\n        elif c == '8':\n            continue\n        elif c == '9':\n            continue\n        else:\n            r = r + c\n    return r", "output": "def filter_non_digits(input_string: str) -> str:\n    \"\"\"返回移除了所有数字字符的字符串。\n    \n    该函数遍历输入字符串，移除所有数字字符（0-9），\n    保留其他所有字符（包括字母、符号、空格等）。\n    \n    Args:\n        input_string: 需要处理的原始字符串\n        \n    Returns:\n        移除了所有数字字符的新字符串\n        \n    Examples:\n        >>> filter_non_digits(\"abc123def\")\n        'abcdef'\n        >>> filter_non_digits(\"Phone: 555-1234\")\n        'Phone: -'\n        >>> filter_non_digits(\"No digits here!\")\n        'No digits here!'\n    \"\"\"\n    filtered_chars = []\n    \n    for character in input_string:\n        if not character.isdigit():\n            filtered_chars.append(character)\n    \n    return ''.join(filtered_chars)"}
{"origin_topic": "检查字符串是否只包含字母", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = True\n    for d in b:\n        e = d.isalpha()\n        if e == False:\n            c = False\n    return c", "output": "from typing import Iterable\n\n\ndef contains_only_alphabetic_characters(text: Iterable[str]) -> bool:\n    \"\"\"检查可迭代字符串中是否所有元素都只包含字母字符。\n\n    该函数遍历输入的可迭代字符串，检查每个字符串是否完全由字母字符组成。\n    如果发现任何非字母字符，立即返回False；否则返回True。\n\n    Args:\n        text: 可迭代的字符串序列，如字符串、列表、元组等。\n\n    Returns:\n        bool: 如果所有字符串都只包含字母字符则返回True，否则返回False。\n\n    Examples:\n        >>> contains_only_alphabetic_characters([\"hello\", \"world\"])\n        True\n        >>> contains_only_alphabetic_characters([\"hello\", \"world123\"])\n        False\n        >>> contains_only_alphabetic_characters(\"hello\")\n        True\n        >>> contains_only_alphabetic_characters(\"hello123\")\n        False\n    \"\"\"\n    all_alphabetic = True\n    \n    for string in text:\n        if not string.isalpha():\n            all_alphabetic = False\n            break  # 发现非字母字符，提前终止循环\n    \n    return all_alphabetic"}
{"origin_topic": "将秒转换为小时、分钟和秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = a % 3600\n    y = x // 60\n    z = x % 60\n    result = (b, y, z)\n    return result", "output": "def convert_seconds(total_seconds: int) -> tuple[int, int, int]:\n    \"\"\"将总秒数转换为小时、分钟、秒的元组。\n\n    该函数将给定的总秒数分解为小时、分钟和秒的整数部分，\n    返回格式为 (小时, 分钟, 秒) 的元组。\n\n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）。\n\n    Returns:\n        包含三个整数的元组，分别表示小时、分钟和秒。\n\n    Examples:\n        >>> convert_seconds(3661)\n        (1, 1, 1)\n        >>> convert_seconds(7200)\n        (2, 0, 0)\n        >>> convert_seconds(65)\n        (0, 1, 5)\n    \"\"\"\n    hours = total_seconds // 3600\n    remaining_seconds = total_seconds % 3600\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n\n    return hours, minutes, seconds"}
{"origin_topic": "反转一个字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for i in range(len(s) - 1, -1, -1):\n        r = r + s[i]\n    return r", "output": "def reverse_string(input_string: str) -> str:\n    \"\"\"Reverses the order of characters in a given string.\n\n    Args:\n        input_string: The original string to be reversed.\n\n    Returns:\n        A new string with characters in reverse order.\n\n    Examples:\n        >>> reverse_string(\"hello\")\n        'olleh'\n        >>> reverse_string(\"\")\n        ''\n        >>> reverse_string(\"a\")\n        'a'\n    \"\"\"\n    reversed_chars = []\n    \n    # Iterate from the last character to the first\n    for i in range(len(input_string) - 1, -1, -1):\n        reversed_chars.append(input_string[i])\n    \n    return ''.join(reversed_chars)"}
{"origin_topic": "将字符串中的每个单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b.split():\n        e = ''\n        for f in range(len(d)):\n            if f == 0:\n                e = e + d[f].upper()\n            else:\n                e = e + d[f].lower()\n        c.append(e)\n    return ' '.join(c)", "output": "def capitalize_words(text: str) -> str:\n    \"\"\"Capitalize the first letter of each word in a string.\n    \n    Args:\n        text: Input string containing words to be capitalized.\n    \n    Returns:\n        String with each word capitalized (first letter uppercase, \n        remaining letters lowercase).\n    \n    Example:\n        >>> capitalize_words('hello world')\n        'Hello World'\n        >>> capitalize_words('PYTHON programming')\n        'Python Programming'\n    \"\"\"\n    capitalized_words = []\n    \n    for word in text.split():\n        # Capitalize first letter, lowercase the rest\n        capitalized_word = word[0].upper() + word[1:].lower()\n        capitalized_words.append(capitalized_word)\n    \n    return ' '.join(capitalized_words)"}
{"origin_topic": "将字符串中的标点符号移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y.isalnum() or y.isspace():\n            x = x + y\n        else:\n            if not y.isalnum():\n                if not y.isspace():\n                    pass\n    return x", "output": "def sanitize_alphanumeric_string(input_string: str) -> str:\n    \"\"\"Filters a string to keep only alphanumeric characters and spaces.\n    \n    This function iterates through each character in the input string and\n    retains only characters that are alphanumeric (letters and digits) or\n    whitespace characters. All other characters are removed.\n    \n    Args:\n        input_string: The string to be sanitized.\n    \n    Returns:\n        A new string containing only alphanumeric characters and spaces\n        from the original input.\n    \n    Examples:\n        >>> sanitize_alphanumeric_string(\"Hello, World! 123\")\n        'Hello World 123'\n        >>> sanitize_alphanumeric_string(\"Test@#$%^&*()String\")\n        'TestString'\n    \"\"\"\n    sanitized_chars = []\n    \n    for char in input_string:\n        if char.isalnum() or char.isspace():\n            sanitized_chars.append(char)\n    \n    return ''.join(sanitized_chars)"}
{"origin_topic": "将蛇形命名法转换为驼峰命名法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = False\n    for e in b:\n        if e == '_':\n            d = True\n        else:\n            if d:\n                c.append(e.upper())\n                d = False\n            else:\n                c.append(e)\n    return ''.join(c)", "output": "def convert_snake_to_camel_case(input_string: str) -> str:\n    \"\"\"将下划线命名法转换为驼峰命名法（小驼峰式）。\n    \n    该函数将输入字符串中的下划线命名法转换为小驼峰命名法。\n    转换规则：\n    1. 遇到下划线时，标记下一个字符需要大写\n    2. 遇到非下划线字符时：\n       - 如果前一个字符是下划线，则将该字符转换为大写\n       - 否则，保持原样\n    \n    示例：\n        \"hello_world\" -> \"helloWorld\"\n        \"test_string_example\" -> \"testStringExample\"\n        \"no_underscore\" -> \"noUnderscore\"\n    \n    Args:\n        input_string: 需要转换的下划线命名法字符串\n    \n    Returns:\n        转换后的小驼峰命名法字符串\n    \n    Raises:\n        TypeError: 如果输入不是字符串类型\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise TypeError(f\"输入必须是字符串类型，但得到的是 {type(input_string).__name__}\")\n    \n    result_chars = []\n    capitalize_next = False\n    \n    for char in input_string:\n        if char == '_':\n            capitalize_next = True\n        else:\n            if capitalize_next:\n                result_chars.append(char.upper())\n                capitalize_next = False\n            else:\n                result_chars.append(char)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将字典按值排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(x):\n    y = list(x.items())\n    for a in range(len(y)):\n        for b in range(len(y) - 1):\n            if y[b][1] > y[b + 1][1]:\n                t = y[b]\n                y[b] = y[b + 1]\n                y[b + 1] = t\n    r = {}\n    for p in y:\n        r[p[0]] = p[1]\n    return r", "output": "from typing import Dict, Any\n\n\ndef sort_dict_by_value(input_dict: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"Sorts a dictionary by its values in ascending order using bubble sort.\n\n    Args:\n        input_dict: The dictionary to be sorted. Values must be comparable.\n\n    Returns:\n        A new dictionary with the same key-value pairs, sorted by value.\n\n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n\n    Note:\n        This implementation uses bubble sort which has O(n²) time complexity.\n        For production use, consider using built-in sorting functions.\n    \"\"\"\n    items = list(input_dict.items())\n    item_count = len(items)\n\n    # Bubble sort implementation\n    for outer_index in range(item_count):\n        for inner_index in range(item_count - 1):\n            if items[inner_index][1] > items[inner_index + 1][1]:\n                # Swap adjacent elements\n                items[inner_index], items[inner_index + 1] = (\n                    items[inner_index + 1],\n                    items[inner_index],\n                )\n\n    # Reconstruct dictionary from sorted items\n    sorted_dict = {}\n    for key, value in items:\n        sorted_dict[key] = value\n\n    return sorted_dict"}
{"origin_topic": "判断一个数字是否为素数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_prime_number(n):\n    if n <= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True", "output": "def is_prime(number: int) -> bool:\n    \"\"\"Check if a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive\n    divisors other than 1 and itself.\n\n    Args:\n        number: The integer to check for primality. Must be non-negative.\n\n    Returns:\n        True if the number is prime, False otherwise.\n\n    Raises:\n        ValueError: If the input is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    \n    if number <= 1:\n        return False\n    \n    # Optimization: Check divisibility only up to sqrt(number)\n    for divisor in range(2, int(number ** 0.5) + 1):\n        if number % divisor == 0:\n            return False\n    \n    return True"}
{"origin_topic": "找出字符串中最长的单词", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split()\n    d = 0\n    e = \"\"\n    for f in c:\n        g = len(f)\n        if g > d:\n            d = g\n            e = f\n    return e", "output": "def find_longest_word(text: str) -> str:\n    \"\"\"返回给定文本中最长的单词。\n    \n    如果存在多个相同长度的最长单词，返回第一个出现的。\n    \n    Args:\n        text: 输入文本字符串\n        \n    Returns:\n        文本中最长的单词\n        \n    Examples:\n        >>> find_longest_word(\"hello world python\")\n        'python'\n        >>> find_longest_word(\"short long longest\")\n        'longest'\n    \"\"\"\n    words = text.split()\n    \n    if not words:\n        return \"\"\n    \n    longest_word = words[0]\n    max_length = len(longest_word)\n    \n    for word in words[1:]:\n        current_length = len(word)\n        if current_length > max_length:\n            max_length = current_length\n            longest_word = word\n    \n    return longest_word"}
{"origin_topic": "将字符串中的所有辅音字母转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y.isalpha():\n            if y.lower() not in ['a', 'e', 'i', 'o', 'u']:\n                x = x + y.upper()\n            else:\n                x = x + y\n        else:\n            x = x + y\n    return x", "output": "from typing import Iterable\n\n\ndef process_string_with_consonants_uppercase(input_string: str) -> str:\n    \"\"\"Processes a string by converting consonants to uppercase.\n    \n    This function iterates through each character in the input string:\n    - Alphabetic characters are processed as follows:\n        * Consonants (non-vowel letters) are converted to uppercase\n        * Vowels (a, e, i, o, u) remain unchanged\n    - Non-alphabetic characters (digits, punctuation, whitespace, etc.) \n      remain unchanged\n    \n    Args:\n        input_string: The string to be processed. Can contain any characters.\n        \n    Returns:\n        A new string where all consonants are converted to uppercase,\n        while vowels and non-alphabetic characters remain unchanged.\n        \n    Examples:\n        >>> process_string_with_consonants_uppercase(\"Hello World!\")\n        'HEllO WOrlD!'\n        >>> process_string_with_consonants_uppercase(\"Python 3.9\")\n        'PYTHOn 3.9'\n        >>> process_string_with_consonants_uppercase(\"aeiou123\")\n        'aeiou123'\n    \"\"\"\n    VOWELS = {'a', 'e', 'i', 'o', 'u'}\n    result_chars = []\n    \n    for char in input_string:\n        if char.isalpha():\n            if char.lower() not in VOWELS:\n                # Convert consonant to uppercase\n                result_chars.append(char.upper())\n            else:\n                # Keep vowel as-is\n                result_chars.append(char)\n        else:\n            # Keep non-alphabetic character as-is\n            result_chars.append(char)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将字符串中的空格移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x == \" \":\n            continue\n        else:\n            b = b + x\n    return b", "output": "def remove_spaces(input_string: str) -> str:\n    \"\"\"Removes all space characters from the input string.\n\n    Args:\n        input_string: The string from which spaces will be removed.\n\n    Returns:\n        A new string containing all characters from input_string except spaces.\n\n    Examples:\n        >>> remove_spaces(\"hello world\")\n        'helloworld'\n        >>> remove_spaces(\"  test  string  \")\n        'teststring'\n        >>> remove_spaces(\"no_spaces\")\n        'no_spaces'\n    \"\"\"\n    result_chars = []\n    \n    for char in input_string:\n        if char != \" \":\n            result_chars.append(char)\n    \n    return \"\".join(result_chars)"}
{"origin_topic": "根据字典的值对键进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(d):\n    r = []\n    for k in d:\n        r.append((d[k], k))\n    s = sorted(r)\n    o = []\n    for t in s:\n        o.append(t[1])\n    return o", "output": "from typing import Dict, List, TypeVar\n\nT = TypeVar('T')\nK = TypeVar('K')\n\n\ndef sort_dict_by_value(dictionary: Dict[K, T]) -> List[K]:\n    \"\"\"Returns keys sorted by their corresponding values in ascending order.\n\n    Args:\n        dictionary: A dictionary whose keys will be sorted based on their\n            associated values.\n\n    Returns:\n        A list of keys from the input dictionary, ordered by the ascending\n        value of their corresponding dictionary entries.\n\n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        ['b', 'c', 'a']\n    \"\"\"\n    value_key_pairs = [(value, key) for key, value in dictionary.items()]\n    sorted_pairs = sorted(value_key_pairs)\n    sorted_keys = [key for _, key in sorted_pairs]\n    return sorted_keys"}
{"origin_topic": "将二进制字符串转换为十进制数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    x = 0\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == '1':\n            y = 1\n            for j in range(x):\n                y = y * 2\n            b = b + y\n        x = x + 1\n    return b", "output": "def binary_string_to_int(binary_str: str) -> int:\n    \"\"\"Converts a binary string to its integer representation.\n    \n    Args:\n        binary_str: A string containing only '0' and '1' characters.\n    \n    Returns:\n        The integer value represented by the binary string.\n    \n    Raises:\n        ValueError: If the input string contains characters other than '0' or '1'.\n    \"\"\"\n    if not all(char in '01' for char in binary_str):\n        raise ValueError(\"Input must contain only '0' and '1' characters\")\n    \n    result = 0\n    for index, char in enumerate(reversed(binary_str)):\n        if char == '1':\n            result += 1 << index  # Equivalent to 2^index\n    \n    return result"}
{"origin_topic": "检查一个数是否为阿姆斯特朗数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    c = len(str(a))\n    for d in str(a):\n        e = int(d)\n        f = 1\n        for g in range(c):\n            f = f * e\n        b = b + f\n    if b == a:\n        return True\n    else:\n        return False", "output": "def is_armstrong_number(number: int) -> bool:\n    \"\"\"Check if a number is an Armstrong number (Narcissistic number).\n\n    An Armstrong number is a number that is the sum of its own digits each raised\n    to the power of the number of digits.\n\n    Args:\n        number: The integer to check.\n\n    Returns:\n        True if the number is an Armstrong number, False otherwise.\n\n    Examples:\n        >>> is_armstrong_number(153)\n        True\n        >>> is_armstrong_number(9474)\n        True\n        >>> is_armstrong_number(123)\n        False\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    digits_str = str(number)\n    num_digits = len(digits_str)\n    \n    digit_power_sum = 0\n    for digit_char in digits_str:\n        digit = int(digit_char)\n        digit_power_sum += digit ** num_digits\n    \n    return digit_power_sum == number"}
{"origin_topic": "检查数字是否为阿姆斯特朗数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_number(num):\n    if isinstance(num, int) and num >= 0:\n        digits = []\n        temp = num\n        while temp > 0:\n            remainder = temp % 10\n            digits.append(remainder)\n            temp = temp // 10\n        if num == 0:\n            digits = [0]\n        power = len(digits)\n        total_sum = 0\n        for digit in digits:\n            product = 1\n            for _ in range(power):\n                product = product * digit\n            total_sum = total_sum + product\n        if total_sum == num:\n            return True\n        else:\n            return False\n    else:\n        return False", "output": "from typing import Union\n\n\ndef is_armstrong_number(number: Union[int, float]) -> bool:\n    \"\"\"Check if a number is an Armstrong number (Narcissistic number).\n\n    An Armstrong number is a number that is equal to the sum of its own digits\n    each raised to the power of the number of digits.\n\n    Args:\n        number: The number to check. Must be a non-negative integer.\n\n    Returns:\n        True if the number is an Armstrong number, False otherwise.\n        Returns False for negative numbers, non-integers, or invalid inputs.\n\n    Examples:\n        >>> is_armstrong_number(153)\n        True\n        >>> is_armstrong_number(370)\n        True\n        >>> is_armstrong_number(371)\n        True\n        >>> is_armstrong_number(407)\n        True\n        >>> is_armstrong_number(123)\n        False\n        >>> is_armstrong_number(-153)\n        False\n        >>> is_armstrong_number(12.5)\n        False\n    \"\"\"\n    # Validate input: must be non-negative integer\n    if not isinstance(number, int) or number < 0:\n        return False\n\n    # Handle edge case: 0 is an Armstrong number\n    if number == 0:\n        return True\n\n    # Extract digits from the number\n    digits = []\n    remaining_number = number\n    while remaining_number > 0:\n        digit = remaining_number % 10\n        digits.append(digit)\n        remaining_number //= 10\n\n    # Calculate number of digits\n    digit_count = len(digits)\n\n    # Calculate sum of digits raised to the power of digit_count\n    sum_of_powers = 0\n    for digit in digits:\n        sum_of_powers += digit ** digit_count\n\n    # Check if it's an Armstrong number\n    return sum_of_powers == number"}
{"origin_topic": "将字符串中的数字替换为'#'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for i in range(len(b)):\n        if b[i] in \"0123456789\":\n            x = x + \"#\"\n        else:\n            x = x + b[i]\n    return x", "output": "def mask_digits(text: str) -> str:\n    \"\"\"Replaces all digit characters in the input string with '#'.\n    \n    Args:\n        text: The input string that may contain digits.\n    \n    Returns:\n        A new string where all digits (0-9) are replaced by '#' characters.\n        Non-digit characters remain unchanged.\n    \n    Examples:\n        >>> mask_digits(\"abc123def\")\n        'abc###def'\n        >>> mask_digits(\"No digits here\")\n        'No digits here'\n        >>> mask_digits(\"Phone: 555-1234\")\n        'Phone: ###-####'\n    \"\"\"\n    masked_text = []\n    \n    for character in text:\n        if character.isdigit():\n            masked_text.append(\"#\")\n        else:\n            masked_text.append(character)\n    \n    return \"\".join(masked_text)"}
{"origin_topic": "检查一个字符串是否对称", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    l = len(s)\n    if l == 0:\n        return True\n    i = 0\n    j = l - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i = i + 1\n        j = j - 1\n    return True", "output": "def is_palindrome(text: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\n    \n    A palindrome is a string that reads the same forwards and backwards,\n    ignoring spaces, punctuation, and capitalization. This implementation\n    performs a case-sensitive comparison.\n    \n    Args:\n        text: The string to check for palindrome property.\n        \n    Returns:\n        True if the string is a palindrome, False otherwise.\n        \n    Examples:\n        >>> is_palindrome(\"racecar\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"a\")\n        True\n        >>> is_palindrome(\"\")\n        True\n    \"\"\"\n    length = len(text)\n    \n    # Empty string is considered a palindrome\n    if length == 0:\n        return True\n    \n    left_index = 0\n    right_index = length - 1\n    \n    while left_index < right_index:\n        if text[left_index] != text[right_index]:\n            return False\n        left_index += 1\n        right_index -= 1\n    \n    return True"}
{"origin_topic": "找出字符串中所有数字的位置", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def find_numbers_in_string(input_string):\n    result_list = []\n    for index in range(len(input_string)):\n        current_char = input_string[index]\n        if current_char == '0' or current_char == '1' or current_char == '2' or current_char == '3' or current_char == '4' or current_char == '5' or current_char == '6' or current_char == '7' or current_char == '8' or current_char == '9':\n            result_list.append(index)\n    return result_list", "output": "def find_digit_indices(input_string: str) -> list[int]:\n    \"\"\"返回字符串中所有数字字符的索引位置。\n    \n    遍历输入字符串，识别所有数字字符（0-9）并记录它们的索引位置。\n    \n    Args:\n        input_string: 需要搜索的输入字符串。\n        \n    Returns:\n        包含所有数字字符索引的列表，按出现顺序排列。\n        如果字符串中没有数字，返回空列表。\n        \n    Examples:\n        >>> find_digit_indices(\"abc123def\")\n        [3, 4, 5]\n        >>> find_digit_indices(\"no digits here\")\n        []\n        >>> find_digit_indices(\"\")\n        []\n    \"\"\"\n    digit_indices = []\n    \n    for index, character in enumerate(input_string):\n        if character.isdigit():\n            digit_indices.append(index)\n    \n    return digit_indices"}
{"origin_topic": "统计字符串中元音字母的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_vowels(input_string):\n    vowels = \"aeiouAEIOU\"\n    count = 0\n    for char in input_string:\n        for vowel in vowels:\n            if char == vowel:\n                count = count + 1\n                break\n    return count", "output": "def count_vowels(text: str) -> int:\n    \"\"\"Counts the number of vowel characters in the given string.\n    \n    Vowels are defined as the letters a, e, i, o, u in both lowercase and\n    uppercase. All other characters (including accented vowels, numbers,\n    punctuation, and whitespace) are ignored.\n    \n    Args:\n        text: The input string to analyze.\n    \n    Returns:\n        The total count of vowel characters in the input string.\n    \n    Examples:\n        >>> count_vowels(\"Hello World\")\n        3\n        >>> count_vowels(\"Python\")\n        1\n        >>> count_vowels(\"\")\n        0\n    \"\"\"\n    vowel_characters = \"aeiouAEIOU\"\n    vowel_count = 0\n    \n    for character in text:\n        if character in vowel_characters:\n            vowel_count += 1\n    \n    return vowel_count"}
{"origin_topic": "将一个数字四舍五入到最近的整数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(x):\n    b = int(x)\n    if x - b >= 0.5:\n        return b + 1\n    else:\n        return b", "output": "def round_to_nearest_integer(value: float) -> int:\n    \"\"\"Rounds a floating-point number to the nearest integer.\n    \n    Uses standard rounding rules where values >= 0.5 round up,\n    and values < 0.5 round down.\n    \n    Args:\n        value: The floating-point number to round.\n        \n    Returns:\n        The nearest integer to the input value.\n        \n    Raises:\n        ValueError: If the input cannot be converted to float.\n    \"\"\"\n    try:\n        float_value = float(value)\n    except (ValueError, TypeError) as e:\n        raise ValueError(f\"Input must be convertible to float. Got: {value}\") from e\n    \n    integer_part = int(float_value)\n    fractional_part = float_value - integer_part\n    \n    if fractional_part >= 0.5:\n        return integer_part + 1\n    return integer_part"}
{"origin_topic": "生成一个NxN的单位矩阵", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def generate_matrix(n):\n    result = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            if i == j:\n                row.append(1)\n            else:\n                row.append(0)\n        result.append(row)\n    return result", "output": "from typing import List\n\n\ndef generate_identity_matrix(size: int) -> List[List[int]]:\n    \"\"\"生成指定大小的单位矩阵。\n    \n    单位矩阵是一个方阵，主对角线上的元素为1，其余元素为0。\n    \n    Args:\n        size: 矩阵的维度，必须为正整数。\n    \n    Returns:\n        一个大小为 size × size 的单位矩阵，表示为二维整数列表。\n    \n    Raises:\n        ValueError: 如果 size 小于等于 0。\n    \n    Examples:\n        >>> generate_identity_matrix(3)\n        [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    \"\"\"\n    if size <= 0:\n        raise ValueError(f\"矩阵大小必须为正整数，当前输入: {size}\")\n    \n    identity_matrix: List[List[int]] = []\n    \n    for row_index in range(size):\n        row: List[int] = []\n        for column_index in range(size):\n            # 主对角线元素设为1，其余为0\n            element = 1 if row_index == column_index else 0\n            row.append(element)\n        identity_matrix.append(row)\n    \n    return identity_matrix"}
{"origin_topic": "将分钟转换为小时和分钟", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_minutes_to_hours_and_minutes(a):\n    b = 0\n    while a >= 60:\n        a = a - 60\n        b = b + 1\n    x = a\n    if x < 0:\n        x = 0\n    if b < 0:\n        b = 0\n    return b, x", "output": "def convert_minutes_to_hours_and_minutes(total_minutes: int) -> tuple[int, int]:\n    \"\"\"将分钟数转换为小时和分钟的组合表示。\n    \n    该函数将输入的分钟数转换为小时和分钟的格式，确保结果中的分钟数小于60，\n    并且小时和分钟均为非负值。\n    \n    Args:\n        total_minutes: 需要转换的总分钟数，应为整数\n        \n    Returns:\n        一个包含两个整数的元组：(小时数, 分钟数)\n        \n    Examples:\n        >>> convert_minutes_to_hours_and_minutes(125)\n        (2, 5)\n        >>> convert_minutes_to_hours_and_minutes(45)\n        (0, 45)\n        >>> convert_minutes_to_hours_and_minutes(-10)\n        (0, 0)\n    \"\"\"\n    if total_minutes < 0:\n        return 0, 0\n    \n    hours = total_minutes // 60\n    minutes = total_minutes % 60\n    \n    return hours, minutes"}
{"origin_topic": "检查数字是否为素数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_prime_number(num):\n    if num <= 1:\n        return False\n    a = 2\n    while a * a <= num:\n        if num % a == 0:\n            return False\n        a = a + 1\n    return True", "output": "def is_prime(number: int) -> bool:\n    \"\"\"Check if a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive\n    divisors other than 1 and itself.\n\n    Args:\n        number: The integer to check for primality.\n\n    Returns:\n        True if the number is prime, False otherwise.\n\n    Examples:\n        >>> is_prime(2)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(17)\n        True\n        >>> is_prime(1)\n        False\n    \"\"\"\n    if number <= 1:\n        return False\n\n    divisor = 2\n    while divisor * divisor <= number:\n        if number % divisor == 0:\n            return False\n        divisor += 1\n\n    return True"}
{"origin_topic": "判断年份是否为闰年", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_year(a):\n    if a % 4 == 0:\n        if a % 100 == 0:\n            if a % 400 == 0:\n                return True\n            else:\n                return False\n        else:\n            return True\n    else:\n        return False", "output": "def is_leap_year(year: int) -> bool:\n    \"\"\"判断给定年份是否为闰年。\n    \n    根据格里高利历闰年规则：\n    1. 能被4整除但不能被100整除的年份为闰年\n    2. 能被400整除的年份为闰年\n    \n    Args:\n        year: 要检查的年份，必须为整数\n        \n    Returns:\n        True 如果年份是闰年，否则 False\n        \n    Raises:\n        TypeError: 如果输入不是整数\n        \n    Examples:\n        >>> is_leap_year(2000)\n        True\n        >>> is_leap_year(1900)\n        False\n        >>> is_leap_year(2024)\n        True\n    \"\"\"\n    if not isinstance(year, int):\n        raise TypeError(f\"年份必须是整数，但收到 {type(year).__name__}\")\n    \n    # 闰年判断逻辑\n    divisible_by_4 = year % 4 == 0\n    divisible_by_100 = year % 100 == 0\n    divisible_by_400 = year % 400 == 0\n    \n    return divisible_by_4 and (not divisible_by_100 or divisible_by_400)"}
{"origin_topic": "从字符串中删除所有标点符号", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    for x in s:\n        b = False\n        if x == '!':\n            b = True\n        if x == '\"':\n            b = True\n        if x == '#':\n            b = True\n        if x == '$':\n            b = True\n        if x == '%':\n            b = True\n        if x == '&':\n            b = True\n        if x == \"'\":\n            b = True\n        if x == '(':\n            b = True\n        if x == ')':\n            b = True\n        if x == '*':\n            b = True\n        if x == '+':\n            b = True\n        if x == ',':\n            b = True\n        if x == '-':\n            b = True\n        if x == '.':\n            b = True\n        if x == '/':\n            b = True\n        if x == ':':\n            b = True\n        if x == ';':\n            b = True\n        if x == '<':\n            b = True\n        if x == '=':\n            b = True\n        if x == '>':\n            b = True\n        if x == '?':\n            b = True\n        if x == '@':\n            b = True\n        if x == '[':\n            b = True\n        if x == '\\\\':\n            b = True\n        if x == ']':\n            b = True\n        if x == '^':\n            b = True\n        if x == '_':\n            b = True\n        if x == '`':\n            b = True\n        if x == '{':\n            b = True\n        if x == '|':\n            b = True\n        if x == '}':\n            b = True\n        if x == '~':\n            b = True\n        if not b:\n            a.append(x)\n    return ''.join(a)", "output": "from typing import Iterable\n\n\ndef remove_punctuation_chars(input_string: str) -> str:\n    \"\"\"Removes punctuation characters from the input string.\n\n    This function filters out common punctuation and special characters\n    as defined by the standard ASCII punctuation range.\n\n    Args:\n        input_string: The string from which punctuation will be removed.\n\n    Returns:\n        A new string containing only non-punctuation characters from the input.\n\n    Examples:\n        >>> remove_punctuation_chars(\"Hello, World!\")\n        'Hello World'\n        >>> remove_punctuation_chars(\"test@example.com\")\n        'testexamplecom'\n    \"\"\"\n    # Define punctuation characters using string module for clarity\n    PUNCTUATION_CHARS = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n    \n    # Use list comprehension for better readability and performance\n    filtered_chars = [\n        char for char in input_string \n        if char not in PUNCTUATION_CHARS\n    ]\n    \n    return ''.join(filtered_chars)"}
{"origin_topic": "统计一段文本中单词的频率", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(t):\n    d = {}\n    w = \"\"\n    for c in t:\n        if c.isalpha():\n            w += c\n        else:\n            if w:\n                if w in d:\n                    d[w] = d[w] + 1\n                else:\n                    d[w] = 1\n                w = \"\"\n    if w:\n        if w in d:\n            d[w] = d[w] + 1\n        else:\n            d[w] = 1\n    return d", "output": "from typing import Dict\n\n\ndef count_words(text: str) -> Dict[str, int]:\n    \"\"\"Count occurrences of each word in the given text.\n    \n    Words are defined as sequences of alphabetic characters separated by\n    non-alphabetic characters. Case-sensitive counting is performed.\n    \n    Args:\n        text: Input string to analyze for word frequencies.\n        \n    Returns:\n        Dictionary mapping each word to its frequency count.\n        \n    Example:\n        >>> count_words(\"Hello world! Hello everyone.\")\n        {'Hello': 2, 'world': 1, 'everyone': 1}\n    \"\"\"\n    word_counts: Dict[str, int] = {}\n    current_word = \"\"\n    \n    for character in text:\n        if character.isalpha():\n            current_word += character\n        else:\n            if current_word:\n                word_counts[current_word] = word_counts.get(current_word, 0) + 1\n                current_word = \"\"\n    \n    # Handle the last word if text ends with alphabetic characters\n    if current_word:\n        word_counts[current_word] = word_counts.get(current_word, 0) + 1\n    \n    return word_counts"}
{"origin_topic": "将数字转换为二进制字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(x):\n    b = \"\"\n    if x == 0:\n        b = \"0\"\n    else:\n        while x > 0:\n            c = x % 2\n            if c == 0:\n                b = \"0\" + b\n            else:\n                b = \"1\" + b\n            x = x // 2\n    return b", "output": "def decimal_to_binary_string(decimal_number: int) -> str:\n    \"\"\"Convert a non-negative integer to its binary string representation.\n    \n    Args:\n        decimal_number: A non-negative integer to convert to binary.\n        \n    Returns:\n        A string representing the binary equivalent of the input number.\n        \n    Examples:\n        >>> decimal_to_binary_string(0)\n        '0'\n        >>> decimal_to_binary_string(5)\n        '101'\n        >>> decimal_to_binary_string(10)\n        '1010'\n    \"\"\"\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    current_number = decimal_number\n    \n    while current_number > 0:\n        remainder = current_number % 2\n        # Prepend the binary digit to maintain correct order\n        binary_digits.insert(0, str(remainder))\n        current_number //= 2\n    \n    return \"\".join(binary_digits)"}
{"origin_topic": "将一个字符串中的数字替换为'#'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = ''\n    for d in b:\n        e = False\n        for f in range(10):\n            if d == str(f):\n                e = True\n        if e:\n            c = c + '#'\n        else:\n            c = c + d\n    return c", "output": "def replace_digits_with_hash(input_string: str) -> str:\n    \"\"\"Replace all digit characters in a string with '#' symbols.\n    \n    Args:\n        input_string: The string to process. Any digit characters (0-9) will be\n            replaced with '#' symbols, while all other characters remain unchanged.\n    \n    Returns:\n        A new string where all digit characters have been replaced with '#'.\n    \n    Examples:\n        >>> replace_digits_with_hash(\"abc123def\")\n        'abc###def'\n        >>> replace_digits_with_hash(\"No digits here!\")\n        'No digits here!'\n        >>> replace_digits_with_hash(\"\")\n        ''\n    \"\"\"\n    result_chars = []\n    \n    for char in input_string:\n        if char.isdigit():\n            result_chars.append('#')\n        else:\n            result_chars.append(char)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "计算字符串中元音和辅音的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_letters(input_string):\n    vowels_count = 0\n    consonants_count = 0\n    vowels_set = set('aeiouAEIOU')\n    for character in input_string:\n        if character.isalpha():\n            if character in vowels_set:\n                vowels_count = vowels_count + 1\n            else:\n                consonants_count = consonants_count + 1\n        else:\n            continue\n    return vowels_count, consonants_count", "output": "from typing import Tuple\n\n\ndef count_letters(text: str) -> Tuple[int, int]:\n    \"\"\"Counts the number of vowels and consonants in a given string.\n\n    This function iterates through each character in the input string,\n    identifies alphabetic characters, and classifies them as either\n    vowels or consonants. Non-alphabetic characters are ignored.\n\n    Args:\n        text: The input string to analyze.\n\n    Returns:\n        A tuple containing two integers:\n        - First element: count of vowels (case-insensitive)\n        - Second element: count of consonants (case-insensitive)\n\n    Examples:\n        >>> count_letters(\"Hello World!\")\n        (3, 7)\n        >>> count_letters(\"Python 3.9\")\n        (1, 5)\n    \"\"\"\n    vowel_count = 0\n    consonant_count = 0\n    vowels = set('aeiouAEIOU')\n\n    for character in text:\n        if not character.isalpha():\n            continue\n\n        if character in vowels:\n            vowel_count += 1\n        else:\n            consonant_count += 1\n\n    return vowel_count, consonant_count"}
{"origin_topic": "将字符串按逗号分割并去除每个元素两端的空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = a.split(',')\n    for y in x:\n        z = y.strip()\n        b.append(z)\n    return b", "output": "from typing import List\n\n\ndef parse_comma_separated_string(input_string: str) -> List[str]:\n    \"\"\"Parse a comma-separated string into a list of trimmed elements.\n    \n    Args:\n        input_string: A string containing comma-separated values.\n        \n    Returns:\n        A list of strings with whitespace stripped from each element.\n        \n    Example:\n        >>> parse_comma_separated_string(\"apple, banana, cherry\")\n        ['apple', 'banana', 'cherry']\n        >>> parse_comma_separated_string(\"  dog , cat ,  mouse  \")\n        ['dog', 'cat', 'mouse']\n    \"\"\"\n    if not input_string:\n        return []\n    \n    elements = input_string.split(',')\n    trimmed_elements = [element.strip() for element in elements]\n    \n    return trimmed_elements"}
{"origin_topic": "从字符串中移除所有的标点符号", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x.isalpha() or x.isdigit() or x.isspace():\n            b = b + x\n        else:\n            pass\n    return b", "output": "from typing import Union\n\ndef filter_alphanumeric_and_spaces(input_string: str) -> str:\n    \"\"\"Filters a string to keep only alphanumeric characters and spaces.\n    \n    This function iterates through each character in the input string and\n    retains only those that are either letters (a-z, A-Z), digits (0-9),\n    or whitespace characters (space, tab, newline, etc.).\n    \n    Args:\n        input_string: The string to be filtered. Can be any string including\n            special characters, punctuation, etc.\n    \n    Returns:\n        A new string containing only alphanumeric characters and spaces from\n        the original input. If the input is empty, returns an empty string.\n    \n    Examples:\n        >>> filter_alphanumeric_and_spaces(\"Hello, World! 123\")\n        'Hello World 123'\n        >>> filter_alphanumeric_and_spaces(\"Test@#$%String\")\n        'TestString'\n        >>> filter_alphanumeric_and_spaces(\"\")\n        ''\n    \"\"\"\n    filtered_chars: list[str] = []\n    \n    for char in input_string:\n        if char.isalnum() or char.isspace():\n            filtered_chars.append(char)\n    \n    return ''.join(filtered_chars)"}
{"origin_topic": "计算1到n的累加和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(x):\n    a = 0\n    b = 1\n    while b <= x:\n        a = a + b\n        b = b + 1\n    return a", "output": "def sum_integers_up_to_limit(limit: int) -> int:\n    \"\"\"Calculates the sum of all integers from 1 to the given limit (inclusive).\n\n    This function computes the arithmetic series sum: 1 + 2 + 3 + ... + n,\n    where n is the largest integer less than or equal to the input limit.\n\n    Args:\n        limit: The upper bound for the summation (inclusive). Must be >= 1.\n\n    Returns:\n        The sum of integers from 1 to limit.\n\n    Raises:\n        ValueError: If limit is less than 1.\n    \"\"\"\n    if limit < 1:\n        raise ValueError(\"Limit must be at least 1.\")\n\n    total_sum = 0\n    current_number = 1\n\n    while current_number <= limit:\n        total_sum += current_number\n        current_number += 1\n\n    return total_sum"}
{"origin_topic": "计算一个数的立方", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def compute_cubic_value(input_number):\n    temporary_variable_for_storing_input = input_number\n    intermediate_result = temporary_variable_for_storing_input * temporary_variable_for_storing_input\n    final_cubic_result = intermediate_result * temporary_variable_for_storing_input\n    return final_cubic_result", "output": "def compute_cube(number: float) -> float:\n    \"\"\"计算一个数的立方值。\n    \n    该函数接收一个数值参数，返回该数值的三次方结果。\n    \n    Args:\n        number: 需要计算立方的数值\n        \n    Returns:\n        输入数值的立方值\n        \n    Examples:\n        >>> compute_cube(2)\n        8.0\n        >>> compute_cube(3.5)\n        42.875\n    \"\"\"\n    return number ** 3"}
{"origin_topic": "计算一个数字的平方根", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_square_root_of_number(x):\n    a = 0\n    b = x\n    while True:\n        c = (a + b) / 2\n        d = c * c\n        if abs(d - x) < 0.000001:\n            return c\n        elif d > x:\n            b = c\n        else:\n            a = c", "output": "\"\"\"Square root calculation using the bisection method.\"\"\"\n\ndef calculate_square_root(number: float, tolerance: float = 1e-6) -> float:\n    \"\"\"Calculate the square root of a number using the bisection method.\n    \n    Args:\n        number: The number to calculate the square root of. Must be non-negative.\n        tolerance: The acceptable error tolerance for the result.\n    \n    Returns:\n        The square root of the input number.\n    \n    Raises:\n        ValueError: If the input number is negative.\n    \n    Examples:\n        >>> calculate_square_root(4.0)\n        2.0\n        >>> calculate_square_root(2.0, tolerance=1e-9)\n        1.414213562373095\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot calculate square root of negative number.\")\n    \n    if number == 0:\n        return 0.0\n    \n    lower_bound = 0.0\n    upper_bound = max(1.0, number)\n    \n    while True:\n        midpoint = (lower_bound + upper_bound) / 2\n        square = midpoint * midpoint\n        \n        if abs(square - number) < tolerance:\n            return midpoint\n        elif square > number:\n            upper_bound = midpoint\n        else:\n            lower_bound = midpoint"}
{"origin_topic": "将字符串全部转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b:\n        e = d.upper()\n        c.append(e)\n    f = ''.join(c)\n    return f", "output": "from typing import List\n\n\ndef convert_to_uppercase_and_concatenate(strings: List[str]) -> str:\n    \"\"\"将字符串列表中的所有元素转换为大写并连接成一个字符串。\n\n    该函数接收一个字符串列表，将每个字符串转换为大写形式，\n    然后将所有转换后的字符串连接成一个单独的字符串返回。\n\n    Args:\n        strings: 包含待处理字符串的列表。\n\n    Returns:\n        由所有大写字符串连接而成的单个字符串。\n\n    Examples:\n        >>> convert_to_uppercase_and_concatenate(['hello', 'world'])\n        'HELLOWORLD'\n        >>> convert_to_uppercase_and_concatenate(['foo', 'bar', 'baz'])\n        'FOOBARBAZ'\n\n    Raises:\n        AttributeError: 如果列表中的元素不是字符串类型。\n    \"\"\"\n    uppercase_strings: List[str] = []\n    \n    for string in strings:\n        uppercase_string: str = string.upper()\n        uppercase_strings.append(uppercase_string)\n    \n    concatenated_result: str = ''.join(uppercase_strings)\n    return concatenated_result"}
{"origin_topic": "实现一个函数，将秒数转换为'时:分:秒'格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 3600\n    x = (a % 3600) // 60\n    y = a % 60\n    result = str(b).zfill(2) + \":\" + str(x).zfill(2) + \":\" + str(y).zfill(2)\n    return result", "output": "def format_duration(seconds: int) -> str:\n    \"\"\"Converts seconds into HH:MM:SS format.\n\n    Args:\n        seconds: Total number of seconds to convert. Must be non-negative.\n\n    Returns:\n        A string in the format \"HH:MM:SS\" with leading zeros.\n\n    Examples:\n        >>> format_duration(3661)\n        '01:01:01'\n        >>> format_duration(0)\n        '00:00:00'\n    \"\"\"\n    if seconds < 0:\n        raise ValueError(\"Input seconds must be non-negative.\")\n\n    hours = seconds // 3600\n    minutes = (seconds % 3600) // 60\n    remaining_seconds = seconds % 60\n\n    return f\"{hours:02d}:{minutes:02d}:{remaining_seconds:02d}\""}
{"origin_topic": "检查字符串是否包含所有英文字母（忽略大小写）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = set()\n    for b in s:\n        if b.isalpha():\n            a.add(b.lower())\n    x = 0\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        if c in a:\n            x = x + 1\n        else:\n            x = x\n    if x == 26:\n        return True\n    else:\n        return False", "output": "def is_pangram(text: str) -> bool:\n    \"\"\"Check if the input text contains all letters of the English alphabet.\n    \n    A pangram is a sentence containing every letter of the alphabet at least once.\n    This function is case-insensitive and ignores non-alphabetic characters.\n    \n    Args:\n        text: The input string to check for pangram status.\n        \n    Returns:\n        True if the text contains all 26 English letters, False otherwise.\n        \n    Examples:\n        >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n        True\n        >>> is_pangram(\"Hello World\")\n        False\n    \"\"\"\n    # Extract unique lowercase alphabetic characters from the text\n    unique_letters = {\n        char.lower() for char in text \n        if char.isalpha()\n    }\n    \n    # Check if all 26 English letters are present\n    return all(\n        letter in unique_letters \n        for letter in 'abcdefghijklmnopqrstuvwxyz'\n    )"}
{"origin_topic": "计算一个字符串中单词的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = 0\n    d = False\n    for e in b:\n        if e == ' ':\n            if d:\n                c = c + 1\n                d = False\n        else:\n            if not d:\n                d = True\n    if d:\n        c = c + 1\n    return c", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a given string.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    Multiple consecutive spaces are treated as a single separator.\n    \n    Args:\n        text: The input string to count words in.\n        \n    Returns:\n        The number of words in the input string.\n        \n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n    \"\"\"\n    word_count = 0\n    in_word = False\n    \n    for character in text:\n        if character == ' ':\n            if in_word:\n                word_count += 1\n                in_word = False\n        else:\n            if not in_word:\n                in_word = True\n    \n    # Handle the case where the string ends with a word\n    if in_word:\n        word_count += 1\n        \n    return word_count"}
{"origin_topic": "检查一个字符串是否只包含字母", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(x):\n    result = True\n    for a in x:\n        if not (('a' <= a <= 'z') or ('A' <= a <= 'Z')):\n            result = False\n            break\n    if result == True:\n        return True\n    else:\n        return False", "output": "from typing import Union\n\n\ndef is_alphabetic_string(input_string: str) -> bool:\n    \"\"\"检查字符串是否仅包含字母字符。\n\n    遍历字符串中的每个字符，验证其是否为英文字母（大小写均可）。\n    如果发现任何非字母字符，立即返回False。\n\n    Args:\n        input_string: 需要检查的字符串。\n\n    Returns:\n        True: 如果字符串仅包含字母字符。\n        False: 如果字符串包含任何非字母字符。\n\n    Examples:\n        >>> is_alphabetic_string(\"HelloWorld\")\n        True\n        >>> is_alphabetic_string(\"Hello123\")\n        False\n        >>> is_alphabetic_string(\"\")\n        True\n    \"\"\"\n    for character in input_string:\n        if not ('a' <= character <= 'z' or 'A' <= character <= 'Z'):\n            return False\n    return True"}
{"origin_topic": "计算斐波那契数列的前n项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def fibonacci_sequence(n):\n    a = 0\n    b = 1\n    x = []\n    if n <= 0:\n        return x\n    if n == 1:\n        x.append(a)\n        return x\n    if n == 2:\n        x.append(a)\n        x.append(b)\n        return x\n    x.append(a)\n    x.append(b)\n    for i in range(2, n):\n        c = a + b\n        x.append(c)\n        a = b\n        b = c\n    return x", "output": "from typing import List\n\n\ndef generate_fibonacci_sequence(term_count: int) -> List[int]:\n    \"\"\"生成指定长度的斐波那契数列。\n\n    斐波那契数列定义：F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n ≥ 2)\n\n    Args:\n        term_count: 需要生成的斐波那契数列项数。必须为非负整数。\n\n    Returns:\n        包含指定项数的斐波那契数列列表。如果term_count为0，返回空列表。\n\n    Raises:\n        ValueError: 如果term_count为负数。\n\n    Examples:\n        >>> generate_fibonacci_sequence(0)\n        []\n        >>> generate_fibonacci_sequence(1)\n        [0]\n        >>> generate_fibonacci_sequence(5)\n        [0, 1, 1, 2, 3]\n    \"\"\"\n    if term_count < 0:\n        raise ValueError(f\"项数必须为非负整数，但得到: {term_count}\")\n\n    if term_count == 0:\n        return []\n\n    if term_count == 1:\n        return [0]\n\n    fibonacci_sequence = [0, 1]\n\n    previous_term, current_term = 0, 1\n    for _ in range(2, term_count):\n        next_term = previous_term + current_term\n        fibonacci_sequence.append(next_term)\n        previous_term, current_term = current_term, next_term\n\n    return fibonacci_sequence"}
{"origin_topic": "找出字符串中第一个不重复的字符", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def find_first_unique_char(s):\n    if not s:\n        return None\n    char_count = {}\n    for c in s:\n        if c in char_count:\n            char_count[c] = char_count[c] + 1\n        else:\n            char_count[c] = 1\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    return None", "output": "from typing import Optional\n\n\ndef find_first_unique_char(input_string: str) -> Optional[str]:\n    \"\"\"返回字符串中第一个不重复的字符。\n    \n    遍历字符串，统计每个字符的出现次数，然后返回第一个出现次数为1的字符。\n    如果所有字符都重复或字符串为空，则返回None。\n    \n    Args:\n        input_string: 要搜索的输入字符串\n        \n    Returns:\n        第一个不重复的字符，如果没有则返回None\n        \n    Examples:\n        >>> find_first_unique_char(\"leetcode\")\n        'l'\n        >>> find_first_unique_char(\"loveleetcode\")\n        'v'\n        >>> find_first_unique_char(\"aabb\")\n        None\n        >>> find_first_unique_char(\"\")\n        None\n    \"\"\"\n    if not input_string:\n        return None\n    \n    character_frequency = {}\n    for character in input_string:\n        character_frequency[character] = character_frequency.get(character, 0) + 1\n    \n    for character in input_string:\n        if character_frequency[character] == 1:\n            return character\n    \n    return None"}
{"origin_topic": "计算字符串中数字和字母的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_chars(s):\n    a = 0\n    b = 0\n    for x in s:\n        if x.isdigit():\n            a = a + 1\n        elif x.isalpha():\n            b = b + 1\n    return a, b", "output": "from typing import Tuple\n\n\ndef count_character_types(text: str) -> Tuple[int, int]:\n    \"\"\"统计字符串中数字和字母字符的数量。\n\n    Args:\n        text: 需要统计的输入字符串。\n\n    Returns:\n        包含两个整数的元组：(数字字符数量, 字母字符数量)。\n\n    Examples:\n        >>> count_character_types(\"abc123\")\n        (3, 3)\n        >>> count_character_types(\"Hello World 2023!\")\n        (4, 10)\n    \"\"\"\n    digit_count = 0\n    letter_count = 0\n\n    for character in text:\n        if character.isdigit():\n            digit_count += 1\n        elif character.isalpha():\n            letter_count += 1\n\n    return digit_count, letter_count"}
{"origin_topic": "将字符串中的字母全部转换为小写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = d\n        if e.isalpha():\n            f = e.lower()\n            c = c + f\n        else:\n            c = c + e\n    return c", "output": "def normalize_string(input_string: str) -> str:\n    \"\"\"Normalizes a string by converting all alphabetic characters to lowercase.\n    \n    This function processes each character in the input string:\n    - Alphabetic characters are converted to lowercase\n    - Non-alphabetic characters remain unchanged\n    \n    Args:\n        input_string: The string to be normalized\n        \n    Returns:\n        A new string with all alphabetic characters converted to lowercase\n        \n    Examples:\n        >>> normalize_string(\"Hello World!\")\n        'hello world!'\n        >>> normalize_string(\"Python 3.9\")\n        'python 3.9'\n        >>> normalize_string(\"ABC123def\")\n        'abc123def'\n    \"\"\"\n    normalized_chars = []\n    \n    for char in input_string:\n        if char.isalpha():\n            normalized_char = char.lower()\n        else:\n            normalized_char = char\n        normalized_chars.append(normalized_char)\n    \n    return ''.join(normalized_chars)"}
{"origin_topic": "从字符串中移除所有空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        if d != \" \":\n            c = c + d\n    return c", "output": "def remove_spaces(input_string: str) -> str:\n    \"\"\"Removes all space characters from the input string.\n    \n    Args:\n        input_string: The string from which spaces will be removed.\n        \n    Returns:\n        A new string with all space characters removed.\n        \n    Examples:\n        >>> remove_spaces(\"hello world\")\n        'helloworld'\n        >>> remove_spaces(\"  test  string  \")\n        'teststring'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character != \" \":\n            result += character\n    return result"}
{"origin_topic": "找出字符串中最短的单词", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = s.split()\n    b = None\n    for x in a:\n        if b is None:\n            b = x\n        else:\n            if len(x) < len(b):\n                b = x\n            else:\n                if len(x) == len(b):\n                    pass\n                else:\n                    pass\n    return b", "output": "def find_shortest_word(text: str) -> str | None:\n    \"\"\"返回字符串中最短的单词。\n    \n    如果存在多个长度相同的最短单词，返回第一个出现的。\n    如果输入为空字符串或只包含空格，返回None。\n    \n    Args:\n        text: 要处理的输入字符串\n        \n    Returns:\n        最短的单词字符串，如果没有单词则返回None\n        \n    Examples:\n        >>> find_shortest_word(\"hello world python\")\n        'world'\n        >>> find_shortest_word(\"apple banana pear orange\")\n        'pear'\n        >>> find_shortest_word(\"\")\n        None\n    \"\"\"\n    words = text.split()\n    \n    if not words:\n        return None\n    \n    shortest_word = words[0]\n    \n    for word in words[1:]:\n        if len(word) < len(shortest_word):\n            shortest_word = word\n    \n    return shortest_word"}
{"origin_topic": "检查数字是否为质数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    if a <= 1:\n        return False\n    b = 2\n    while b < a:\n        x = a % b\n        if x == 0:\n            return False\n        b = b + 1\n    return True", "output": "def is_prime(number: int) -> bool:\n    \"\"\"Check if a given integer is a prime number.\n    \n    A prime number is a natural number greater than 1 that has no positive\n    divisors other than 1 and itself.\n    \n    Args:\n        number: The integer to check for primality.\n    \n    Returns:\n        True if the number is prime, False otherwise.\n    \n    Raises:\n        ValueError: If the input is not a positive integer.\n    \n    Examples:\n        >>> is_prime(2)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(17)\n        True\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if number <= 1:\n        return False\n    \n    # Check divisibility by numbers from 2 to sqrt(number)\n    divisor = 2\n    while divisor * divisor <= number:\n        if number % divisor == 0:\n            return False\n        divisor += 1\n    \n    return True"}
{"origin_topic": "将字符串中的字母全部转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        if d.isalpha():\n            e = d.upper()\n            c = c + e\n        else:\n            c = c + d\n    return c", "output": "def normalize_and_uppercase_letters(input_string: str) -> str:\n    \"\"\"Converts all alphabetic characters in the string to uppercase.\n\n    This function iterates through each character in the input string.\n    If the character is an alphabetic letter (a-z or A-Z), it converts it to\n    uppercase. All other characters (digits, punctuation, whitespace, etc.)\n    remain unchanged.\n\n    Args:\n        input_string: The original string to process.\n\n    Returns:\n        A new string where all alphabetic characters are converted to uppercase,\n        and all other characters are preserved in their original form.\n\n    Example:\n        >>> normalize_and_uppercase_letters(\"Hello, World! 123\")\n        'HELLO, WORLD! 123'\n    \"\"\"\n    result_chars = []\n    for char in input_string:\n        if char.isalpha():\n            normalized_char = char.upper()\n            result_chars.append(normalized_char)\n        else:\n            result_chars.append(char)\n    return ''.join(result_chars)"}
{"origin_topic": "从字符串中移除所有数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for c in s:\n        if c == \"0\":\n            continue\n        elif c == \"1\":\n            continue\n        elif c == \"2\":\n            continue\n        elif c == \"3\":\n            continue\n        elif c == \"4\":\n            continue\n        elif c == \"5\":\n            continue\n        elif c == \"6\":\n            continue\n        elif c == \"7\":\n            continue\n        elif c == \"8\":\n            continue\n        elif c == \"9\":\n            continue\n        else:\n            r = r + c\n    return r", "output": "def filter_non_digits(input_string: str) -> str:\n    \"\"\"返回移除了所有数字字符的字符串。\n    \n    该函数遍历输入字符串，移除所有数字字符（0-9），\n    保留其他所有字符（包括字母、符号、空格等）。\n    \n    Args:\n        input_string: 需要处理的输入字符串。\n        \n    Returns:\n        移除了所有数字字符的新字符串。\n        \n    Examples:\n        >>> filter_non_digits(\"abc123def\")\n        'abcdef'\n        >>> filter_non_digits(\"Phone: 555-1234\")\n        'Phone: -'\n        >>> filter_non_digits(\"No digits here!\")\n        'No digits here!'\n    \"\"\"\n    filtered_chars = []\n    \n    for char in input_string:\n        if not char.isdigit():\n            filtered_chars.append(char)\n    \n    return ''.join(filtered_chars)"}
{"origin_topic": "验证邮箱地址格式是否合法（简单规则）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(email_string):\n    result_flag = False\n    if email_string is not None:\n        if isinstance(email_string, str):\n            if len(email_string) > 0:\n                email_parts = email_string.split('@')\n                if len(email_parts) == 2:\n                    local_part = email_parts[0]\n                    domain_part = email_parts[1]\n                    if local_part and domain_part:\n                        if '.' in domain_part:\n                            domain_subparts = domain_part.split('.')\n                            if len(domain_subparts) >= 2:\n                                for subpart in domain_subparts:\n                                    if not subpart:\n                                        result_flag = False\n                                        break\n                                else:\n                                    if local_part[0] != '.' and local_part[-1] != '.':\n                                        if '..' not in local_part:\n                                            result_flag = True\n    return result_flag", "output": "\"\"\"Email format validation module.\"\"\"\n\nimport re\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"Validates if the given string is a properly formatted email address.\n    \n    This function checks for basic email format requirements:\n    - Must contain exactly one '@' symbol\n    - Must have non-empty local and domain parts\n    - Domain must contain at least one dot\n    - Domain parts must be non-empty\n    - Local part cannot start or end with a dot\n    - Local part cannot contain consecutive dots\n    \n    Args:\n        email: The email string to validate. Can be None.\n        \n    Returns:\n        True if the email format is valid, False otherwise.\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"user@.com\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    if not email or not isinstance(email, str):\n        return False\n    \n    # Basic structure check: must contain exactly one '@'\n    if email.count('@') != 1:\n        return False\n    \n    local_part, domain_part = email.split('@')\n    \n    # Both parts must be non-empty\n    if not local_part or not domain_part:\n        return False\n    \n    # Domain must contain at least one dot\n    if '.' not in domain_part:\n        return False\n    \n    # Split domain into subdomains\n    domain_subparts = domain_part.split('.')\n    \n    # All domain parts must be non-empty\n    if any(not subpart for subpart in domain_subparts):\n        return False\n    \n    # Local part validation\n    if local_part.startswith('.') or local_part.endswith('.'):\n        return False\n    \n    if '..' in local_part:\n        return False\n    \n    return True\n\n\n# Alternative implementation using regex for more comprehensive validation\ndef is_valid_email_regex(email: Optional[str]) -> bool:\n    \"\"\"Validates email format using RFC 5322 compliant regex.\n    \n    This implementation uses a more comprehensive regex pattern that follows\n    RFC 5322 standards for email validation.\n    \n    Args:\n        email: The email string to validate. Can be None.\n        \n    Returns:\n        True if the email format is valid, False otherwise.\n    \"\"\"\n    if not email or not isinstance(email, str):\n        return False\n    \n    # RFC 5322 compliant email regex pattern\n    pattern = r'^[a-zA-Z0-9.!#$%&\\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'\n    \n    return bool(re.match(pattern, email))"}
{"origin_topic": "将字符串按单词分割并统计单词数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    c = []\n    d = \"\"\n    for e in b:\n        if e != \" \":\n            d = d + e\n        else:\n            if d != \"\":\n                c.append(d)\n                d = \"\"\n    if d != \"\":\n        c.append(d)\n    for f in c:\n        x = x + 1\n    return x", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a given string.\n    \n    Words are defined as sequences of non-space characters separated by one or\n    more spaces. Leading and trailing spaces are ignored.\n    \n    Args:\n        text: The input string to count words from.\n    \n    Returns:\n        The number of words in the input string.\n    \n    Examples:\n        >>> count_words(\"hello world\")\n        2\n        >>> count_words(\"  multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n    \"\"\"\n    if not text:\n        return 0\n    \n    words = []\n    current_word = \"\"\n    \n    for character in text:\n        if character != \" \":\n            current_word += character\n        else:\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n    \n    # Handle the last word if it exists\n    if current_word:\n        words.append(current_word)\n    \n    return len(words)"}
{"origin_topic": "将字符串中的所有空格替换为下划线", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y == \" \":\n            x = x + \"_\"\n        else:\n            x = x + y\n    return x", "output": "def replace_spaces_with_underscores(input_string: str) -> str:\n    \"\"\"Replaces all space characters with underscores in the given string.\n\n    Args:\n        input_string: The string to process. Spaces will be replaced with underscores.\n\n    Returns:\n        A new string with all spaces replaced by underscores.\n\n    Examples:\n        >>> replace_spaces_with_underscores(\"hello world\")\n        'hello_world'\n        >>> replace_spaces_with_underscores(\"multiple   spaces\")\n        'multiple___spaces'\n        >>> replace_spaces_with_underscores(\"\")\n        ''\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character == \" \":\n            result += \"_\"\n        else:\n            result += character\n    return result"}
{"origin_topic": "遍历字典并打印所有键值对", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    for b in a:\n        x = a[b]\n        print(b, x)", "output": "from typing import Dict, Any\n\n\ndef print_dict_items(data: Dict[Any, Any]) -> None:\n    \"\"\"Prints each key-value pair in the provided dictionary.\n    \n    Args:\n        data: A dictionary containing key-value pairs to be printed.\n        \n    Returns:\n        None\n        \n    Example:\n        >>> print_dict_items({\"name\": \"Alice\", \"age\": 30})\n        name Alice\n        age 30\n    \"\"\"\n    for key, value in data.items():\n        print(key, value)"}
{"origin_topic": "检查一个字符串是否为有效的电子邮件地址（简单验证）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                if '@' in a:\n                    x = a.split('@')\n                    if len(x) == 2:\n                        if len(x[0]) > 0:\n                            if len(x[1]) > 0:\n                                if '.' in x[1]:\n                                    y = x[1].split('.')\n                                    if len(y) >= 2:\n                                        for z in y:\n                                            if len(z) > 0:\n                                                b = True\n                                            else:\n                                                b = False\n                                                break\n                                    else:\n                                        b = False\n                                else:\n                                    b = False\n                            else:\n                                b = False\n                        else:\n                            b = False\n                    else:\n                        b = False\n                else:\n                    b = False\n            else:\n                b = False\n        else:\n            b = False\n    else:\n        b = False\n    return b", "output": "import re\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证电子邮件地址格式是否有效。\n    \n    验证规则：\n    1. 输入必须为非空字符串\n    2. 必须包含且仅包含一个 '@' 符号\n    3. '@' 前必须有内容（本地部分）\n    4. '@' 后必须有内容（域名部分）\n    5. 域名部分必须包含至少一个 '.' 符号\n    6. '.' 分隔的每个域名部分必须非空\n    \n    Args:\n        email: 待验证的电子邮件地址，可为None\n        \n    Returns:\n        bool: 如果电子邮件地址格式有效则返回True，否则返回False\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email@\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    # 基础验证：非空字符串\n    if not isinstance(email, str) or not email:\n        return False\n    \n    # 使用正则表达式进行更简洁的验证\n    # 这个正则表达式匹配大多数常见电子邮件格式\n    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    return bool(re.match(email_pattern, email))\n\n\n# 如果需要保持原始逻辑的精确验证，这里提供另一种实现方式\ndef is_valid_email_detailed(email: Optional[str]) -> bool:\n    \"\"\"详细验证电子邮件地址格式是否有效（保持原始逻辑）。\n    \n    此函数保持原始代码的验证逻辑，但进行了重构以提高可读性。\n    \n    Args:\n        email: 待验证的电子邮件地址，可为None\n        \n    Returns:\n        bool: 如果电子邮件地址格式有效则返回True，否则返回False\n    \"\"\"\n    # 基础验证\n    if not isinstance(email, str) or not email:\n        return False\n    \n    # 验证 '@' 符号\n    if '@' not in email:\n        return False\n    \n    # 分割本地部分和域名部分\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    \n    local_part, domain_part = parts\n    \n    # 验证本地部分\n    if not local_part:\n        return False\n    \n    # 验证域名部分\n    if not domain_part:\n        return False\n    \n    # 验证域名包含点号\n    if '.' not in domain_part:\n        return False\n    \n    # 验证域名各部分非空\n    domain_parts = domain_part.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    return all(part for part in domain_parts)"}
{"origin_topic": "计算一个字符串中元音字母的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_vowels(s):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    total = 0\n    for char in s:\n        for v in vowels:\n            if char == v:\n                total = total + 1\n                break\n    return total", "output": "from typing import Iterable\n\n\ndef count_vowels(text: str) -> int:\n    \"\"\"Count the number of vowels in a given string.\n    \n    Args:\n        text: The input string to analyze.\n        \n    Returns:\n        The total count of vowels (both lowercase and uppercase) in the text.\n        \n    Examples:\n        >>> count_vowels(\"Hello World\")\n        3\n        >>> count_vowels(\"Python\")\n        1\n        >>> count_vowels(\"\")\n        0\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    vowel_count = 0\n    \n    for character in text:\n        if character in vowels:\n            vowel_count += 1\n            \n    return vowel_count"}
{"origin_topic": "从字符串中提取所有数字并求和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = ''\n    for e in b:\n        if e.isdigit():\n            d = d + e\n        else:\n            if d:\n                c.append(int(d))\n                d = ''\n    if d:\n        c.append(int(d))\n    f = 0\n    for g in c:\n        f = f + g\n    return f", "output": "from typing import List\n\n\ndef sum_numbers_from_string(text: str) -> int:\n    \"\"\"Extracts and sums all integer numbers from a given string.\n    \n    This function scans through the input string character by character,\n    identifies consecutive digit sequences, converts them to integers,\n    and returns their sum.\n    \n    Args:\n        text: The input string containing alphanumeric characters.\n    \n    Returns:\n        The sum of all integer numbers found in the input string.\n    \n    Examples:\n        >>> sum_numbers_from_string(\"abc123def45gh6\")\n        174\n        >>> sum_numbers_from_string(\"no numbers here\")\n        0\n        >>> sum_numbers_from_string(\"100 200 300\")\n        600\n    \"\"\"\n    numbers: List[int] = []\n    current_number_str: str = ''\n    \n    for character in text:\n        if character.isdigit():\n            current_number_str += character\n        else:\n            if current_number_str:\n                numbers.append(int(current_number_str))\n                current_number_str = ''\n    \n    # Handle any trailing number at the end of the string\n    if current_number_str:\n        numbers.append(int(current_number_str))\n    \n    total_sum: int = 0\n    for number in numbers:\n        total_sum += number\n    \n    return total_sum"}
{"origin_topic": "将一个字符串转换为驼峰命名法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = False\n    for e in b:\n        if e == '_' or e == '-':\n            d = True\n        else:\n            if d:\n                c.append(e.upper())\n                d = False\n            else:\n                c.append(e.lower())\n    f = ''.join(c)\n    if f:\n        g = f[0].lower() + f[1:]\n    else:\n        g = ''\n    return g", "output": "def to_camel_case(input_string: str) -> str:\n    \"\"\"Convert kebab-case or snake_case strings to camelCase.\n\n    This function converts strings with '-' or '_' separators to camelCase format.\n    The first character is always lowercased, and each character following a separator\n    is uppercased while removing the separator.\n\n    Examples:\n        >>> to_camel_case(\"hello-world\")\n        'helloWorld'\n        >>> to_camel_case(\"hello_world\")\n        'helloWorld'\n        >>> to_camel_case(\"hello-world_example\")\n        'helloWorldExample'\n        >>> to_camel_case(\"\")\n        ''\n        >>> to_camel_case(\"single\")\n        'single'\n\n    Args:\n        input_string: A string that may contain '-' or '_' separators.\n\n    Returns:\n        The converted camelCase string. Returns empty string if input is empty.\n    \"\"\"\n    if not input_string:\n        return \"\"\n\n    characters = []\n    capitalize_next = False\n\n    for character in input_string:\n        if character == \"_\" or character == \"-\":\n            capitalize_next = True\n        else:\n            if capitalize_next:\n                characters.append(character.upper())\n                capitalize_next = False\n            else:\n                characters.append(character.lower())\n\n    result = \"\".join(characters)\n    \n    # Ensure first character is lowercase\n    if result:\n        result = result[0].lower() + result[1:]\n\n    return result"}
{"origin_topic": "将字符串中的所有字母转换为小写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = d\n        if e == \"A\":\n            e = \"a\"\n        elif e == \"B\":\n            e = \"b\"\n        elif e == \"C\":\n            e = \"c\"\n        elif e == \"D\":\n            e = \"d\"\n        elif e == \"E\":\n            e = \"e\"\n        elif e == \"F\":\n            e = \"f\"\n        elif e == \"G\":\n            e = \"g\"\n        elif e == \"H\":\n            e = \"h\"\n        elif e == \"I\":\n            e = \"i\"\n        elif e == \"J\":\n            e = \"j\"\n        elif e == \"K\":\n            e = \"k\"\n        elif e == \"L\":\n            e = \"l\"\n        elif e == \"M\":\n            e = \"m\"\n        elif e == \"N\":\n            e = \"n\"\n        elif e == \"O\":\n            e = \"o\"\n        elif e == \"P\":\n            e = \"p\"\n        elif e == \"Q\":\n            e = \"q\"\n        elif e == \"R\":\n            e = \"r\"\n        elif e == \"S\":\n            e = \"s\"\n        elif e == \"T\":\n            e = \"t\"\n        elif e == \"U\":\n            e = \"u\"\n        elif e == \"V\":\n            e = \"v\"\n        elif e == \"W\":\n            e = \"w\"\n        elif e == \"X\":\n            e = \"x\"\n        elif e == \"Y\":\n            e = \"y\"\n        elif e == \"Z\":\n            e = \"z\"\n        c = c + e\n    return c", "output": "def convert_to_lowercase(input_string: str) -> str:\n    \"\"\"将输入字符串中的所有大写字母转换为小写字母。\n    \n    该函数遍历输入字符串中的每个字符，如果字符是大写字母（A-Z），\n    则将其转换为对应的小写字母；其他字符保持不变。\n    \n    Args:\n        input_string: 需要转换的输入字符串\n        \n    Returns:\n        转换后的全小写字符串\n        \n    Examples:\n        >>> convert_to_lowercase(\"Hello WORLD 123!\")\n        'hello world 123!'\n        >>> convert_to_lowercase(\"PYTHON\")\n        'python'\n        >>> convert_to_lowercase(\"\")\n        ''\n    \"\"\"\n    # 使用字典映射提高可读性和性能\n    uppercase_to_lowercase = {\n        'A': 'a', 'B': 'b', 'C': 'c', 'D': 'd', 'E': 'e',\n        'F': 'f', 'G': 'g', 'H': 'h', 'I': 'i', 'J': 'j',\n        'K': 'k', 'L': 'l', 'M': 'm', 'N': 'n', 'O': 'o',\n        'P': 'p', 'Q': 'q', 'R': 'r', 'S': 's', 'T': 't',\n        'U': 'u', 'V': 'v', 'W': 'w', 'X': 'x', 'Y': 'y',\n        'Z': 'z'\n    }\n    \n    result_chars = []\n    for char in input_string:\n        # 使用字典的get方法，如果字符不在字典中则返回原字符\n        converted_char = uppercase_to_lowercase.get(char, char)\n        result_chars.append(converted_char)\n    \n    return ''.join(result_chars)\n\n\n# 更简洁的替代方案（使用内置函数）\ndef convert_to_lowercase_alternative(input_string: str) -> str:\n    \"\"\"使用Python内置方法将字符串转换为小写。\n    \n    注意：这个版本更简洁且性能更好，但为了展示重构过程，\n    上面的版本保留了原始逻辑的结构。\n    \n    Args:\n        input_string: 需要转换的输入字符串\n        \n    Returns:\n        转换后的全小写字符串\n    \"\"\"\n    return input_string.lower()"}
{"origin_topic": "验证邮箱地址格式是否合法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                x = a.find('@')\n                if x > 0:\n                    y = a.find('.', x)\n                    if y > x + 1:\n                        if y < len(a) - 1:\n                            z = a.rfind('.')\n                            if z == y:\n                                if a.count('@') == 1:\n                                    if not a.startswith('.'):\n                                        if not a.endswith('.'):\n                                            if ' ' not in a:\n                                                if '..' not in a:\n                                                    b = True\n    return b", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"Validates if a string is a properly formatted email address.\n    \n    This function performs basic email format validation following common rules:\n    - Must contain exactly one '@' symbol\n    - Must have at least one '.' after the '@'\n    - Cannot start or end with '.'\n    - Cannot contain spaces\n    - Cannot contain consecutive dots ('..')\n    \n    Args:\n        email: The string to validate as an email address. Can be None.\n        \n    Returns:\n        True if the string is a valid email format, False otherwise.\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email@\")\n        False\n        >>> is_valid_email(None)\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    if email is None:\n        return False\n    \n    if not isinstance(email, str):\n        return False\n    \n    if len(email) == 0:\n        return False\n    \n    # Check for exactly one '@' symbol\n    if email.count('@') != 1:\n        return False\n    \n    at_position = email.find('@')\n    \n    # '@' must not be at the beginning\n    if at_position <= 0:\n        return False\n    \n    # Find the first '.' after '@'\n    dot_after_at = email.find('.', at_position)\n    \n    # Must have at least one '.' after '@'\n    if dot_after_at <= at_position + 1:\n        return False\n    \n    # '.' after '@' must not be at the end\n    if dot_after_at >= len(email) - 1:\n        return False\n    \n    # Verify this is the last '.' in the string\n    last_dot_position = email.rfind('.')\n    if last_dot_position != dot_after_at:\n        return False\n    \n    # Additional format checks\n    if email.startswith('.') or email.endswith('.'):\n        return False\n    \n    if ' ' in email:\n        return False\n    \n    if '..' in email:\n        return False\n    \n    return True"}
{"origin_topic": "去除字符串两端的空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    x = 0\n    while x < len(a):\n        if a[x] != \" \":\n            break\n        x = x + 1\n    y = len(a) - 1\n    while y >= 0:\n        if a[y] != \" \":\n            break\n        y = y - 1\n    z = x\n    while z <= y:\n        b = b + a[z]\n        z = z + 1\n    return b", "output": "def trim_whitespace(input_string: str) -> str:\n    \"\"\"Removes leading and trailing whitespace from a string.\n    \n    This function mimics the behavior of Python's built-in str.strip() method,\n    but is implemented manually for demonstration purposes.\n    \n    Args:\n        input_string: The string to be trimmed.\n    \n    Returns:\n        A new string with leading and trailing whitespace removed.\n    \n    Examples:\n        >>> trim_whitespace(\"  hello world  \")\n        'hello world'\n        >>> trim_whitespace(\"no_spaces\")\n        'no_spaces'\n        >>> trim_whitespace(\"   \")\n        ''\n    \"\"\"\n    result = \"\"\n    \n    # Find first non-space character from the left\n    left_index = 0\n    while left_index < len(input_string):\n        if input_string[left_index] != \" \":\n            break\n        left_index += 1\n    \n    # Find first non-space character from the right\n    right_index = len(input_string) - 1\n    while right_index >= 0:\n        if input_string[right_index] != \" \":\n            break\n        right_index -= 1\n    \n    # If the string is all spaces, return empty string\n    if left_index > right_index:\n        return \"\"\n    \n    # Build the trimmed string\n    current_index = left_index\n    while current_index <= right_index:\n        result += input_string[current_index]\n        current_index += 1\n    \n    return result"}
{"origin_topic": "检查年份是否为闰年", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_year(a):\n    b = a % 4\n    x = a % 100\n    y = a % 400\n    if b == 0:\n        if x != 0:\n            return True\n        else:\n            if y == 0:\n                return True\n            else:\n                return False\n    else:\n        return False", "output": "def is_leap_year(year: int) -> bool:\n    \"\"\"Check if a given year is a leap year.\n\n    A leap year is defined as:\n    - Divisible by 4, but not by 100, OR\n    - Divisible by 400.\n\n    Args:\n        year: The year to check.\n\n    Returns:\n        True if the year is a leap year, False otherwise.\n\n    Examples:\n        >>> is_leap_year(2000)\n        True\n        >>> is_leap_year(1900)\n        False\n        >>> is_leap_year(2024)\n        True\n    \"\"\"\n    divisible_by_4 = year % 4 == 0\n    divisible_by_100 = year % 100 == 0\n    divisible_by_400 = year % 400 == 0\n\n    return divisible_by_4 and (not divisible_by_100 or divisible_by_400)"}
{"origin_topic": "验证电子邮件地址的格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(a):\n    b = False\n    if a is not None:\n        if isinstance(a, str):\n            if len(a) > 0:\n                x = a.find('@')\n                if x > 0:\n                    y = a.find('.', x)\n                    if y > x + 1:\n                        if len(a) > y + 1:\n                            z = a.split('@')\n                            if len(z) == 2:\n                                w = z[1].split('.')\n                                if len(w) >= 2:\n                                    for part in w:\n                                        if len(part) == 0:\n                                            b = False\n                                            break\n                                    else:\n                                        b = True\n    return b", "output": "from typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证电子邮件地址格式是否有效。\n    \n    验证规则：\n    1. 输入必须是非空字符串\n    2. 必须包含且仅包含一个 '@' 符号\n    3. '@' 符号前必须有至少一个字符\n    4. '@' 符号后必须包含至少一个 '.' 符号\n    5. '.' 符号必须在 '@' 符号之后且至少相隔一个字符\n    6. 域名部分（'@' 之后）必须包含至少一个 '.' 符号\n    7. 所有域名部分（由 '.' 分隔）必须非空\n    \n    Args:\n        email: 待验证的电子邮件地址字符串，可为 None\n        \n    Returns:\n        bool: 如果电子邮件格式有效返回 True，否则返回 False\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email\")\n        False\n        >>> is_valid_email(None)\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    # 基础验证：非空字符串\n    if not email or not isinstance(email, str):\n        return False\n    \n    email_str = email.strip()\n    if not email_str:\n        return False\n    \n    # 验证 '@' 符号\n    at_symbol_index = email_str.find('@')\n    if at_symbol_index <= 0:  # '@' 必须在字符串中且不在开头\n        return False\n    \n    # 验证域名部分包含 '.'\n    dot_after_at_index = email_str.find('.', at_symbol_index)\n    if dot_after_at_index <= at_symbol_index + 1:  # '.' 必须在 '@' 后且至少相隔一个字符\n        return False\n    \n    # 验证字符串不以 '.' 结尾\n    if dot_after_at_index >= len(email_str) - 1:\n        return False\n    \n    # 分割并验证各部分\n    parts = email_str.split('@')\n    if len(parts) != 2:  # 必须且只能有一个 '@'\n        return False\n    \n    local_part, domain_part = parts\n    \n    # 验证域名部分\n    domain_segments = domain_part.split('.')\n    if len(domain_segments) < 2:  # 域名必须包含至少一个 '.'\n        return False\n    \n    # 验证所有域名段非空\n    if any(not segment for segment in domain_segments):\n        return False\n    \n    return True"}
{"origin_topic": "将字符串按逗号分割并去除首尾空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = a.split(',')\n    for y in x:\n        z = y.strip()\n        b.append(z)\n    return b", "output": "from typing import List\n\n\ndef parse_comma_separated_string(input_string: str) -> List[str]:\n    \"\"\"Parse a comma-separated string into a list of trimmed elements.\n    \n    Args:\n        input_string: A string containing comma-separated values.\n    \n    Returns:\n        A list of strings with whitespace stripped from each element.\n    \n    Examples:\n        >>> parse_comma_separated_string(\"apple, banana, cherry\")\n        ['apple', 'banana', 'cherry']\n        >>> parse_comma_separated_string(\"  dog , cat ,  mouse  \")\n        ['dog', 'cat', 'mouse']\n    \"\"\"\n    if not input_string:\n        return []\n    \n    elements = input_string.split(',')\n    trimmed_elements = [element.strip() for element in elements]\n    \n    return trimmed_elements"}
{"origin_topic": "检查一个字符串是否为有效的电子邮件格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = False\n    if b:\n        d = b.count('@')\n        if d == 1:\n            e = b.split('@')\n            if len(e) == 2:\n                f = e[0]\n                g = e[1]\n                if f and g:\n                    h = g.count('.')\n                    if h >= 1:\n                        i = g.split('.')\n                        j = i[-1]\n                        if len(j) >= 2:\n                            k = True\n                            for l in b:\n                                m = l.isalnum() or l in ['.', '-', '_', '@']\n                                if not m:\n                                    k = False\n                                    break\n                            if k:\n                                n = b[0]\n                                o = b[-1]\n                                if n.isalnum() and o.isalnum():\n                                    p = True\n                                    for q in range(len(b) - 1):\n                                        r = b[q]\n                                        s = b[q + 1]\n                                        if r == '.' and s == '.':\n                                            p = False\n                                            break\n                                    if p:\n                                        c = True\n    return c", "output": "\"\"\"Email address validation module.\n\nThis module provides a function to validate email addresses based on basic\nsyntax rules. Note that this is not a comprehensive email validator and\ndoes not check DNS records or actual mailbox existence.\n\"\"\"\n\nimport re\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"Validates the basic syntax of an email address.\n\n    The function checks:\n    1. Contains exactly one '@' character\n    2. Has non-empty local part and domain part\n    3. Domain contains at least one '.'\n    4. Top-level domain has at least 2 characters\n    5. Contains only allowed characters (alphanumeric, '.', '-', '_', '@')\n    6. Starts and ends with alphanumeric characters\n    7. No consecutive '.' characters\n\n    Args:\n        email: The email address string to validate. If None or empty,\n               returns False.\n\n    Returns:\n        True if the email address passes all syntax checks, False otherwise.\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"user@.com\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    if not email:\n        return False\n\n    # Check for exactly one '@' character\n    if email.count('@') != 1:\n        return False\n\n    # Split into local and domain parts\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n\n    local_part, domain = parts[0], parts[1]\n\n    # Ensure both parts are non-empty\n    if not local_part or not domain:\n        return False\n\n    # Check domain contains at least one '.'\n    if '.' not in domain:\n        return False\n\n    # Split domain and check TLD length\n    domain_parts = domain.split('.')\n    top_level_domain = domain_parts[-1]\n    if len(top_level_domain) < 2:\n        return False\n\n    # Validate allowed characters\n    allowed_chars_pattern = re.compile(r'^[a-zA-Z0-9._\\-@]+$')\n    if not allowed_chars_pattern.match(email):\n        return False\n\n    # Check first and last characters are alphanumeric\n    if not email[0].isalnum() or not email[-1].isalnum():\n        return False\n\n    # Check for consecutive '.' characters\n    if '..' in email:\n        return False\n\n    return True"}
{"origin_topic": "检查一个字符串是否只包含数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(x):\n    result = False\n    for a in x:\n        b = ord(a)\n        if b >= 48 and b <= 57:\n            continue\n        else:\n            result = False\n            return result\n    if len(x) > 0:\n        result = True\n    else:\n        result = False\n    return result", "output": "from typing import Union\n\n\ndef contains_only_digits(input_string: str) -> bool:\n    \"\"\"检查字符串是否仅包含数字字符。\n\n    该函数遍历输入字符串中的每个字符，检查其ASCII码是否在数字字符范围内\n    (ASCII 48-57，对应字符'0'-'9')。如果所有字符都是数字，则返回True，\n    否则返回False。\n\n    Args:\n        input_string: 需要检查的字符串\n\n    Returns:\n        bool: 如果字符串仅包含数字字符则返回True，否则返回False\n\n    Examples:\n        >>> contains_only_digits(\"12345\")\n        True\n        >>> contains_only_digits(\"12a45\")\n        False\n        >>> contains_only_digits(\"\")\n        False\n    \"\"\"\n    # 空字符串直接返回False\n    if not input_string:\n        return False\n\n    for character in input_string:\n        character_code = ord(character)\n        # 检查字符是否在数字ASCII码范围之外\n        if character_code < 48 or character_code > 57:\n            return False\n    \n    return True"}
{"origin_topic": "将字符串中的每个单词反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b.split()\n    for e in d:\n        f = \"\"\n        g = len(e)\n        h = g - 1\n        while h >= 0:\n            f = f + e[h]\n            h = h - 1\n        c.append(f)\n    i = \" \".join(c)\n    return i", "output": "def reverse_words(text: str) -> str:\n    \"\"\"Reverses each word in a given string while preserving word order.\n\n    This function splits the input string into words, reverses each word\n    character by character, and then joins them back together with spaces.\n\n    Args:\n        text: The input string containing words to be reversed.\n\n    Returns:\n        A string where each word from the input has its characters reversed,\n        but the original word order is maintained.\n\n    Examples:\n        >>> reverse_words(\"hello world\")\n        'olleh dlrow'\n        >>> reverse_words(\"Python programming\")\n        'nohtyP gnimmargorp'\n    \"\"\"\n    reversed_words = []\n    words = text.split()\n    \n    for word in words:\n        reversed_word = \"\"\n        word_length = len(word)\n        current_index = word_length - 1\n        \n        # Reverse the word by iterating from end to beginning\n        while current_index >= 0:\n            reversed_word += word[current_index]\n            current_index -= 1\n        \n        reversed_words.append(reversed_word)\n    \n    return \" \".join(reversed_words)"}
{"origin_topic": "将字符串中的所有字母转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = d\n        if e.isalpha():\n            f = e.upper()\n            c = c + f\n        else:\n            g = e\n            c = c + g\n    return c", "output": "def filter_and_uppercase_letters(input_string: str) -> str:\n    \"\"\"Filters a string, converting all alphabetic characters to uppercase.\n    \n    This function processes each character in the input string:\n    - Alphabetic characters are converted to uppercase\n    - Non-alphabetic characters are preserved as-is\n    \n    Args:\n        input_string: The string to be processed. Can contain any characters.\n        \n    Returns:\n        A new string where all alphabetic characters are uppercase and\n        non-alphabetic characters remain unchanged.\n        \n    Examples:\n        >>> filter_and_uppercase_letters(\"Hello, World! 123\")\n        'HELLO, WORLD! 123'\n        >>> filter_and_uppercase_letters(\"abc123def\")\n        'ABC123DEF'\n    \"\"\"\n    result = \"\"\n    \n    for character in input_string:\n        if character.isalpha():\n            uppercase_char = character.upper()\n            result += uppercase_char\n        else:\n            result += character\n    \n    return result"}
{"origin_topic": "统计一段文本中的单词数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = 0\n    d = 0\n    e = False\n    for f in b:\n        if f == ' ' or f == '\\t' or f == '\\n' or f == '\\r':\n            if e == True:\n                c = c + 1\n                e = False\n        else:\n            if e == False:\n                e = True\n    if e == True:\n        c = c + 1\n    return c", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a given string.\n    \n    Words are defined as sequences of non-whitespace characters separated\n    by whitespace (space, tab, newline, or carriage return).\n    \n    Args:\n        text: The input string to count words from.\n        \n    Returns:\n        The number of words in the input string.\n        \n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n    \"\"\"\n    word_count = 0\n    in_word = False\n    \n    for character in text:\n        if character in (' ', '\\t', '\\n', '\\r'):\n            if in_word:\n                word_count += 1\n                in_word = False\n        else:\n            if not in_word:\n                in_word = True\n    \n    # Handle the case where the text ends with a word\n    if in_word:\n        word_count += 1\n        \n    return word_count"}
{"origin_topic": "将字符串中的单词按长度排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = s.split()\n    b = []\n    for x in a:\n        b.append(x)\n    c = []\n    for y in b:\n        c.append(len(y))\n    d = []\n    for i in range(len(c)):\n        d.append((c[i], b[i]))\n    e = []\n    for j in range(len(d)):\n        for k in range(len(d) - 1):\n            if d[k][0] > d[k + 1][0]:\n                t = d[k]\n                d[k] = d[k + 1]\n                d[k + 1] = t\n    f = []\n    for m in d:\n        f.append(m[1])\n    g = ' '.join(f)\n    return g", "output": "from typing import List, Tuple\n\n\ndef sort_words_by_length(text: str) -> str:\n    \"\"\"Sorts words in a string by their length in ascending order.\n    \n    The function splits the input string into words, sorts them by word length\n    (shortest first), and returns a new string with the sorted words.\n    \n    Args:\n        text: The input string containing words to be sorted.\n        \n    Returns:\n        A string containing the words from the input sorted by length.\n        \n    Examples:\n        >>> sort_words_by_length(\"hello world python\")\n        'world hello python'\n        \n        >>> sort_words_by_length(\"a bb ccc dddd\")\n        'a bb ccc dddd'\n    \"\"\"\n    if not text:\n        return \"\"\n    \n    words: List[str] = text.split()\n    \n    # Create list of (length, word) tuples\n    word_length_pairs: List[Tuple[int, str]] = [\n        (len(word), word) for word in words\n    ]\n    \n    # Sort by length (first element of tuple)\n    word_length_pairs.sort(key=lambda pair: pair[0])\n    \n    # Extract sorted words\n    sorted_words: List[str] = [word for _, word in word_length_pairs]\n    \n    return \" \".join(sorted_words)"}
{"origin_topic": "将字符串中的元音字母替换为星号", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    v = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    r = ''\n    for c in s:\n        f = False\n        for vc in v:\n            if c == vc:\n                f = True\n                break\n        if f:\n            r = r + '*'\n        else:\n            r = r + c\n    return r", "output": "def replace_vowels_with_asterisk(text: str) -> str:\n    \"\"\"Replaces all vowel characters in the input string with asterisks.\n    \n    Both lowercase and uppercase vowels (a, e, i, o, u) are replaced.\n    Non-vowel characters remain unchanged.\n    \n    Args:\n        text: The input string to process.\n        \n    Returns:\n        A new string where all vowels are replaced with '*'.\n        \n    Examples:\n        >>> replace_vowels_with_asterisk(\"Hello World\")\n        'H*ll* W*rld'\n        >>> replace_vowels_with_asterisk(\"Python\")\n        'Pyth*n'\n        >>> replace_vowels_with_asterisk(\"AEIOU\")\n        '*****'\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result_chars = []\n    \n    for character in text:\n        if character in vowels:\n            result_chars.append('*')\n        else:\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将一个字符串按空格分割成单词列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = 0\n    y = \"\"\n    for z in a:\n        if z == \" \":\n            if y != \"\":\n                b.append(y)\n                y = \"\"\n        else:\n            y = y + z\n        x = x + 1\n    if y != \"\":\n        b.append(y)\n    return b", "output": "from typing import List\n\n\ndef split_string_by_spaces(input_string: str) -> List[str]:\n    \"\"\"Splits a string into words based on space characters as delimiters.\n    \n    This function processes the input string character by character, accumulating\n    characters into words until a space is encountered. Multiple consecutive spaces\n    are treated as a single delimiter. Words are collected in order and returned\n    as a list.\n    \n    Args:\n        input_string: The string to be split into words.\n        \n    Returns:\n        A list of words extracted from the input string. Returns an empty list\n        if the input string contains no non-space characters.\n        \n    Examples:\n        >>> split_string_by_spaces(\"hello world\")\n        ['hello', 'world']\n        >>> split_string_by_spaces(\"  multiple   spaces   \")\n        ['multiple', 'spaces']\n        >>> split_string_by_spaces(\"\")\n        []\n    \"\"\"\n    words: List[str] = []\n    current_word: str = \"\"\n    \n    for character in input_string:\n        if character == \" \":\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n        else:\n            current_word += character\n    \n    # Append the last word if it exists\n    if current_word:\n        words.append(current_word)\n    \n    return words"}
{"origin_topic": "生成杨辉三角的前N行", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(n):\n    if n <= 0:\n        return []\n    b = [[1]]\n    for x in range(1, n):\n        c = [1]\n        for y in range(1, x):\n            d = b[x-1][y-1] + b[x-1][y]\n            c.append(d)\n        c.append(1)\n        b.append(c)\n    return b", "output": "from typing import List\n\n\ndef generate_pascals_triangle(num_rows: int) -> List[List[int]]:\n    \"\"\"生成指定行数的帕斯卡三角形（杨辉三角）。\n    \n    帕斯卡三角形是一个二维数组，其中每个数字是它正上方两个数字的和。\n    三角形的边缘始终为1。\n    \n    Args:\n        num_rows: 要生成的三角形行数。必须为非负整数。\n        \n    Returns:\n        包含帕斯卡三角形所有行的列表，每行是一个整数列表。\n        如果num_rows <= 0，返回空列表。\n        \n    Examples:\n        >>> generate_pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]\n        \n        >>> generate_pascals_triangle(1)\n        [[1]]\n        \n        >>> generate_pascals_triangle(0)\n        []\n    \"\"\"\n    if num_rows <= 0:\n        return []\n    \n    triangle: List[List[int]] = [[1]]\n    \n    for current_row in range(1, num_rows):\n        new_row = [1]  # 每行的第一个元素总是1\n        \n        for column in range(1, current_row):\n            # 当前元素等于上一行相邻两个元素之和\n            value = triangle[current_row - 1][column - 1] + triangle[current_row - 1][column]\n            new_row.append(value)\n        \n        new_row.append(1)  # 每行的最后一个元素总是1\n        triangle.append(new_row)\n    \n    return triangle"}
{"origin_topic": "检查一个字符串是否以元音字母开头和结尾", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(s):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    if len(s) > 0:\n        first_char = s[0]\n        last_char = s[-1]\n        first_is_vowel = False\n        last_is_vowel = False\n        for v in vowels:\n            if first_char == v:\n                first_is_vowel = True\n            if last_char == v:\n                last_is_vowel = True\n        if first_is_vowel and last_is_vowel:\n            return True\n        else:\n            return False\n    else:\n        return False", "output": "from typing import List\n\n\ndef is_first_and_last_char_vowel(text: str) -> bool:\n    \"\"\"检查字符串的首尾字符是否都是元音字母。\n\n    该函数检查输入字符串的首字符和尾字符是否都是元音字母（包括大小写）。\n    如果字符串为空或首尾字符不都是元音字母，则返回False。\n\n    Args:\n        text: 要检查的输入字符串。\n\n    Returns:\n        True 如果字符串非空且首尾字符都是元音字母，否则返回False。\n\n    Examples:\n        >>> is_first_and_last_char_vowel(\"apple\")\n        True\n        >>> is_first_and_last_char_vowel(\"banana\")\n        False\n        >>> is_first_and_last_char_vowel(\"\")\n        False\n        >>> is_first_and_last_char_vowel(\"Utopia\")\n        True\n    \"\"\"\n    if not text:\n        return False\n\n    vowels: List[str] = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    first_char: str = text[0]\n    last_char: str = text[-1]\n\n    # 使用成员关系检查替代显式循环\n    is_first_vowel: bool = first_char in vowels\n    is_last_vowel: bool = last_char in vowels\n\n    return is_first_vowel and is_last_vowel"}
{"origin_topic": "将蛇形命名转换为驼峰命名", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = False\n    for e in b:\n        if e == '_':\n            d = True\n        else:\n            if d:\n                c.append(e.upper())\n                d = False\n            else:\n                c.append(e)\n    return ''.join(c)", "output": "def convert_snake_to_camel(snake_case_string: str) -> str:\n    \"\"\"Convert snake_case string to camelCase.\n    \n    This function converts a snake_case string to camelCase by removing underscores\n    and capitalizing the following character. The first character remains lowercase.\n    \n    Args:\n        snake_case_string: Input string in snake_case format (e.g., 'hello_world')\n    \n    Returns:\n        String converted to camelCase format (e.g., 'helloWorld')\n    \n    Examples:\n        >>> convert_snake_to_camel('hello_world')\n        'helloWorld'\n        >>> convert_snake_to_camel('my_variable_name')\n        'myVariableName'\n        >>> convert_snake_to_camel('single')\n        'single'\n        >>> convert_snake_to_camel('')\n        ''\n    \"\"\"\n    camel_chars: list[str] = []\n    capitalize_next: bool = False\n    \n    for char in snake_case_string:\n        if char == '_':\n            capitalize_next = True\n        else:\n            if capitalize_next:\n                camel_chars.append(char.upper())\n                capitalize_next = False\n            else:\n                camel_chars.append(char)\n    \n    return ''.join(camel_chars)"}
{"origin_topic": "计算一个数的平方根", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_square_root_of_number(input_value):\n    if input_value < 0:\n        raise ValueError(\"不能处理负数\")\n    else:\n        approximation = input_value / 2.0\n        for _ in range(100):\n            better_approximation = 0.5 * (approximation + input_value / approximation)\n            approximation = better_approximation\n        return approximation", "output": "\"\"\"Module for calculating square roots using the Newton-Raphson method.\"\"\"\n\nfrom typing import Union\n\n\ndef calculate_square_root(\n    number: Union[int, float],\n    max_iterations: int = 100,\n    tolerance: float = 1e-15\n) -> float:\n    \"\"\"Calculate the square root of a non-negative number using Newton-Raphson method.\n\n    Args:\n        number: The non-negative number for which to calculate the square root.\n        max_iterations: Maximum number of iterations for convergence (default: 100).\n        tolerance: Convergence tolerance for stopping early (default: 1e-15).\n\n    Returns:\n        The square root of the input number.\n\n    Raises:\n        ValueError: If the input number is negative.\n        ZeroDivisionError: If the input number is zero (handled by initial guess).\n\n    Example:\n        >>> calculate_square_root(25)\n        5.0\n        >>> calculate_square_root(2, max_iterations=50)\n        1.4142135623730951\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input must be non-negative. Received: {number}\")\n\n    if number == 0:\n        return 0.0\n\n    # Initial guess: half of the input value\n    current_approximation = number / 2.0\n\n    for iteration in range(max_iterations):\n        next_approximation = 0.5 * (\n            current_approximation + number / current_approximation\n        )\n\n        # Check for convergence\n        if abs(next_approximation - current_approximation) < tolerance:\n            return next_approximation\n\n        current_approximation = next_approximation\n\n    return current_approximation"}
{"origin_topic": "反转给定字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for i in range(len(s) - 1, -1, -1):\n        r = r + s[i]\n    return r", "output": "def reverse_string(input_string: str) -> str:\n    \"\"\"Reverses the order of characters in a given string.\n\n    Args:\n        input_string: The string to be reversed.\n\n    Returns:\n        A new string with characters in reverse order.\n\n    Examples:\n        >>> reverse_string(\"hello\")\n        'olleh'\n        >>> reverse_string(\"\")\n        ''\n        >>> reverse_string(\"a\")\n        'a'\n    \"\"\"\n    reversed_chars = []\n    for i in range(len(input_string) - 1, -1, -1):\n        reversed_chars.append(input_string[i])\n    return ''.join(reversed_chars)"}
{"origin_topic": "计算字符串中字母和数字的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = 0\n    b = 0\n    for x in s:\n        if (x >= 'a' and x <= 'z') or (x >= 'A' and x <= 'Z'):\n            a = a + 1\n        elif x >= '0' and x <= '9':\n            b = b + 1\n    return a, b", "output": "from typing import Tuple\n\n\ndef count_letters_and_digits(input_string: str) -> Tuple[int, int]:\n    \"\"\"统计字符串中字母和数字的数量。\n\n    Args:\n        input_string: 需要统计的输入字符串。\n\n    Returns:\n        包含两个整数的元组：(字母数量, 数字数量)。\n\n    Examples:\n        >>> count_letters_and_digits(\"Hello123\")\n        (5, 3)\n        >>> count_letters_and_digits(\"Python 3.9\")\n        (6, 2)\n    \"\"\"\n    letter_count = 0\n    digit_count = 0\n\n    for character in input_string:\n        if character.isalpha():\n            letter_count += 1\n        elif character.isdigit():\n            digit_count += 1\n\n    return letter_count, digit_count"}
{"origin_topic": "将字典按键排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = {}\n    for x in sorted(a.keys()):\n        b[x] = a[x]\n    return b", "output": "from typing import Dict, Any\n\n\ndef sort_dict_by_keys(input_dict: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"返回按键排序后的字典副本。\n    \n    由于Python 3.7+中字典保持插入顺序，此函数确保返回的字典按键排序。\n    适用于需要确定性顺序的场景，如序列化或测试。\n    \n    Args:\n        input_dict: 需要排序的原始字典\n        \n    Returns:\n        按键排序后的新字典\n        \n    Example:\n        >>> sort_dict_by_keys({'c': 3, 'a': 1, 'b': 2})\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\n    sorted_dict: Dict[Any, Any] = {}\n    \n    for key in sorted(input_dict.keys()):\n        sorted_dict[key] = input_dict[key]\n    \n    return sorted_dict"}
{"origin_topic": "将给定的秒数转换为天、小时、分钟、秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a\n    x = b // 86400\n    y = b % 86400\n    z = y // 3600\n    w = y % 3600\n    u = w // 60\n    v = w % 60\n    t = x\n    s = z\n    r = u\n    q = v\n    p = t\n    o = s\n    n = r\n    m = q\n    l = p\n    k = o\n    j = n\n    i = m\n    h = l\n    g = k\n    e = j\n    d = i\n    c = h\n    b = g\n    a = e\n    x = d\n    return c, b, a, x", "output": "def seconds_to_dhms(total_seconds: int) -> tuple[int, int, int, int]:\n    \"\"\"将总秒数转换为天、小时、分钟、秒的元组。\n    \n    参数:\n        total_seconds: 需要转换的总秒数（非负整数）\n    \n    返回:\n        包含四个整数的元组 (days, hours, minutes, seconds)\n    \n    示例:\n        >>> seconds_to_dhms(93784)\n        (1, 2, 3, 4)\n    \"\"\"\n    days = total_seconds // 86400\n    remaining_seconds = total_seconds % 86400\n    \n    hours = remaining_seconds // 3600\n    remaining_seconds %= 3600\n    \n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    \n    return days, hours, minutes, seconds"}
{"origin_topic": "统计字符串中每个单词的出现次数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = {}\n    d = b.split()\n    for e in d:\n        f = 0\n        for g in d:\n            if g == e:\n                f = f + 1\n        c[e] = f\n    return c", "output": "from typing import Dict, List\n\n\ndef count_word_frequencies(text: str) -> Dict[str, int]:\n    \"\"\"Counts the frequency of each word in the given text.\n\n    Args:\n        text: A string containing words separated by whitespace.\n\n    Returns:\n        A dictionary where keys are unique words and values are their\n        corresponding frequencies in the input text.\n\n    Example:\n        >>> count_word_frequencies(\"hello world hello\")\n        {'hello': 2, 'world': 1}\n    \"\"\"\n    word_counts: Dict[str, int] = {}\n    words: List[str] = text.split()\n    \n    for current_word in words:\n        # Count occurrences of current_word in the entire word list\n        frequency = 0\n        for word in words:\n            if word == current_word:\n                frequency += 1\n        word_counts[current_word] = frequency\n    \n    return word_counts"}
{"origin_topic": "检查一个数字是否为完全平方数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check(a):\n    b = 0\n    while b * b <= a:\n        if b * b == a:\n            return True\n        b = b + 1\n    return False", "output": "def is_perfect_square(number: int) -> bool:\n    \"\"\"Check if a given integer is a perfect square.\n\n    A perfect square is an integer that is the square of another integer.\n    This function uses a simple iterative approach to verify if the input\n    number has an integer square root.\n\n    Args:\n        number: The integer to check for perfect square property.\n\n    Returns:\n        True if the input is a perfect square, False otherwise.\n\n    Examples:\n        >>> is_perfect_square(9)\n        True\n        >>> is_perfect_square(10)\n        False\n        >>> is_perfect_square(0)\n        True\n        >>> is_perfect_square(1)\n        True\n    \"\"\"\n    if number < 0:\n        return False\n    \n    candidate_root = 0\n    while candidate_root * candidate_root <= number:\n        if candidate_root * candidate_root == number:\n            return True\n        candidate_root += 1\n    \n    return False"}
{"origin_topic": "将时间从秒转换为小时:分钟:秒格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_time(a):\n    b = 0\n    x = 0\n    while a >= 3600:\n        b = b + 1\n        a = a - 3600\n    while a >= 60:\n        x = x + 1\n        a = a - 60\n    result = str(b) + \":\" + str(x) + \":\" + str(a)\n    return result", "output": "def convert_seconds_to_hms(total_seconds: int) -> str:\n    \"\"\"将总秒数转换为HH:MM:SS格式的字符串。\n    \n    该函数将给定的秒数转换为小时、分钟和秒的格式，\n    并返回格式化的字符串。例如，3665秒将转换为\"1:1:5\"。\n    \n    Args:\n        total_seconds: 需要转换的总秒数，应为非负整数。\n        \n    Returns:\n        格式为\"HH:MM:SS\"的字符串，其中小时和分钟可能为0。\n        \n    Raises:\n        ValueError: 如果输入为负数。\n    \"\"\"\n    if total_seconds < 0:\n        raise ValueError(\"输入秒数不能为负数\")\n    \n    remaining_seconds = total_seconds\n    \n    # 计算小时数\n    hours = remaining_seconds // 3600\n    remaining_seconds %= 3600\n    \n    # 计算分钟数\n    minutes = remaining_seconds // 60\n    remaining_seconds %= 60\n    \n    # 返回格式化的时间字符串\n    return f\"{hours}:{minutes}:{remaining_seconds}\""}
{"origin_topic": "从字符串中提取数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = \"\"\n    e = False\n    for f in b:\n        g = False\n        if f.isdigit():\n            g = True\n        if g:\n            d = d + f\n            e = True\n        else:\n            if e:\n                c.append(d)\n                d = \"\"\n                e = False\n    if e:\n        c.append(d)\n    h = []\n    for i in c:\n        if i:\n            j = int(i)\n            h.append(j)\n    return h", "output": "from typing import List, Optional\n\n\ndef extract_numbers_from_string(input_string: str) -> List[int]:\n    \"\"\"Extracts all consecutive digit sequences from a string and returns them as integers.\n    \n    This function scans the input string character by character, identifies sequences\n    of consecutive digits, converts each sequence to an integer, and returns a list\n    of these integers.\n    \n    Args:\n        input_string: The string from which to extract digit sequences.\n        \n    Returns:\n        A list of integers extracted from the input string. Returns an empty list\n        if no digit sequences are found.\n        \n    Examples:\n        >>> extract_numbers_from_string(\"abc123def45gh6\")\n        [123, 45, 6]\n        >>> extract_numbers_from_string(\"no digits here\")\n        []\n        >>> extract_numbers_from_string(\"123 456 789\")\n        [123, 456, 789]\n    \"\"\"\n    digit_sequences: List[str] = []\n    current_sequence: str = \"\"\n    in_digit_sequence: bool = False\n    \n    # First pass: extract all consecutive digit sequences as strings\n    for character in input_string:\n        is_digit: bool = character.isdigit()\n        \n        if is_digit:\n            current_sequence += character\n            in_digit_sequence = True\n        else:\n            if in_digit_sequence:\n                digit_sequences.append(current_sequence)\n                current_sequence = \"\"\n                in_digit_sequence = False\n    \n    # Handle case where string ends with a digit sequence\n    if in_digit_sequence:\n        digit_sequences.append(current_sequence)\n    \n    # Convert digit sequences to integers\n    result: List[int] = []\n    for sequence in digit_sequences:\n        if sequence:  # Ensure sequence is not empty\n            result.append(int(sequence))\n    \n    return result"}
{"origin_topic": "计算一个数的阶乘", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 1\n    x = 1\n    while x <= a:\n        b = b * x\n        x = x + 1\n    return b", "output": "def factorial(n: int) -> int:\n    \"\"\"Calculate the factorial of a non-negative integer.\n\n    Args:\n        n: A non-negative integer for which to compute the factorial.\n\n    Returns:\n        The factorial of n (n!).\n\n    Raises:\n        ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    result = 1\n    current_multiplier = 1\n    \n    while current_multiplier <= n:\n        result *= current_multiplier\n        current_multiplier += 1\n    \n    return result"}
{"origin_topic": "将字符串中的所有数字移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for c in s:\n        if c == \"0\":\n            continue\n        elif c == \"1\":\n            continue\n        elif c == \"2\":\n            continue\n        elif c == \"3\":\n            continue\n        elif c == \"4\":\n            continue\n        elif c == \"5\":\n            continue\n        elif c == \"6\":\n            continue\n        elif c == \"7\":\n            continue\n        elif c == \"8\":\n            continue\n        elif c == \"9\":\n            continue\n        else:\n            r = r + c\n    return r", "output": "def filter_non_digits(input_string: str) -> str:\n    \"\"\"返回移除了所有数字字符的字符串。\n    \n    该函数遍历输入字符串，移除所有数字字符（0-9），\n    返回只包含非数字字符的新字符串。\n    \n    Args:\n        input_string: 需要处理的输入字符串\n        \n    Returns:\n        移除了所有数字字符的新字符串\n        \n    Examples:\n        >>> filter_non_digits(\"abc123def456\")\n        'abcdef'\n        >>> filter_non_digits(\"hello world\")\n        'hello world'\n        >>> filter_non_digits(\"2024年\")\n        '年'\n    \"\"\"\n    filtered_chars = []\n    \n    for char in input_string:\n        if not char.isdigit():\n            filtered_chars.append(char)\n    \n    return ''.join(filtered_chars)"}
{"origin_topic": "找出字符串中所有数字的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(s):\n    b = 0\n    x = \"\"\n    for i in range(len(s)):\n        if s[i].isdigit():\n            x = x + s[i]\n        else:\n            if x != \"\":\n                b = b + int(x)\n                x = \"\"\n    if x != \"\":\n        b = b + int(x)\n    return b", "output": "def sum_numbers_in_string(text: str) -> int:\n    \"\"\"计算字符串中所有连续数字字符组成的整数的总和。\n\n    该函数遍历输入字符串，识别连续的数字字符序列，将每个序列转换为整数，\n    并返回所有整数的总和。非数字字符作为分隔符使用。\n\n    示例:\n        >>> sum_numbers_in_string(\"abc123def45gh6\")\n        174  # 123 + 45 + 6\n\n    参数:\n        text: 可能包含数字和非数字字符的输入字符串。\n\n    返回:\n        字符串中所有连续数字序列的总和。如果没有数字，则返回0。\n    \"\"\"\n    total_sum = 0\n    current_number_str = \"\"\n\n    for char in text:\n        if char.isdigit():\n            current_number_str += char\n        else:\n            if current_number_str:\n                total_sum += int(current_number_str)\n                current_number_str = \"\"\n\n    # 处理字符串末尾可能存在的数字序列\n    if current_number_str:\n        total_sum += int(current_number_str)\n\n    return total_sum"}
{"origin_topic": "计算1到n的阶乘", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(n):\n    if n == 1:\n        return 1\n    else:\n        b = 1\n        for x in range(1, n + 1):\n            b = b * x\n        return b", "output": "def factorial(n: int) -> int:\n    \"\"\"Calculate the factorial of a non-negative integer.\n    \n    Args:\n        n: A non-negative integer for which to compute the factorial.\n    \n    Returns:\n        The factorial of n, defined as n! = n × (n-1) × ... × 1.\n    \n    Raises:\n        ValueError: If n is negative.\n    \n    Examples:\n        >>> factorial(0)\n        1\n        >>> factorial(5)\n        120\n        >>> factorial(10)\n        3628800\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    if n == 0:\n        return 1\n    \n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    \n    return result"}
{"origin_topic": "将一个时间字符串（如'14:30'）转换为分钟数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = b.split(':')\n    y = int(x[0])\n    z = int(x[1])\n    result = y * 60 + z\n    return result", "output": "def parse_time_to_minutes(time_str: str) -> int:\n    \"\"\"Converts a time string in 'HH:MM' format to total minutes.\n\n    Args:\n        time_str: A string representing time in 'HH:MM' format (24-hour clock).\n\n    Returns:\n        The total number of minutes since midnight.\n\n    Raises:\n        ValueError: If the input string is not in the correct format,\n                   or if hour/minute values are invalid.\n\n    Examples:\n        >>> parse_time_to_minutes(\"14:30\")\n        870\n        >>> parse_time_to_minutes(\"00:15\")\n        15\n    \"\"\"\n    try:\n        hour_str, minute_str = time_str.split(':')\n    except ValueError as exc:\n        raise ValueError(\n            f\"Invalid time format: '{time_str}'. Expected 'HH:MM'.\"\n        ) from exc\n\n    try:\n        hours = int(hour_str)\n        minutes = int(minute_str)\n    except ValueError as exc:\n        raise ValueError(\n            f\"Invalid numeric values in time string: '{time_str}'.\"\n        ) from exc\n\n    if not (0 <= hours <= 23):\n        raise ValueError(f\"Hour must be between 0-23, got: {hours}\")\n    if not (0 <= minutes <= 59):\n        raise ValueError(f\"Minute must be between 0-59, got: {minutes}\")\n\n    return hours * 60 + minutes"}
{"origin_topic": "将一个句子中的单词顺序反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = s.split()\n    c = len(b)\n    d = c - 1\n    while d >= 0:\n        e = b[d]\n        a.append(e)\n        d = d - 1\n    x = ' '.join(a)\n    return x", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n    \n    Words are defined as sequences of characters separated by whitespace.\n    The function preserves the original whitespace between words.\n    \n    Args:\n        sentence: The input string containing words to be reversed.\n        \n    Returns:\n        A new string with words in reverse order.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"Python is great\")\n        'great is Python'\n    \"\"\"\n    words = sentence.split()\n    reversed_words = []\n    \n    # Iterate through words in reverse order\n    for i in range(len(words) - 1, -1, -1):\n        reversed_words.append(words[i])\n    \n    return ' '.join(reversed_words)"}
{"origin_topic": "将十进制整数转换为二进制字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_number(input_value):\n    if input_value == 0:\n        return \"0\"\n    \n    temp_value = abs(input_value)\n    result_string = \"\"\n    \n    while temp_value > 0:\n        remainder_value = temp_value % 2\n        result_string = str(remainder_value) + result_string\n        temp_value = temp_value // 2\n    \n    if input_value < 0:\n        result_string = \"-\" + result_string\n    \n    return result_string", "output": "def decimal_to_binary_string(decimal_number: int) -> str:\n    \"\"\"将十进制整数转换为二进制字符串表示。\n    \n    支持正整数、负整数和零的转换，负数会添加负号前缀。\n    \n    Args:\n        decimal_number: 要转换的十进制整数\n        \n    Returns:\n        二进制字符串表示，例如：\n        - 5 -> \"101\"\n        - -5 -> \"-101\"\n        - 0 -> \"0\"\n        \n    Examples:\n        >>> decimal_to_binary_string(5)\n        '101'\n        >>> decimal_to_binary_string(-5)\n        '-101'\n        >>> decimal_to_binary_string(0)\n        '0'\n    \"\"\"\n    if decimal_number == 0:\n        return \"0\"\n    \n    absolute_value = abs(decimal_number)\n    binary_digits = []\n    \n    while absolute_value > 0:\n        remainder = absolute_value % 2\n        binary_digits.append(str(remainder))\n        absolute_value //= 2\n    \n    binary_digits.reverse()\n    binary_string = \"\".join(binary_digits)\n    \n    if decimal_number < 0:\n        binary_string = f\"-{binary_string}\"\n    \n    return binary_string"}
{"origin_topic": "根据字典值对字典进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(input_dict):\n    result_list = []\n    for key_item in input_dict:\n        result_list.append((key_item, input_dict[key_item]))\n    for i in range(len(result_list)):\n        for j in range(len(result_list) - 1):\n            if result_list[j][1] > result_list[j + 1][1]:\n                temp = result_list[j]\n                result_list[j] = result_list[j + 1]\n                result_list[j + 1] = temp\n    output_dict = {}\n    for pair in result_list:\n        output_dict[pair[0]] = pair[1]\n    return output_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')\nK = TypeVar('K')\nV = TypeVar('V')\n\n\ndef sort_dict_by_value(input_dict: Dict[K, V]) -> Dict[K, V]:\n    \"\"\"Sorts a dictionary by its values in ascending order.\n\n    This function converts the dictionary to a list of key-value pairs,\n    sorts them by value using bubble sort, and reconstructs the dictionary.\n    Note: For production use, consider using built-in sorting methods.\n\n    Args:\n        input_dict: The dictionary to be sorted by values.\n\n    Returns:\n        A new dictionary with the same key-value pairs as input_dict,\n        sorted by values in ascending order.\n\n    Raises:\n        TypeError: If dictionary values are not comparable.\n    \"\"\"\n    # Convert dictionary items to list of tuples\n    items = [(key, value) for key, value in input_dict.items()]\n    \n    # Sort items by value using bubble sort (educational purpose)\n    item_count = len(items)\n    for i in range(item_count):\n        for j in range(item_count - 1):\n            if items[j][1] > items[j + 1][1]:\n                # Swap items\n                items[j], items[j + 1] = items[j + 1], items[j]\n    \n    # Reconstruct sorted dictionary\n    sorted_dict = {key: value for key, value in items}\n    \n    return sorted_dict"}
{"origin_topic": "将字符串中的相邻重复字符删除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    if not s:\n        return s\n    r = []\n    i = 0\n    while i < len(s):\n        c = s[i]\n        if i == 0:\n            r.append(c)\n        else:\n            if c != s[i - 1]:\n                r.append(c)\n        i += 1\n    return ''.join(r)", "output": "def remove_consecutive_duplicates(input_string: str) -> str:\n    \"\"\"Removes consecutive duplicate characters from a string.\n    \n    This function processes the input string and returns a new string where\n    all consecutive duplicate characters are reduced to a single occurrence.\n    \n    Examples:\n        >>> remove_consecutive_duplicates(\"aaabbbccc\")\n        'abc'\n        >>> remove_consecutive_duplicates(\"hello\")\n        'helo'\n        >>> remove_consecutive_duplicates(\"\")\n        ''\n        >>> remove_consecutive_duplicates(\"a\")\n        'a'\n    \n    Args:\n        input_string: The string to process.\n    \n    Returns:\n        A new string with consecutive duplicates removed.\n    \"\"\"\n    if not input_string:\n        return input_string\n    \n    result_chars = []\n    \n    for index, current_char in enumerate(input_string):\n        # First character is always included\n        if index == 0:\n            result_chars.append(current_char)\n        # Only include character if it's different from the previous one\n        elif current_char != input_string[index - 1]:\n            result_chars.append(current_char)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "计算一个数的倒数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_reciprocal_of_number(x):\n    if x == 0:\n        result = None\n    else:\n        a = 1\n        b = x\n        result = a / b\n    return result", "output": "from typing import Optional\n\n\ndef calculate_reciprocal(number: float) -> Optional[float]:\n    \"\"\"Calculates the reciprocal (1/x) of a given number.\n\n    Args:\n        number: The input value for which to calculate the reciprocal.\n\n    Returns:\n        The reciprocal value (1/number) if number is not zero, otherwise None.\n\n    Raises:\n        TypeError: If the input is not a numeric type.\n    \"\"\"\n    if not isinstance(number, (int, float)):\n        raise TypeError(f\"Input must be numeric, got {type(number).__name__}\")\n\n    if number == 0:\n        return None\n\n    numerator = 1.0\n    denominator = float(number)\n    reciprocal = numerator / denominator\n    \n    return reciprocal"}
{"origin_topic": "将字符串中的空格替换为连字符", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y == \" \":\n            x = x + \"-\"\n        else:\n            x = x + y\n    return x", "output": "def replace_spaces_with_dashes(input_string: str) -> str:\n    \"\"\"Replaces all space characters in a string with hyphens.\n    \n    Args:\n        input_string: The original string containing spaces.\n        \n    Returns:\n        A new string where all spaces are replaced with hyphens.\n        \n    Example:\n        >>> replace_spaces_with_dashes(\"hello world python\")\n        'hello-world-python'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character == \" \":\n            result += \"-\"\n        else:\n            result += character\n    return result"}
{"origin_topic": "将字符串按单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = b.split()\n    y = []\n    for z in x:\n        if z:\n            p = z[0].upper()\n            q = z[1:] if len(z) > 1 else ''\n            r = p + q\n            y.append(r)\n        else:\n            y.append('')\n    s = ' '.join(y)\n    return s", "output": "def capitalize_words(text: str) -> str:\n    \"\"\"Capitalizes the first letter of each word in the given string.\n\n    This function splits the input string into words, capitalizes the first\n    character of each non-empty word, and joins them back into a single string.\n    Empty words (resulting from multiple consecutive spaces) are preserved as\n    empty strings in the output.\n\n    Args:\n        text: The input string to process.\n\n    Returns:\n        A new string with the first character of each word capitalized.\n\n    Examples:\n        >>> capitalize_words('hello world')\n        'Hello World'\n        >>> capitalize_words('  multiple   spaces  ')\n        '  Multiple   Spaces  '\n    \"\"\"\n    words = text.split(' ')\n    capitalized_words = []\n\n    for word in words:\n        if not word:  # Handle empty strings from multiple spaces\n            capitalized_words.append('')\n            continue\n\n        first_char = word[0].upper()\n        remaining_chars = word[1:] if len(word) > 1 else ''\n        capitalized_word = first_char + remaining_chars\n        capitalized_words.append(capitalized_word)\n\n    return ' '.join(capitalized_words)"}
{"origin_topic": "检查IP地址是否合法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_ip(a):\n    if not isinstance(a, str):\n        return False\n    b = a.split('.')\n    if len(b) != 4:\n        return False\n    for x in b:\n        if not x.isdigit():\n            return False\n        y = int(x)\n        if y < 0 or y > 255:\n            return False\n        if len(x) > 1 and x[0] == '0':\n            return False\n    return True", "output": "from typing import Union\n\n\ndef is_valid_ipv4_address(ip_string: Union[str, bytes]) -> bool:\n    \"\"\"Validates whether a string represents a valid IPv4 address.\n    \n    Args:\n        ip_string: The string to validate as an IPv4 address.\n    \n    Returns:\n        True if the input is a valid IPv4 address, False otherwise.\n    \n    Examples:\n        >>> is_valid_ipv4_address(\"192.168.1.1\")\n        True\n        >>> is_valid_ipv4_address(\"256.0.0.1\")\n        False\n        >>> is_valid_ipv4_address(\"01.002.003.004\")\n        False\n    \"\"\"\n    # Handle bytes input by decoding to string\n    if isinstance(ip_string, bytes):\n        try:\n            ip_string = ip_string.decode('utf-8')\n        except UnicodeDecodeError:\n            return False\n    \n    # Ensure input is a string\n    if not isinstance(ip_string, str):\n        return False\n    \n    # Split into octets\n    octets = ip_string.split('.')\n    \n    # Must have exactly 4 octets\n    if len(octets) != 4:\n        return False\n    \n    for octet in octets:\n        # Each octet must contain only digits\n        if not octet.isdigit():\n            return False\n        \n        # Check for leading zeros (except single digit zero)\n        if len(octet) > 1 and octet[0] == '0':\n            return False\n        \n        # Convert to integer and check range\n        try:\n            octet_value = int(octet)\n        except ValueError:\n            return False\n            \n        if octet_value < 0 or octet_value > 255:\n            return False\n    \n    return True"}
{"origin_topic": "计算一个数的平方根（使用牛顿法）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_square_root(number):\n    a = number\n    if a < 0:\n        return None\n    b = a / 2.0\n    while True:\n        x = (b + a / b) / 2.0\n        if abs(x - b) < 0.000001:\n            break\n        b = x\n    return x", "output": "\"\"\"Module for calculating square roots using the Newton-Raphson method.\"\"\"\n\nfrom typing import Optional\n\n\ndef calculate_square_root(number: float) -> Optional[float]:\n    \"\"\"Calculate the square root of a number using Newton-Raphson method.\n    \n    Args:\n        number: The number to calculate the square root for. Must be non-negative.\n        \n    Returns:\n        The square root of the input number, or None if the input is negative.\n        \n    Raises:\n        ValueError: If the input is not a number (not implemented in this version).\n        \n    Examples:\n        >>> calculate_square_root(25)\n        5.0\n        >>> calculate_square_root(2)\n        1.414213562373095\n        >>> calculate_square_root(-1) is None\n        True\n    \"\"\"\n    if number < 0:\n        return None\n    \n    # Initial guess: half of the input number\n    current_approximation = number / 2.0\n    tolerance = 1e-6\n    \n    while True:\n        # Newton-Raphson iteration: x_{n+1} = 0.5 * (x_n + a/x_n)\n        next_approximation = (current_approximation + number / current_approximation) / 2.0\n        \n        # Check if we've reached the desired precision\n        if abs(next_approximation - current_approximation) < tolerance:\n            break\n            \n        current_approximation = next_approximation\n    \n    return next_approximation"}
{"origin_topic": "编写函数检查字符串是否为回文", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = list(s)\n    b = []\n    for x in range(len(a)):\n        b.append(a[len(a) - x - 1])\n    c = ''.join(b)\n    if s == c:\n        return True\n    else:\n        return False", "output": "def is_palindrome(text: str) -> bool:\n    \"\"\"Check if a given string is a palindrome.\n    \n    A palindrome is a string that reads the same forwards and backwards,\n    ignoring spaces, punctuation, and capitalization.\n    \n    Args:\n        text: The input string to check.\n        \n    Returns:\n        True if the string is a palindrome, False otherwise.\n        \n    Examples:\n        >>> is_palindrome(\"racecar\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"A man a plan a canal Panama\")\n        False  # Note: This would require additional processing for a real palindrome check\n    \"\"\"\n    # Clean the input: convert to lowercase and remove non-alphanumeric characters\n    # This provides more robust palindrome checking for real-world use cases\n    cleaned_text = ''.join(char.lower() for char in text if char.isalnum())\n    \n    # Compare the cleaned string with its reverse\n    return cleaned_text == cleaned_text[::-1]"}
{"origin_topic": "将字符串中的字母大小写互换", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x.islower():\n            b = b + x.upper()\n        elif x.isupper():\n            b = b + x.lower()\n        else:\n            b = b + x\n    return b", "output": "def swap_case(input_string: str) -> str:\n    \"\"\"Converts lowercase characters to uppercase and vice versa.\n\n    This function iterates through each character in the input string and:\n    - Converts lowercase letters to uppercase\n    - Converts uppercase letters to lowercase\n    - Leaves non-alphabetic characters unchanged\n\n    Args:\n        input_string: The string to be processed.\n\n    Returns:\n        A new string with the case of each alphabetic character swapped.\n\n    Examples:\n        >>> swap_case(\"Hello World!\")\n        'hELLO wORLD!'\n        >>> swap_case(\"Python 3.10\")\n        'pYTHON 3.10'\n    \"\"\"\n    result_chars = []\n    \n    for char in input_string:\n        if char.islower():\n            result_chars.append(char.upper())\n        elif char.isupper():\n            result_chars.append(char.lower())\n        else:\n            result_chars.append(char)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将秒数转换为天、小时、分钟、秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_seconds(a):\n    b = a // 86400\n    x = a % 86400\n    c = x // 3600\n    d = x % 3600\n    e = d // 60\n    f = d % 60\n    g = b\n    h = c\n    i = e\n    j = f\n    k = [g, h, i, j]\n    return k", "output": "def convert_seconds(total_seconds: int) -> list[int]:\n    \"\"\"将总秒数转换为天、小时、分钟、秒的列表。\n    \n    该函数将给定的总秒数分解为天、小时、分钟和秒的整数部分，\n    并返回一个包含这四个值的列表。\n    \n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）。\n        \n    Returns:\n        一个包含四个整数的列表，格式为：[天, 小时, 分钟, 秒]。\n        \n    Examples:\n        >>> convert_seconds(90061)\n        [1, 1, 1, 1]\n        >>> convert_seconds(3661)\n        [0, 1, 1, 1]\n    \"\"\"\n    days = total_seconds // 86400\n    remaining_seconds = total_seconds % 86400\n    \n    hours = remaining_seconds // 3600\n    remaining_seconds %= 3600\n    \n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n    \n    return [days, hours, minutes, seconds]"}
{"origin_topic": "将时间字符串（如'14:30'）转换为分钟数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = b.split(':')\n    y = int(x[0])\n    z = int(x[1])\n    result = y * 60 + z\n    return result", "output": "def parse_time_to_minutes(time_str: str) -> int:\n    \"\"\"Convert a time string in 'HH:MM' format to total minutes.\n    \n    Args:\n        time_str: A string representing time in 'HH:MM' format (24-hour clock).\n        \n    Returns:\n        Total minutes since midnight.\n        \n    Raises:\n        ValueError: If the input string is not in the correct format or contains\n                   invalid time values.\n        \n    Examples:\n        >>> parse_time_to_minutes('02:30')\n        150\n        >>> parse_time_to_minutes('12:45')\n        765\n    \"\"\"\n    try:\n        hour_str, minute_str = time_str.split(':')\n        hours = int(hour_str)\n        minutes = int(minute_str)\n        \n        if hours < 0 or hours > 23:\n            raise ValueError(f'Hour value {hours} is out of valid range (0-23)')\n        if minutes < 0 or minutes > 59:\n            raise ValueError(f'Minute value {minutes} is out of valid range (0-59)')\n            \n        return hours * 60 + minutes\n        \n    except ValueError as e:\n        if 'invalid literal' in str(e):\n            raise ValueError(f'Invalid time format: {time_str}. Expected \"HH:MM\"') from e\n        raise"}
{"origin_topic": "检查一个字符串是否为有效的电子邮件地址", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if b is not None:\n        if isinstance(b, str):\n            if len(b) > 0:\n                if '@' in b:\n                    parts = b.split('@')\n                    if len(parts) == 2:\n                        local_part = parts[0]\n                        domain_part = parts[1]\n                        if local_part and domain_part:\n                            if '.' in domain_part:\n                                domain_parts = domain_part.split('.')\n                                if len(domain_parts) >= 2:\n                                    for d in domain_parts:\n                                        if d:\n                                            pass\n                                        else:\n                                            return x\n                                    if b.count('@') == 1:\n                                        if b[0] != '@' and b[-1] != '@':\n                                            if b[0] != '.' and b[-1] != '.':\n                                                if '..' not in b:\n                                                    if ' ' not in b:\n                                                        x = True\n                                                    else:\n                                                        x = False\n                                                else:\n                                                    x = False\n                                            else:\n                                                x = False\n                                        else:\n                                            x = False\n                                    else:\n                                        x = False\n                                else:\n                                    x = False\n                            else:\n                                x = False\n                        else:\n                            x = False\n                    else:\n                        x = False\n                else:\n                    x = False\n            else:\n                x = False\n        else:\n            x = False\n    else:\n        x = False\n    return x", "output": "\"\"\"Email validation module.\n\nThis module provides a function to validate email addresses according to\nbasic email format requirements.\n\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"Validates if a string is a properly formatted email address.\n\n    Performs basic email format validation including:\n    - Non-empty string\n    - Single '@' character\n    - Valid local and domain parts\n    - Domain contains at least one dot\n    - No leading/trailing dots or '@' characters\n    - No consecutive dots\n    - No spaces\n\n    Args:\n        email: The string to validate as an email address.\n\n    Returns:\n        True if the string appears to be a valid email address, False otherwise.\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid@email\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    if email is None:\n        return False\n\n    if not isinstance(email, str):\n        return False\n\n    if not email:\n        return False\n\n    # Basic '@' validation\n    if '@' not in email:\n        return False\n\n    # Split into local and domain parts\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n\n    local_part, domain_part = parts\n\n    # Validate parts are non-empty\n    if not local_part or not domain_part:\n        return False\n\n    # Validate domain structure\n    if '.' not in domain_part:\n        return False\n\n    domain_subparts = domain_part.split('.')\n    if len(domain_subparts) < 2:\n        return False\n\n    # Validate all domain subparts are non-empty\n    if any(not subpart for subpart in domain_subparts):\n        return False\n\n    # Validate '@' count and position\n    if email.count('@') != 1:\n        return False\n\n    if email[0] == '@' or email[-1] == '@':\n        return False\n\n    # Validate dot position and patterns\n    if email[0] == '.' or email[-1] == '.':\n        return False\n\n    if '..' in email:\n        return False\n\n    # Validate no spaces\n    if ' ' in email:\n        return False\n\n    return True"}
{"origin_topic": "生成斐波那契数列的前N项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def generate_fibonacci_sequence_up_to_n_terms(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    else:\n        a = 0\n        b = 1\n        x = [a, b]\n        while len(x) < n:\n            c = a + b\n            x.append(c)\n            a = b\n            b = c\n        return x", "output": "from typing import List\n\n\ndef generate_fibonacci_sequence(n_terms: int) -> List[int]:\n    \"\"\"Generates the Fibonacci sequence up to the specified number of terms.\n\n    The Fibonacci sequence starts with 0 and 1. Each subsequent term is the sum\n    of the two preceding terms.\n\n    Args:\n        n_terms: The number of terms to generate. Must be a non-negative integer.\n\n    Returns:\n        A list containing the first `n_terms` Fibonacci numbers.\n        Returns an empty list if `n_terms` is 0.\n        Returns [0] if `n_terms` is 1.\n\n    Raises:\n        ValueError: If `n_terms` is negative.\n    \"\"\"\n    if n_terms < 0:\n        raise ValueError(\"Number of terms must be non-negative.\")\n    if n_terms == 0:\n        return []\n    if n_terms == 1:\n        return [0]\n\n    sequence = [0, 1]\n    previous_term, current_term = 0, 1\n\n    while len(sequence) < n_terms:\n        next_term = previous_term + current_term\n        sequence.append(next_term)\n        previous_term, current_term = current_term, next_term\n\n    return sequence"}
{"origin_topic": "计算斐波那契数列的第n项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a = 0\n        b = 1\n        for x in range(2, n + 1):\n            c = a + b\n            a = b\n            b = c\n        return b", "output": "def fibonacci(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\n    \n    The Fibonacci sequence is defined as:\n    F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1\n    \n    Args:\n        n: The position in the Fibonacci sequence (non-negative integer).\n    \n    Returns:\n        The nth Fibonacci number.\n    \n    Raises:\n        ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    \n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    prev_prev = 0  # F(n-2)\n    prev = 1       # F(n-1)\n    \n    for _ in range(2, n + 1):\n        current = prev_prev + prev\n        prev_prev = prev\n        prev = current\n    \n    return prev"}
{"origin_topic": "检查括号字符串是否有效", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = {')': '(', ']': '[', '}': '{'}\n    for c in a:\n        if c in x.values():\n            b.append(c)\n        elif c in x.keys():\n            if not b or b.pop() != x[c]:\n                return False\n        else:\n            continue\n    return not b", "output": "def is_valid_parentheses(expression: str) -> bool:\n    \"\"\"检查括号表达式是否有效。\n\n    有效的括号表达式需要满足：\n    1. 左括号必须用相同类型的右括号闭合\n    2. 左括号必须以正确的顺序闭合\n    3. 每个右括号都有一个对应的相同类型的左括号\n\n    Args:\n        expression: 包含括号的字符串表达式，可能包含其他字符\n\n    Returns:\n        bool: 如果括号表达式有效则返回True，否则返回False\n\n    Examples:\n        >>> is_valid_parentheses(\"()[]{}\")\n        True\n        >>> is_valid_parentheses(\"([{}])\")\n        True\n        >>> is_valid_parentheses(\"(]\")\n        False\n        >>> is_valid_parentheses(\"([)]\")\n        False\n        >>> is_valid_parentheses(\"a(b)c[d]e{f}\")\n        True\n    \"\"\"\n    stack: list[str] = []\n    bracket_pairs: dict[str, str] = {')': '(', ']': '[', '}': '{'}\n    opening_brackets = set(bracket_pairs.values())\n    closing_brackets = set(bracket_pairs.keys())\n\n    for char in expression:\n        if char in opening_brackets:\n            # 遇到左括号，压入栈中\n            stack.append(char)\n        elif char in closing_brackets:\n            # 遇到右括号，检查栈顶是否匹配\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n        # 忽略非括号字符\n\n    # 栈为空表示所有括号都正确匹配\n    return not stack"}
{"origin_topic": "将字符串转换为小写并去除首尾空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a.lower()\n    x = b.strip()\n    return x", "output": "def normalize_string(input_string: str) -> str:\n    \"\"\"将输入字符串转换为小写并移除首尾空白字符。\n    \n    该函数首先将输入字符串转换为全小写格式，然后移除字符串\n    首尾的空白字符（包括空格、制表符、换行符等）。\n    \n    Args:\n        input_string: 需要处理的原始字符串\n        \n    Returns:\n        处理后的标准化字符串\n        \n    Examples:\n        >>> normalize_string(\"  Hello World  \")\n        'hello world'\n        >>> normalize_string(\"PyThOn\\n\")\n        'python'\n        >>> normalize_string(\"\")\n        ''\n    \"\"\"\n    lowercase_string = input_string.lower()\n    normalized_string = lowercase_string.strip()\n    return normalized_string"}
{"origin_topic": "验证电子邮件地址格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    if a is None:\n        return False\n    if not isinstance(a, str):\n        return False\n    if len(a) == 0:\n        return False\n    b = a.split('@')\n    if len(b) != 2:\n        return False\n    x = b[0]\n    y = b[1]\n    if len(x) == 0:\n        return False\n    if len(y) == 0:\n        return False\n    if '.' not in y:\n        return False\n    z = y.split('.')\n    if len(z) < 2:\n        return False\n    for part in z:\n        if len(part) == 0:\n            return False\n    if a[0] == '.' or a[-1] == '.':\n        return False\n    if '..' in a:\n        return False\n    if ' ' in a:\n        return False\n    return True", "output": "\"\"\"Email address validation module.\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"Validates if the given string is a properly formatted email address.\n    \n    This function performs basic email format validation including:\n    - Non-empty string check\n    - Single '@' character presence\n    - Non-empty local part (before '@')\n    - Non-empty domain part (after '@')\n    - Domain contains at least one '.'\n    - No empty segments in domain parts\n    - No leading or trailing dots\n    - No consecutive dots\n    - No spaces\n    \n    Args:\n        email: The string to validate as an email address.\n    \n    Returns:\n        True if the string appears to be a valid email address format,\n        False otherwise.\n    \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"user@.com\")\n        False\n        >>> is_valid_email(None)\n        False\n    \"\"\"\n    # Early return for None or non-string inputs\n    if email is None or not isinstance(email, str):\n        return False\n    \n    # Check for empty string\n    if not email:\n        return False\n    \n    # Check for invalid characters and patterns\n    if ' ' in email or '..' in email:\n        return False\n    \n    # Check for leading or trailing dots\n    if email.startswith('.') or email.endswith('.'):\n        return False\n    \n    # Split into local and domain parts\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    \n    local_part, domain_part = parts\n    \n    # Validate local part\n    if not local_part:\n        return False\n    \n    # Validate domain part\n    if not domain_part or '.' not in domain_part:\n        return False\n    \n    # Split domain into subdomains\n    domain_segments = domain_part.split('.')\n    if len(domain_segments) < 2:\n        return False\n    \n    # Check each domain segment is non-empty\n    if any(not segment for segment in domain_segments):\n        return False\n    \n    return True"}
{"origin_topic": "计算数字的平方根", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_square_root_of_number(x):\n    a = 0\n    b = x\n    while True:\n        c = (a + b) / 2\n        d = c * c\n        if abs(d - x) < 0.000001:\n            return c\n        elif d > x:\n            b = c\n        else:\n            a = c", "output": "\"\"\"Square root calculation using the bisection method.\"\"\"\n\ndef calculate_square_root(number: float, tolerance: float = 1e-6) -> float:\n    \"\"\"Calculate the square root of a number using the bisection method.\n    \n    Args:\n        number: The number to calculate the square root for. Must be non-negative.\n        tolerance: The acceptable error tolerance for the square root approximation.\n    \n    Returns:\n        The approximate square root of the input number.\n    \n    Raises:\n        ValueError: If the input number is negative.\n    \n    Example:\n        >>> calculate_square_root(25.0)\n        5.000000000000001\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot calculate square root of negative number.\")\n    \n    if number == 0:\n        return 0.0\n    \n    lower_bound = 0.0\n    upper_bound = max(1.0, number)\n    \n    while True:\n        midpoint = (lower_bound + upper_bound) / 2.0\n        square = midpoint * midpoint\n        \n        if abs(square - number) < tolerance:\n            return midpoint\n        \n        if square > number:\n            upper_bound = midpoint\n        else:\n            lower_bound = midpoint"}
{"origin_topic": "计算数字的立方", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_cube_of_number(x):\n    a = x\n    b = a * a\n    c = b * a\n    d = c\n    result = d\n    return result", "output": "def calculate_cube_of_number(number: float) -> float:\n    \"\"\"Calculate the cube of a given number.\n    \n    Args:\n        number: The input number to be cubed.\n        \n    Returns:\n        The cube of the input number.\n        \n    Examples:\n        >>> calculate_cube_of_number(2)\n        8.0\n        >>> calculate_cube_of_number(3.5)\n        42.875\n    \"\"\"\n    square = number * number\n    cube = square * number\n    return cube"}
{"origin_topic": "计算字符串中数字字符的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    c = 0\n    for x in s:\n        if x == '0' or x == '1' or x == '2' or x == '3' or x == '4' or x == '5' or x == '6' or x == '7' or x == '8' or x == '9':\n            c = c + 1\n        else:\n            c = c + 0\n    return c", "output": "def count_digits_in_string(input_string: str) -> int:\n    \"\"\"Counts the number of digit characters in a given string.\n\n    This function iterates through each character in the input string and\n    counts how many characters are decimal digits (0-9).\n\n    Args:\n        input_string: The string to be analyzed for digit characters.\n\n    Returns:\n        The total count of digit characters found in the input string.\n\n    Examples:\n        >>> count_digits_in_string(\"abc123\")\n        3\n        >>> count_digits_in_string(\"Hello World!\")\n        0\n        >>> count_digits_in_string(\"2024-01-01\")\n        8\n    \"\"\"\n    digit_count = 0\n    \n    for character in input_string:\n        if character.isdigit():\n            digit_count += 1\n    \n    return digit_count"}
{"origin_topic": "将字典按键和值分别排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict(d):\n    keys_list = []\n    for k in d:\n        keys_list.append(k)\n    sorted_keys = sorted(keys_list)\n    values_list = []\n    for v in d.values():\n        values_list.append(v)\n    sorted_values = sorted(values_list)\n    result = {}\n    result['keys'] = sorted_keys\n    result['values'] = sorted_values\n    return result", "output": "from typing import Dict, List, Any\n\n\ndef sort_dictionary_items(dictionary: Dict[Any, Any]) -> Dict[str, List[Any]]:\n    \"\"\"Sorts dictionary keys and values separately and returns them in a new dictionary.\n    \n    This function extracts all keys and values from the input dictionary, sorts them\n    independently, and returns them in a structured format. Note that the original\n    key-value pairings are not preserved in the output.\n    \n    Args:\n        dictionary: The input dictionary to process. Keys and values can be of any\n            comparable type that supports Python's default sorting.\n    \n    Returns:\n        A dictionary with two keys:\n        - 'keys': A sorted list of all keys from the input dictionary\n        - 'values': A sorted list of all values from the input dictionary\n    \n    Example:\n        >>> sort_dictionary_items({'c': 3, 'a': 1, 'b': 2})\n        {'keys': ['a', 'b', 'c'], 'values': [1, 2, 3]}\n    \"\"\"\n    # Extract and sort keys\n    sorted_keys = sorted(dictionary.keys())\n    \n    # Extract and sort values\n    sorted_values = sorted(dictionary.values())\n    \n    return {'keys': sorted_keys, 'values': sorted_values}"}
{"origin_topic": "生成杨辉三角的前n行", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(n):\n    if n <= 0:\n        return []\n    b = [[1]]\n    for x in range(1, n):\n        c = []\n        d = b[-1]\n        for e in range(len(d) + 1):\n            f = 0\n            if e - 1 >= 0:\n                f = f + d[e - 1]\n            if e < len(d):\n                f = f + d[e]\n            c.append(f)\n        b.append(c)\n    return b", "output": "from typing import List\n\n\ndef generate_pascals_triangle(num_rows: int) -> List[List[int]]:\n    \"\"\"生成指定行数的杨辉三角（帕斯卡三角）。\n    \n    杨辉三角是一个二维数组，其中每个数字是它正上方两个数字之和。\n    第一行只有一个数字1，后续每行比上一行多一个数字。\n    \n    Args:\n        num_rows: 要生成的杨辉三角的行数。必须是非负整数。\n        \n    Returns:\n        包含num_rows行杨辉三角的二维列表。如果num_rows <= 0，返回空列表。\n        \n    Examples:\n        >>> generate_pascals_triangle(3)\n        [[1], [1, 1], [1, 2, 1]]\n        \n        >>> generate_pascals_triangle(1)\n        [[1]]\n        \n        >>> generate_pascals_triangle(0)\n        []\n    \"\"\"\n    if num_rows <= 0:\n        return []\n    \n    triangle: List[List[int]] = [[1]]\n    \n    for row_index in range(1, num_rows):\n        previous_row = triangle[-1]\n        current_row = []\n        \n        for element_index in range(len(previous_row) + 1):\n            element_value = 0\n            \n            # 加上左上方元素（如果存在）\n            if element_index - 1 >= 0:\n                element_value += previous_row[element_index - 1]\n            \n            # 加上右上方元素（如果存在）\n            if element_index < len(previous_row):\n                element_value += previous_row[element_index]\n            \n            current_row.append(element_value)\n        \n        triangle.append(current_row)\n    \n    return triangle"}
{"origin_topic": "将CSV字符串解析为列表的列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    c = 0\n    d = []\n    e = \"\"\n    f = False\n    while c < len(b):\n        g = b[c]\n        if g == '\"':\n            if not f:\n                f = True\n            else:\n                if c + 1 < len(b) and b[c + 1] == '\"':\n                    e = e + g\n                    c = c + 1\n                else:\n                    f = not f\n        elif g == ',':\n            if not f:\n                d.append(e)\n                e = \"\"\n            else:\n                e = e + g\n        elif g == '\\n':\n            if not f:\n                d.append(e)\n                x.append(d)\n                d = []\n                e = \"\"\n            else:\n                e = e + g\n        else:\n            e = e + g\n        c = c + 1\n    if e != \"\" or len(d) > 0:\n        d.append(e)\n    if len(d) > 0:\n        x.append(d)\n    return x", "output": "\"\"\"CSV Parser Module.\n\nThis module provides functionality to parse CSV strings with support for:\n- Quoted fields containing commas and newlines\n- Double quotes as escape mechanism within quoted fields\n\"\"\"\n\nfrom typing import List, Optional\n\n\ndef parse_csv(csv_string: str) -> List[List[str]]:\n    \"\"\"Parse a CSV string into a 2D list of strings.\n\n    This parser handles:\n    - Fields enclosed in double quotes\n    - Commas and newlines within quoted fields\n    - Double quotes escaped as \"\" within quoted fields\n    - Trailing empty fields\n\n    Args:\n        csv_string: The CSV string to parse.\n\n    Returns:\n        A 2D list where each inner list represents a row and each element\n        represents a field.\n\n    Example:\n        >>> parse_csv('a,b,c\\\\n\"d,e\",f,g')\n        [['a', 'b', 'c'], ['d,e', 'f', 'g']]\n\n    Note:\n        This parser does not handle:\n        - Different delimiters (only comma)\n        - Different quote characters (only double quote)\n        - Whitespace trimming\n    \"\"\"\n    rows: List[List[str]] = []\n    current_row: List[str] = []\n    current_field: str = \"\"\n    inside_quotes: bool = False\n    position: int = 0\n\n    while position < len(csv_string):\n        current_char = csv_string[position]\n\n        if current_char == '\"':\n            if not inside_quotes:\n                inside_quotes = True\n            else:\n                # Check for escaped quote (\"\")\n                if position + 1 < len(csv_string) and csv_string[position + 1] == '\"':\n                    current_field += current_char\n                    position += 1  # Skip next quote\n                else:\n                    inside_quotes = not inside_quotes\n\n        elif current_char == ',':\n            if not inside_quotes:\n                current_row.append(current_field)\n                current_field = \"\"\n            else:\n                current_field += current_char\n\n        elif current_char == '\\n':\n            if not inside_quotes:\n                current_row.append(current_field)\n                rows.append(current_row)\n                current_row = []\n                current_field = \"\"\n            else:\n                current_field += current_char\n\n        else:\n            current_field += current_char\n\n        position += 1\n\n    # Handle trailing data\n    if current_field != \"\" or len(current_row) > 0:\n        current_row.append(current_field)\n    if len(current_row) > 0:\n        rows.append(current_row)\n\n    return rows"}
{"origin_topic": "计算字符串中大写字母的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    c = 0\n    for i in range(len(s)):\n        if s[i].isupper():\n            c = c + 1\n        else:\n            pass\n    return c", "output": "def count_uppercase_characters(text: str) -> int:\n    \"\"\"Counts the number of uppercase characters in a given string.\n\n    Args:\n        text: The input string to analyze.\n\n    Returns:\n        The count of uppercase alphabetical characters in the input string.\n        Returns 0 if the string is empty or contains no uppercase characters.\n\n    Examples:\n        >>> count_uppercase_characters(\"Hello World\")\n        2\n        >>> count_uppercase_characters(\"lowercase\")\n        0\n        >>> count_uppercase_characters(\"\")\n        0\n    \"\"\"\n    uppercase_count = 0\n    for character in text:\n        if character.isupper():\n            uppercase_count += 1\n    return uppercase_count"}
{"origin_topic": "找出一个字符串中第一个不重复的字符", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def find_first_unique_char(s):\n    d = {}\n    for i in range(len(s)):\n        c = s[i]\n        if c in d:\n            d[c] = d[c] + 1\n        else:\n            d[c] = 1\n    for j in range(len(s)):\n        ch = s[j]\n        if d[ch] == 1:\n            return ch\n    return None", "output": "from typing import Optional\n\n\ndef find_first_unique_char(string: str) -> Optional[str]:\n    \"\"\"返回字符串中第一个不重复的字符。\n    \n    该函数遍历输入字符串，统计每个字符的出现频率，然后返回第一个\n    出现次数为1的字符。如果不存在这样的字符，则返回None。\n    \n    Args:\n        string: 输入字符串，可能包含任意字符。\n    \n    Returns:\n        第一个不重复的字符，如果不存在则返回None。\n    \n    Examples:\n        >>> find_first_unique_char(\"leetcode\")\n        'l'\n        >>> find_first_unique_char(\"loveleetcode\")\n        'v'\n        >>> find_first_unique_char(\"aabb\")\n        None\n    \"\"\"\n    char_frequency = {}\n    \n    # 统计每个字符的出现频率\n    for char in string:\n        if char in char_frequency:\n            char_frequency[char] += 1\n        else:\n            char_frequency[char] = 1\n    \n    # 查找第一个出现次数为1的字符\n    for char in string:\n        if char_frequency[char] == 1:\n            return char\n    \n    return None"}
{"origin_topic": "提取字符串中的所有数字并求和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    for c in b:\n        d = \"\"\n        while c.isdigit():\n            d = d + c\n            break\n        if d:\n            x.append(int(d))\n    e = 0\n    for f in x:\n        e = e + f\n    return e", "output": "from typing import List, Union\n\n\ndef sum_digits_from_strings(strings: List[str]) -> int:\n    \"\"\"Extracts and sums all digit-only strings from a list of strings.\n\n    Iterates through each string in the input list. If a string consists\n    entirely of digits (0-9), it is converted to an integer and added to\n    the running total.\n\n    Args:\n        strings: A list of strings to process.\n\n    Returns:\n        The sum of all integer values extracted from digit-only strings.\n\n    Examples:\n        >>> sum_digits_from_strings([\"123\", \"abc\", \"45\", \"78\", \"xyz\"])\n        246\n        >>> sum_digits_from_strings([\"hello\", \"world\"])\n        0\n    \"\"\"\n    digit_strings: List[str] = []\n    \n    for string in strings:\n        if string.isdigit():\n            digit_strings.append(string)\n    \n    total: int = 0\n    for digit_string in digit_strings:\n        total += int(digit_string)\n    \n    return total\n\n\n# Alternative implementation using generator expression (more Pythonic)\ndef sum_digits_from_strings_alt(strings: List[str]) -> int:\n    \"\"\"Extracts and sums all digit-only strings from a list of strings.\n\n    Args:\n        strings: A list of strings to process.\n\n    Returns:\n        The sum of all integer values extracted from digit-only strings.\n    \"\"\"\n    return sum(int(s) for s in strings if s.isdigit())"}
{"origin_topic": "将十六进制字符串转换为十进制数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    c = len(a)\n    for d in range(c):\n        e = a[d]\n        if e == '0':\n            f = 0\n        elif e == '1':\n            f = 1\n        elif e == '2':\n            f = 2\n        elif e == '3':\n            f = 3\n        elif e == '4':\n            f = 4\n        elif e == '5':\n            f = 5\n        elif e == '6':\n            f = 6\n        elif e == '7':\n            f = 7\n        elif e == '8':\n            f = 8\n        elif e == '9':\n            f = 9\n        elif e == 'A' or e == 'a':\n            f = 10\n        elif e == 'B' or e == 'b':\n            f = 11\n        elif e == 'C' or e == 'c':\n            f = 12\n        elif e == 'D' or e == 'd':\n            f = 13\n        elif e == 'E' or e == 'e':\n            f = 14\n        elif e == 'F' or e == 'f':\n            f = 15\n        else:\n            f = 0\n        g = c - d - 1\n        h = 1\n        for i in range(g):\n            h = h * 16\n        j = f * h\n        b = b + j\n    return b", "output": "def hex_string_to_int(hex_str: str) -> int:\n    \"\"\"Convert a hexadecimal string to its integer representation.\n    \n    This function processes each character in the input string from left to right,\n    converting valid hexadecimal digits (0-9, A-F, a-f) to their decimal values.\n    Invalid characters are treated as 0.\n    \n    Args:\n        hex_str: A string containing hexadecimal digits. Can include uppercase\n                 and lowercase letters A-F.\n    \n    Returns:\n        The integer value represented by the hexadecimal string.\n    \n    Examples:\n        >>> hex_string_to_int(\"1A\")\n        26\n        >>> hex_string_to_int(\"ff\")\n        255\n        >>> hex_string_to_int(\"0\")\n        0\n    \"\"\"\n    result = 0\n    str_length = len(hex_str)\n    \n    for position, char in enumerate(hex_str):\n        # Convert character to its decimal value\n        if '0' <= char <= '9':\n            digit_value = ord(char) - ord('0')\n        elif 'A' <= char <= 'F':\n            digit_value = ord(char) - ord('A') + 10\n        elif 'a' <= char <= 'f':\n            digit_value = ord(char) - ord('a') + 10\n        else:\n            digit_value = 0  # Invalid character\n        \n        # Calculate position weight (16^position_from_right)\n        position_from_right = str_length - position - 1\n        position_weight = 16 ** position_from_right\n        \n        # Add to total result\n        result += digit_value * position_weight\n    \n    return result"}
{"origin_topic": "计算一个句子中每个单词的长度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = []\n    t = \"\"\n    for c in s:\n        if c == \" \":\n            if t != \"\":\n                r.append(len(t))\n                t = \"\"\n        else:\n            t = t + c\n    if t != \"\":\n        r.append(len(t))\n    return r", "output": "from typing import List\n\n\ndef count_word_lengths(input_string: str) -> List[int]:\n    \"\"\"计算字符串中每个单词的长度。\n    \n    单词由空格分隔，连续的空格被视为单个分隔符。\n    返回包含每个单词长度的列表，按出现顺序排列。\n    \n    Args:\n        input_string: 要处理的输入字符串\n        \n    Returns:\n        包含每个单词长度的整数列表\n        \n    Examples:\n        >>> count_word_lengths(\"hello world\")\n        [5, 5]\n        >>> count_word_lengths(\"  multiple   spaces   here  \")\n        [8, 6, 4]\n        >>> count_word_lengths(\"\")\n        []\n    \"\"\"\n    word_lengths: List[int] = []\n    current_word: str = \"\"\n    \n    for character in input_string:\n        if character == \" \":\n            if current_word:\n                word_lengths.append(len(current_word))\n                current_word = \"\"\n        else:\n            current_word += character\n    \n    # 处理最后一个单词（如果存在）\n    if current_word:\n        word_lengths.append(len(current_word))\n    \n    return word_lengths"}
{"origin_topic": "根据字典的值进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(a):\n    b = list(a.items())\n    for x in range(len(b)):\n        for y in range(len(b) - 1):\n            if b[y][1] > b[y + 1][1]:\n                temp = b[y]\n                b[y] = b[y + 1]\n                b[y + 1] = temp\n    result = {}\n    for item in b:\n        result[item[0]] = item[1]\n    return result", "output": "from typing import Dict, Any\n\n\ndef sort_dict_by_value(input_dict: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"Sorts a dictionary by its values in ascending order.\n\n    This function implements bubble sort algorithm to sort dictionary items\n    based on their values. The original dictionary remains unchanged.\n\n    Args:\n        input_dict: The dictionary to be sorted. Values must be comparable.\n\n    Returns:\n        A new dictionary with the same key-value pairs as input_dict,\n        sorted by values in ascending order.\n\n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n\n    Raises:\n        TypeError: If dictionary values are not comparable.\n    \"\"\"\n    items = list(input_dict.items())\n    num_items = len(items)\n\n    # Bubble sort implementation\n    for outer_index in range(num_items):\n        for inner_index in range(num_items - 1):\n            if items[inner_index][1] > items[inner_index + 1][1]:\n                # Swap adjacent items\n                items[inner_index], items[inner_index + 1] = (\n                    items[inner_index + 1],\n                    items[inner_index],\n                )\n\n    # Reconstruct dictionary from sorted items\n    sorted_dict = {}\n    for key, value in items:\n        sorted_dict[key] = value\n\n    return sorted_dict"}
{"origin_topic": "找出一个数字的所有因数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def find_factors_of_number(input_number):\n    result_list = []\n    for current_value in range(1, input_number + 1):\n        if input_number % current_value == 0:\n            result_list.append(current_value)\n    return result_list", "output": "from typing import List\n\n\ndef find_factors(number: int) -> List[int]:\n    \"\"\"返回给定整数的所有正因数。\n\n    该函数通过遍历从1到给定数字的所有整数，找出所有能整除该数字的整数，\n    即该数字的所有正因数。\n\n    Args:\n        number: 需要查找因数的正整数。\n\n    Returns:\n        包含所有正因数的列表，按升序排列。\n\n    Raises:\n        ValueError: 如果输入的数字小于等于0。\n\n    Examples:\n        >>> find_factors(12)\n        [1, 2, 3, 4, 6, 12]\n        >>> find_factors(7)\n        [1, 7]\n    \"\"\"\n    if number <= 0:\n        raise ValueError(\"输入必须是正整数\")\n\n    factors: List[int] = []\n    for divisor in range(1, number + 1):\n        if number % divisor == 0:\n            factors.append(divisor)\n    \n    return factors"}
{"origin_topic": "统计字符串中元音字母的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_vowels_in_string(input_string):\n    vowels_list = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    total_count = 0\n    for character in input_string:\n        for vowel in vowels_list:\n            if character == vowel:\n                total_count = total_count + 1\n                break\n    return total_count", "output": "from typing import Union\n\n\ndef count_vowels(text: str) -> int:\n    \"\"\"Counts the number of vowels in a given string.\n\n    This function counts both lowercase and uppercase vowels (a, e, i, o, u).\n\n    Args:\n        text: The input string to analyze.\n\n    Returns:\n        The total number of vowels found in the input string.\n\n    Examples:\n        >>> count_vowels(\"Hello World\")\n        3\n        >>> count_vowels(\"Python\")\n        1\n        >>> count_vowels(\"\")\n        0\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    vowel_count = 0\n    \n    for character in text:\n        if character in vowels:\n            vowel_count += 1\n    \n    return vowel_count"}
{"origin_topic": "判断字符串是否为回文", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(s):\n    length_of_string = len(s)\n    if length_of_string == 0:\n        return True\n    else:\n        i = 0\n        j = length_of_string - 1\n        while i < j:\n            if s[i] != s[j]:\n                return False\n            i = i + 1\n            j = j - 1\n        return True", "output": "def is_palindrome(string: str) -> bool:\n    \"\"\"Checks if a string is a palindrome.\n\n    A palindrome is a string that reads the same forwards and backwards.\n    This function uses a two-pointer approach to compare characters from\n    both ends of the string, moving towards the center.\n\n    Args:\n        string: The input string to check.\n\n    Returns:\n        True if the string is a palindrome, False otherwise.\n\n    Examples:\n        >>> is_palindrome(\"racecar\")\n        True\n        >>> is_palindrome(\"hello\")\n        False\n        >>> is_palindrome(\"\")\n        True\n        >>> is_palindrome(\"a\")\n        True\n    \"\"\"\n    # Empty strings and single-character strings are palindromes by definition\n    if not string:\n        return True\n\n    left_index = 0\n    right_index = len(string) - 1\n\n    while left_index < right_index:\n        if string[left_index] != string[right_index]:\n            return False\n        left_index += 1\n        right_index -= 1\n\n    return True"}
{"origin_topic": "计算一个数字的二进制表示", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    if a == 0:\n        b = \"0\"\n    else:\n        x = a\n        while x > 0:\n            if x % 2 == 0:\n                b = \"0\" + b\n            else:\n                b = \"1\" + b\n            x = x // 2\n    return b", "output": "def decimal_to_binary_string(decimal_number: int) -> str:\n    \"\"\"Convert a non-negative integer to its binary string representation.\n    \n    Args:\n        decimal_number: A non-negative integer to convert to binary.\n        \n    Returns:\n        A string representing the binary equivalent of the input number.\n        \n    Examples:\n        >>> decimal_to_binary_string(0)\n        '0'\n        >>> decimal_to_binary_string(5)\n        '101'\n        >>> decimal_to_binary_string(10)\n        '1010'\n    \"\"\"\n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    remaining_value = decimal_number\n    \n    while remaining_value > 0:\n        if remaining_value % 2 == 0:\n            binary_digits.insert(0, \"0\")\n        else:\n            binary_digits.insert(0, \"1\")\n        remaining_value //= 2\n    \n    return \"\".join(binary_digits)"}
{"origin_topic": "将华氏温度转换为摄氏温度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a - 32\n    x = b * 5\n    y = x / 9\n    z = y + 0\n    return z", "output": "def fahrenheit_to_celsius(fahrenheit: float) -> float:\n    \"\"\"Convert temperature from Fahrenheit to Celsius.\n\n    Args:\n        fahrenheit: Temperature in degrees Fahrenheit.\n\n    Returns:\n        Temperature in degrees Celsius.\n\n    Formula:\n        Celsius = (Fahrenheit - 32) * 5 / 9\n    \"\"\"\n    celsius = (fahrenheit - 32) * 5 / 9\n    return celsius"}
{"origin_topic": "检查字符串是否包含数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string_for_numbers(a):\n    b = False\n    for x in a:\n        if x == '0' or x == '1' or x == '2' or x == '3' or x == '4' or x == '5' or x == '6' or x == '7' or x == '8' or x == '9':\n            b = True\n            break\n        else:\n            continue\n    if b == True:\n        return True\n    else:\n        return False", "output": "def contains_digit(text: str) -> bool:\n    \"\"\"检查字符串中是否包含至少一个数字字符。\n\n    Args:\n        text: 需要检查的输入字符串。\n\n    Returns:\n        True 如果字符串中包含至少一个数字字符 (0-9)，否则返回 False。\n\n    Examples:\n        >>> contains_digit(\"Hello123\")\n        True\n        >>> contains_digit(\"Hello World\")\n        False\n        >>> contains_digit(\"\")\n        False\n    \"\"\"\n    for character in text:\n        if character.isdigit():\n            return True\n    return False"}
{"origin_topic": "计算一个数的平方根（近似）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_square_root_approximation(a):\n    b = 0\n    while b * b <= a:\n        b = b + 0.0001\n    x = b - 0.0001\n    while x * x <= a:\n        x = x + 0.000001\n    y = x - 0.000001\n    while y * y <= a:\n        y = y + 0.0000001\n    z = y - 0.0000001\n    result = z\n    return result", "output": "\"\"\"Module for calculating square root approximations using iterative refinement.\"\"\"\n\nfrom typing import Union\n\n\ndef calculate_square_root_approximation(\n    number: Union[int, float]\n) -> float:\n    \"\"\"Calculate an approximation of the square root of a given number.\n    \n    This function uses an iterative refinement approach with decreasing step\n    sizes to approximate the square root. The algorithm starts with a coarse\n    approximation and progressively refines it with smaller step sizes.\n    \n    Args:\n        number: The number for which to calculate the square root approximation.\n            Must be non-negative.\n    \n    Returns:\n        A float approximation of the square root of the input number.\n    \n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Input must be non-negative. Received: {number}\")\n    \n    # Initial coarse approximation with step size 0.0001\n    coarse_step = 0.0001\n    coarse_approximation = 0.0\n    while coarse_approximation * coarse_approximation <= number:\n        coarse_approximation += coarse_step\n    \n    # First refinement with step size 0.000001\n    medium_step = 0.000001\n    medium_approximation = coarse_approximation - coarse_step\n    while medium_approximation * medium_approximation <= number:\n        medium_approximation += medium_step\n    \n    # Final refinement with step size 0.0000001\n    fine_step = 0.0000001\n    fine_approximation = medium_approximation - medium_step\n    while fine_approximation * fine_approximation <= number:\n        fine_approximation += fine_step\n    \n    # Return the final approximation (stepping back one fine step)\n    return fine_approximation - fine_step"}
{"origin_topic": "验证电子邮件地址的简单格式（包含@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    x = 0\n    y = 0\n    for z in a:\n        if z == '@':\n            x = x + 1\n        if z == '.':\n            y = y + 1\n    if x > 0:\n        if y > 0:\n            b = True\n    return b", "output": "from typing import List\n\n\ndef contains_at_and_dot(characters: List[str]) -> bool:\n    \"\"\"检查字符列表中是否同时包含'@'和'.'字符。\n\n    该函数遍历字符列表，统计'@'和'.'的出现次数。如果两者都至少出现一次，\n    则返回True，否则返回False。\n\n    Args:\n        characters: 要检查的字符串字符列表。\n\n    Returns:\n        True: 如果列表中同时包含至少一个'@'和至少一个'.'。\n        False: 如果列表中缺少'@'或'.'中的任意一个。\n\n    Examples:\n        >>> contains_at_and_dot(['a', '@', 'b', '.', 'c'])\n        True\n        >>> contains_at_and_dot(['@', '@', '@'])\n        False\n        >>> contains_at_and_dot(['.', '.', '.'])\n        False\n        >>> contains_at_and_dot(['a', 'b', 'c'])\n        False\n    \"\"\"\n    at_count = 0\n    dot_count = 0\n    \n    for char in characters:\n        if char == '@':\n            at_count += 1\n        elif char == '.':\n            dot_count += 1\n    \n    return at_count > 0 and dot_count > 0"}
{"origin_topic": "计算一个数的二进制表示中1的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_ones_in_binary_representation_of_a_number(num):\n    if num < 0:\n        num = abs(num)\n    binary_string = bin(num)\n    length_of_binary_string = len(binary_string)\n    counter_variable_for_counting_ones = 0\n    for character_index in range(length_of_binary_string):\n        current_character = binary_string[character_index]\n        if current_character == '1':\n            counter_variable_for_counting_ones = counter_variable_for_counting_ones + 1\n    return counter_variable_for_counting_ones", "output": "def count_set_bits(num: int) -> int:\n    \"\"\"Count the number of 1 bits in the binary representation of an integer.\n    \n    Args:\n        num: An integer whose binary representation will be analyzed.\n    \n    Returns:\n        The number of 1 bits (set bits) in the binary representation.\n    \n    Examples:\n        >>> count_set_bits(5)  # binary: 101\n        2\n        >>> count_set_bits(0)  # binary: 0\n        0\n        >>> count_set_bits(-3)  # uses absolute value, binary: 11\n        2\n    \"\"\"\n    # Use absolute value for negative numbers\n    num = abs(num)\n    \n    # Convert to binary string and count '1' characters\n    binary_str = bin(num)\n    return binary_str.count('1')"}
{"origin_topic": "将一个字符串中的空格替换为下划线", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y == \" \":\n            x = x + \"_\"\n        else:\n            x = x + y\n    return x", "output": "def replace_spaces_with_underscores(input_string: str) -> str:\n    \"\"\"Replaces all space characters in a string with underscores.\n    \n    Args:\n        input_string: The original string containing spaces.\n        \n    Returns:\n        A new string where all spaces have been replaced with underscores.\n        \n    Examples:\n        >>> replace_spaces_with_underscores(\"hello world\")\n        'hello_world'\n        >>> replace_spaces_with_underscores(\"multiple   spaces\")\n        'multiple___spaces'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character == \" \":\n            result += \"_\"\n        else:\n            result += character\n    return result"}
{"origin_topic": "将字典的键和值互换", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = {}\n    for x in a:\n        v = a[x]\n        b[v] = x\n    return b", "output": "from typing import Dict, TypeVar\n\nKeyType = TypeVar('KeyType')\nValueType = TypeVar('ValueType')\n\n\ndef invert_dictionary(original_dict: Dict[KeyType, ValueType]) -> Dict[ValueType, KeyType]:\n    \"\"\"Inverts a dictionary by swapping keys and values.\n    \n    This function creates a new dictionary where the original values become keys,\n    and the original keys become values. Note that duplicate values in the\n    original dictionary will be overwritten in the inverted result.\n    \n    Args:\n        original_dict: The dictionary to invert. Keys and values must be hashable.\n        \n    Returns:\n        A new dictionary with inverted key-value pairs.\n        \n    Raises:\n        TypeError: If dictionary values are not hashable.\n        \n    Example:\n        >>> invert_dictionary({'a': 1, 'b': 2})\n        {1: 'a', 2: 'b'}\n    \"\"\"\n    inverted_dict: Dict[ValueType, KeyType] = {}\n    \n    for key, value in original_dict.items():\n        inverted_dict[value] = key\n    \n    return inverted_dict"}
{"origin_topic": "统计一个数字中各位数的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_sum_of_digits(input_number):\n    total_sum = 0\n    number_as_string = str(input_number)\n    for character in number_as_string:\n        if character.isdigit():\n            digit_value = int(character)\n            total_sum = total_sum + digit_value\n        else:\n            continue\n    return total_sum", "output": "def calculate_sum_of_digits(number: int | str) -> int:\n    \"\"\"Calculate the sum of all digits in the given number.\n\n    This function accepts either an integer or a string representation of a number\n    and returns the sum of its individual digits. Non-digit characters in string\n    inputs are ignored.\n\n    Args:\n        number: An integer or string containing digits to sum.\n\n    Returns:\n        The sum of all digits in the input number.\n\n    Examples:\n        >>> calculate_sum_of_digits(123)\n        6\n        >>> calculate_sum_of_digits(\"45a6b\")\n        15\n\n    Raises:\n        TypeError: If the input is neither an integer nor a string.\n    \"\"\"\n    if not isinstance(number, (int, str)):\n        raise TypeError(f\"Expected int or str, got {type(number).__name__}\")\n\n    digit_sum = 0\n    number_str = str(number)\n    \n    for char in number_str:\n        if char.isdigit():\n            digit_value = int(char)\n            digit_sum += digit_value\n    \n    return digit_sum"}
{"origin_topic": "计算一个数的绝对值（不使用abs函数）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_absolute_value_of_a_number(x):\n    if x > 0:\n        result = x\n    elif x < 0:\n        result = -x\n    else:\n        result = 0\n    return result", "output": "def calculate_absolute_value(number: float) -> float:\n    \"\"\"Calculate the absolute value of a given number.\n    \n    The absolute value of a number is its non-negative value without regard to its sign.\n    For positive numbers and zero, the absolute value is the number itself.\n    For negative numbers, the absolute value is the positive counterpart.\n    \n    Args:\n        number: The input number for which to calculate the absolute value.\n    \n    Returns:\n        The absolute value of the input number.\n    \n    Examples:\n        >>> calculate_absolute_value(5)\n        5.0\n        >>> calculate_absolute_value(-3.14)\n        3.14\n        >>> calculate_absolute_value(0)\n        0.0\n    \"\"\"\n    if number > 0:\n        absolute_value = number\n    elif number < 0:\n        absolute_value = -number\n    else:\n        absolute_value = 0.0\n    \n    return absolute_value"}
{"origin_topic": "计算一个数的平方根（使用牛顿法近似）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a / 2\n    while True:\n        x = (b + a / b) / 2\n        if abs(x - b) < 0.000001:\n            return x\n        b = x", "output": "def calculate_square_root(number: float) -> float:\n    \"\"\"Calculate the square root of a non-negative number using Newton's method.\n    \n    Args:\n        number: The non-negative number for which to calculate the square root.\n        \n    Returns:\n        The square root of the input number.\n        \n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot calculate square root of negative number\")\n    \n    if number == 0:\n        return 0.0\n    \n    # Initial guess for the square root\n    current_estimate = number / 2\n    tolerance = 1e-6\n    \n    while True:\n        # Newton's method iteration: x_{n+1} = (x_n + a/x_n) / 2\n        next_estimate = (current_estimate + number / current_estimate) / 2\n        \n        # Check if we've reached the desired precision\n        if abs(next_estimate - current_estimate) < tolerance:\n            return next_estimate\n        \n        current_estimate = next_estimate"}
{"origin_topic": "将一个字符串中的所有字母转换为小写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = d\n        if e >= 'A' and e <= 'Z':\n            f = ord(e)\n            g = f + 32\n            h = chr(g)\n            c = c + h\n        else:\n            c = c + e\n    return c", "output": "def to_lowercase(input_string: str) -> str:\n    \"\"\"Convert all uppercase characters in a string to lowercase.\n    \n    This function iterates through each character in the input string and converts\n    any uppercase letters (A-Z) to their lowercase equivalents using ASCII\n    arithmetic. Non-uppercase characters remain unchanged.\n    \n    Args:\n        input_string: The string to be processed. Can contain any characters.\n        \n    Returns:\n        A new string with all uppercase letters converted to lowercase.\n        \n    Examples:\n        >>> to_lowercase(\"Hello WORLD!\")\n        'hello world!'\n        >>> to_lowercase(\"123 ABC xyz\")\n        '123 abc xyz'\n    \"\"\"\n    result = \"\"\n    \n    for character in input_string:\n        if 'A' <= character <= 'Z':\n            # Convert uppercase to lowercase using ASCII values\n            uppercase_code = ord(character)\n            lowercase_code = uppercase_code + 32  # ASCII difference between cases\n            lowercase_char = chr(lowercase_code)\n            result += lowercase_char\n        else:\n            result += character\n    \n    return result"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件地址（简单规则：包含@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email(a):\n    b = False\n    x = 0\n    y = 0\n    for z in a:\n        if z == '@':\n            x = x + 1\n        if z == '.':\n            y = y + 1\n    if x > 0:\n        if y > 0:\n            b = True\n    return b", "output": "def is_valid_email(email: str) -> bool:\n    \"\"\"检查字符串是否符合基本的电子邮件格式要求。\n    \n    基本验证规则：\n    1. 必须包含且仅包含一个 '@' 符号\n    2. 必须至少包含一个 '.' 符号\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果符合基本格式要求返回True，否则返回False\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid-email\")\n        False\n        >>> is_valid_email(\"user@com\")\n        False\n    \"\"\"\n    at_symbol_count = 0\n    dot_symbol_count = 0\n    \n    for character in email:\n        if character == '@':\n            at_symbol_count += 1\n        elif character == '.':\n            dot_symbol_count += 1\n    \n    # 必须恰好有一个 '@' 符号且至少有一个 '.' 符号\n    return at_symbol_count == 1 and dot_symbol_count > 0"}
{"origin_topic": "检查用户名是否符合规则", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if len(b) >= 3:\n        if len(b) <= 20:\n            if b[0].isalpha():\n                y = True\n                for z in b:\n                    if not (z.isalnum() or z == '_'):\n                        y = False\n                if y:\n                    x = True\n    return x", "output": "def is_valid_identifier(identifier: str) -> bool:\n    \"\"\"Validates if a string is a valid identifier according to specific rules.\n\n    The identifier must satisfy all of the following conditions:\n    1. Length between 3 and 20 characters (inclusive)\n    2. First character must be alphabetic\n    3. All characters must be alphanumeric or underscore\n\n    Args:\n        identifier: The string to validate as an identifier.\n\n    Returns:\n        True if the identifier meets all validation criteria, False otherwise.\n\n    Examples:\n        >>> is_valid_identifier(\"valid_name_123\")\n        True\n        >>> is_valid_identifier(\"1invalid\")\n        False\n        >>> is_valid_identifier(\"ab\")\n        False\n        >>> is_valid_identifier(\"too_long_identifier_12345\")\n        False\n        >>> is_valid_identifier(\"valid-but-with-dash\")\n        False\n    \"\"\"\n    # Validate length constraints\n    if len(identifier) < 3 or len(identifier) > 20:\n        return False\n\n    # Validate first character is alphabetic\n    if not identifier[0].isalpha():\n        return False\n\n    # Validate all characters are alphanumeric or underscore\n    for char in identifier:\n        if not (char.isalnum() or char == '_'):\n            return False\n\n    return True"}
{"origin_topic": "将字符串全部转换为小写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = ord(d)\n        if e >= 65 and e <= 90:\n            f = e + 32\n            g = chr(f)\n            c = c + g\n        else:\n            c = c + d\n    return c", "output": "def convert_to_lowercase(text: str) -> str:\n    \"\"\"Convert uppercase letters in a string to lowercase.\n    \n    This function iterates through each character in the input string and converts\n    any uppercase ASCII letters (A-Z) to their lowercase equivalents. All other\n    characters remain unchanged.\n    \n    Args:\n        text: The input string to process.\n    \n    Returns:\n        A new string with all uppercase ASCII letters converted to lowercase.\n    \n    Example:\n        >>> convert_to_lowercase(\"Hello World! 123\")\n        'hello world! 123'\n    \"\"\"\n    result = \"\"\n    \n    for character in text:\n        char_code = ord(character)\n        \n        # Check if character is uppercase ASCII (A-Z)\n        if 65 <= char_code <= 90:\n            lowercase_code = char_code + 32  # ASCII offset for lowercase\n            lowercase_char = chr(lowercase_code)\n            result += lowercase_char\n        else:\n            result += character\n    \n    return result"}
{"origin_topic": "将字符串中的数字相加", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    x = 0\n    while x < len(a):\n        if a[x].isdigit():\n            y = ''\n            while x < len(a) and a[x].isdigit():\n                y = y + a[x]\n                x = x + 1\n            b = b + int(y)\n        else:\n            x = x + 1\n    return b", "output": "from typing import List, Union\n\n\ndef sum_digits_in_string(input_string: str) -> int:\n    \"\"\"计算字符串中所有连续数字组成的整数的总和。\n\n    该函数遍历输入字符串，识别连续的数值字符序列，将每个序列转换为整数，\n    并返回所有整数的总和。非数字字符将被跳过。\n\n    示例:\n        >>> sum_digits_in_string(\"abc123def45gh6\")\n        174  # 123 + 45 + 6 = 174\n        >>> sum_digits_in_string(\"no digits here\")\n        0\n\n    参数:\n        input_string: 待处理的输入字符串。\n\n    返回:\n        字符串中所有连续数字序列的整数总和。\n    \"\"\"\n    total_sum: int = 0\n    current_index: int = 0\n    string_length: int = len(input_string)\n\n    while current_index < string_length:\n        if input_string[current_index].isdigit():\n            # 提取连续的数字字符序列\n            digit_sequence: str = ''\n            while (current_index < string_length and\n                   input_string[current_index].isdigit()):\n                digit_sequence += input_string[current_index]\n                current_index += 1\n            \n            # 将数字序列转换为整数并累加\n            total_sum += int(digit_sequence)\n        else:\n            # 跳过非数字字符\n            current_index += 1\n\n    return total_sum"}
{"origin_topic": "获取字典中所有值的列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def get_all_values_from_dictionary(x):\n    result_list = []\n    for key in x:\n        current_value = x[key]\n        result_list.append(current_value)\n    return result_list", "output": "from typing import Dict, Any, List\n\n\ndef extract_all_values(dictionary: Dict[Any, Any]) -> List[Any]:\n    \"\"\"Extracts all values from a dictionary and returns them as a list.\n\n    This function iterates through all key-value pairs in the input dictionary\n    and collects the values into a list. The order of values in the returned\n    list corresponds to the iteration order of the dictionary.\n\n    Args:\n        dictionary: The input dictionary from which to extract values.\n\n    Returns:\n        A list containing all values from the input dictionary.\n\n    Example:\n        >>> extract_all_values({'a': 1, 'b': 2, 'c': 3})\n        [1, 2, 3]\n        >>> extract_all_values({})\n        []\n    \"\"\"\n    return list(dictionary.values())"}
{"origin_topic": "将多个字典合并为一个字典", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def merge_dicts(a, b, x):\n    result = {}\n    for key in a:\n        result[key] = a[key]\n    for key in b:\n        result[key] = b[key]\n    for key in x:\n        result[key] = x[key]\n    return result", "output": "from typing import Dict, TypeVar, Union\n\n# Type variable for dictionary values\nT = TypeVar('T')\n\n\ndef merge_dictionaries(\n    primary: Dict[str, T],\n    secondary: Dict[str, T],\n    tertiary: Dict[str, T]\n) -> Dict[str, T]:\n    \"\"\"Merges three dictionaries into a single dictionary.\n    \n    If duplicate keys exist across input dictionaries, the value from the \n    later dictionary in the parameter order takes precedence (tertiary > \n    secondary > primary).\n    \n    Args:\n        primary: The first dictionary to merge. Has lowest priority for \n            duplicate keys.\n        secondary: The second dictionary to merge. Has medium priority for \n            duplicate keys.\n        tertiary: The third dictionary to merge. Has highest priority for \n            duplicate keys.\n    \n    Returns:\n        A new dictionary containing all key-value pairs from the input \n        dictionaries, with conflicts resolved by parameter order precedence.\n    \n    Example:\n        >>> merge_dictionaries({'a': 1}, {'b': 2}, {'a': 3, 'c': 4})\n        {'a': 3, 'b': 2, 'c': 4}\n    \"\"\"\n    merged_dict: Dict[str, T] = {}\n    \n    # Merge in order of increasing priority\n    merged_dict.update(primary)\n    merged_dict.update(secondary)\n    merged_dict.update(tertiary)\n    \n    return merged_dict"}
{"origin_topic": "检查两个字符串是否为变位词（字母相同，顺序不同）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_anagram(a, b):\n    if len(a) != len(b):\n        return False\n    else:\n        list_a = []\n        list_b = []\n        for char in a:\n            list_a.append(char)\n        for char in b:\n            list_b.append(char)\n        sorted_a = sorted(list_a)\n        sorted_b = sorted(list_b)\n        for i in range(len(sorted_a)):\n            if sorted_a[i] != sorted_b[i]:\n                return False\n        return True", "output": "from collections import Counter\nfrom typing import Union\n\n\ndef is_anagram(string_a: str, string_b: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\n\n    An anagram is a word or phrase formed by rearranging the letters of\n    a different word or phrase, using all the original letters exactly once.\n\n    Args:\n        string_a: First string to compare.\n        string_b: Second string to compare.\n\n    Returns:\n        True if the strings are anagrams, False otherwise.\n\n    Examples:\n        >>> is_anagram(\"listen\", \"silent\")\n        True\n        >>> is_anagram(\"hello\", \"world\")\n        False\n        >>> is_anagram(\"rail safety\", \"fairy tales\")\n        True\n    \"\"\"\n    # Early exit if lengths differ (performance optimization)\n    if len(string_a) != len(string_b):\n        return False\n\n    # Compare character frequency using Counter for O(n) complexity\n    return Counter(string_a) == Counter(string_b)\n\n\n# Alternative implementation using sorted strings (O(n log n) complexity)\ndef is_anagram_sorted(string_a: str, string_b: str) -> bool:\n    \"\"\"Check if two strings are anagrams using sorting approach.\n\n    This implementation uses sorting which has O(n log n) time complexity\n    but may be more memory efficient for very large strings.\n\n    Args:\n        string_a: First string to compare.\n        string_b: Second string to compare.\n\n    Returns:\n        True if the strings are anagrams, False otherwise.\n    \"\"\"\n    return sorted(string_a) == sorted(string_b)"}
{"origin_topic": "编写函数计算两个数字的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_sum_of_two_numbers(a, b):\n    x = 0\n    x = a + b\n    result = x\n    return result", "output": "def calculate_sum_of_two_numbers(a: float, b: float) -> float:\n    \"\"\"Calculates the sum of two numbers.\n\n    Args:\n        a: The first number to add.\n        b: The second number to add.\n\n    Returns:\n        The sum of a and b.\n\n    Examples:\n        >>> calculate_sum_of_two_numbers(3, 4)\n        7.0\n        >>> calculate_sum_of_two_numbers(-1.5, 2.5)\n        1.0\n    \"\"\"\n    return a + b"}
{"origin_topic": "将字符串按字母顺序重新排列", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    for i in b:\n        x.append(i)\n    y = []\n    for j in x:\n        y.append(j)\n    z = []\n    for k in y:\n        z.append(k)\n    m = []\n    for n in z:\n        m.append(n)\n    o = []\n    for p in m:\n        o.append(p)\n    q = []\n    for r in o:\n        q.append(r)\n    s = []\n    for t in q:\n        s.append(t)\n    u = []\n    for v in s:\n        u.append(v)\n    w = []\n    for aa in u:\n        w.append(aa)\n    w.sort()\n    bb = \"\"\n    for cc in w:\n        bb = bb + cc\n    return bb", "output": "from typing import List, Iterable\n\n\ndef concatenate_sorted_strings(strings: Iterable[str]) -> str:\n    \"\"\"Concatenates an iterable of strings into a single sorted string.\n    \n    This function takes an iterable of strings, flattens it through multiple\n    intermediate lists (preserving original order at each step), sorts the\n    final collection, and concatenates all strings into a single result.\n    \n    Note: The multiple intermediate list copies are preserved from the original\n    implementation for behavioral compatibility, though in practice a direct\n    approach would be more efficient.\n    \n    Args:\n        strings: An iterable of strings to process.\n        \n    Returns:\n        A single string containing all input strings concatenated in sorted order.\n        \n    Example:\n        >>> concatenate_sorted_strings(['c', 'a', 'b'])\n        'abc'\n    \"\"\"\n    # First level copy\n    first_copy: List[str] = []\n    for string in strings:\n        first_copy.append(string)\n    \n    # Second level copy\n    second_copy: List[str] = []\n    for string in first_copy:\n        second_copy.append(string)\n    \n    # Third level copy\n    third_copy: List[str] = []\n    for string in second_copy:\n        third_copy.append(string)\n    \n    # Fourth level copy\n    fourth_copy: List[str] = []\n    for string in third_copy:\n        fourth_copy.append(string)\n    \n    # Fifth level copy\n    fifth_copy: List[str] = []\n    for string in fourth_copy:\n        fifth_copy.append(string)\n    \n    # Sixth level copy\n    sixth_copy: List[str] = []\n    for string in fifth_copy:\n        sixth_copy.append(string)\n    \n    # Seventh level copy\n    seventh_copy: List[str] = []\n    for string in sixth_copy:\n        seventh_copy.append(string)\n    \n    # Eighth level copy\n    eighth_copy: List[str] = []\n    for string in seventh_copy:\n        eighth_copy.append(string)\n    \n    # Ninth level copy\n    ninth_copy: List[str] = []\n    for string in eighth_copy:\n        ninth_copy.append(string)\n    \n    # Sort the final copy\n    ninth_copy.sort()\n    \n    # Concatenate all strings\n    result: str = \"\"\n    for string in ninth_copy:\n        result += string\n    \n    return result\n\n\n# Alternative optimized version (commented out as per requirements to preserve original behavior)\n# def concatenate_sorted_strings_optimized(strings: Iterable[str]) -> str:\n#     \"\"\"Optimized version that directly sorts and concatenates strings.\n#     \n#     Args:\n#         strings: An iterable of strings to process.\n#         \n#     Returns:\n#         A single string containing all input strings concatenated in sorted order.\n#     \"\"\"\n#     sorted_strings = sorted(strings)\n#     return ''.join(sorted_strings)"}
{"origin_topic": "将罗马数字字符串转换为整数（仅支持I, V, X, L, C, D, M）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    d = {}\n    d['I'] = 1\n    d['V'] = 5\n    d['X'] = 10\n    d['L'] = 50\n    d['C'] = 100\n    d['D'] = 500\n    d['M'] = 1000\n    t = 0\n    i = 0\n    n = len(s)\n    while i < n:\n        c1 = s[i]\n        v1 = d[c1]\n        if i + 1 < n:\n            c2 = s[i + 1]\n            v2 = d[c2]\n            if v1 < v2:\n                t = t + (v2 - v1)\n                i = i + 2\n            else:\n                t = t + v1\n                i = i + 1\n        else:\n            t = t + v1\n            i = i + 1\n    return t", "output": "def roman_to_int(roman_numeral: str) -> int:\n    \"\"\"Convert a Roman numeral string to its integer value.\n    \n    Args:\n        roman_numeral: A string representing a valid Roman numeral.\n            Valid characters are: I, V, X, L, C, D, M.\n    \n    Returns:\n        The integer value of the Roman numeral.\n    \n    Examples:\n        >>> roman_to_int('III')\n        3\n        >>> roman_to_int('IV')\n        4\n        >>> roman_to_int('MCMXCIV')\n        1994\n    \n    Raises:\n        KeyError: If the input contains invalid Roman numeral characters.\n    \"\"\"\n    roman_to_value = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n    \n    total = 0\n    index = 0\n    length = len(roman_numeral)\n    \n    while index < length:\n        current_char = roman_numeral[index]\n        current_value = roman_to_value[current_char]\n        \n        # Check if there's a next character for subtraction cases\n        if index + 1 < length:\n            next_char = roman_numeral[index + 1]\n            next_value = roman_to_value[next_char]\n            \n            # Handle subtraction notation (e.g., IV = 4, IX = 9)\n            if current_value < next_value:\n                total += (next_value - current_value)\n                index += 2  # Skip both characters\n            else:\n                total += current_value\n                index += 1\n        else:\n            total += current_value\n            index += 1\n    \n    return total"}
{"origin_topic": "检查两个字符串是否为变位词（字母相同但顺序不同）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_anagram(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    else:\n        list1 = []\n        list2 = []\n        for char in s1:\n            list1.append(char)\n        for char in s2:\n            list2.append(char)\n        list1.sort()\n        list2.sort()\n        for i in range(len(list1)):\n            if list1[i] != list2[i]:\n                return False\n        return True", "output": "from collections import Counter\nfrom typing import Union\n\n\ndef is_anagram(string1: str, string2: str) -> bool:\n    \"\"\"Check if two strings are anagrams of each other.\n    \n    An anagram is a word or phrase formed by rearranging the letters of\n    a different word or phrase, using all the original letters exactly once.\n    \n    Args:\n        string1: First string to compare.\n        string2: Second string to compare.\n    \n    Returns:\n        True if the strings are anagrams, False otherwise.\n    \n    Examples:\n        >>> is_anagram(\"listen\", \"silent\")\n        True\n        >>> is_anagram(\"hello\", \"world\")\n        False\n        >>> is_anagram(\"\", \"\")\n        True\n    \"\"\"\n    # Early return for length mismatch\n    if len(string1) != len(string2):\n        return False\n    \n    # Compare character frequency using Counter\n    return Counter(string1) == Counter(string2)\n\n\n# Alternative implementation using sorted strings\ndef is_anagram_sorted(string1: str, string2: str) -> bool:\n    \"\"\"Check if two strings are anagrams by sorting characters.\n    \n    This implementation uses string sorting which may be more memory\n    efficient for very large strings but has O(n log n) time complexity.\n    \n    Args:\n        string1: First string to compare.\n        string2: Second string to compare.\n    \n    Returns:\n        True if the strings are anagrams, False otherwise.\n    \"\"\"\n    # Early return for length mismatch\n    if len(string1) != len(string2):\n        return False\n    \n    # Compare sorted character sequences\n    return sorted(string1) == sorted(string2)"}
{"origin_topic": "将两个字符串按字母顺序合并", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a, b):\n    c = []\n    i = 0\n    j = 0\n    while i < len(a) and j < len(b):\n        if a[i] < b[j]:\n            c.append(a[i])\n            i = i + 1\n        else:\n            c.append(b[j])\n            j = j + 1\n    while i < len(a):\n        c.append(a[i])\n        i = i + 1\n    while j < len(b):\n        c.append(b[j])\n        j = j + 1\n    d = \"\"\n    for x in c:\n        d = d + x\n    return d", "output": "from typing import List, Optional\n\n\ndef merge_sorted_strings(\n    str_list_a: List[str], \n    str_list_b: List[str]\n) -> str:\n    \"\"\"Merges two sorted lists of strings into a single sorted string.\n    \n    This function implements the merge step of the merge sort algorithm,\n    combining two pre-sorted lists of strings into one sorted concatenated string.\n    \n    Args:\n        str_list_a: First sorted list of strings to merge.\n        str_list_b: Second sorted list of strings to merge.\n    \n    Returns:\n        A single string containing all elements from both input lists,\n        sorted in ascending order.\n    \n    Example:\n        >>> merge_sorted_strings(['a', 'c'], ['b', 'd'])\n        'abcd'\n        >>> merge_sorted_strings(['apple', 'banana'], ['apricot', 'avocado'])\n        'appleapricotavocadobanana'\n    \n    Note:\n        Both input lists must be sorted in ascending order for correct results.\n        The function assumes string comparison follows lexicographical order.\n    \"\"\"\n    merged_list: List[str] = []\n    index_a: int = 0\n    index_b: int = 0\n    \n    # Merge while both lists have remaining elements\n    while index_a < len(str_list_a) and index_b < len(str_list_b):\n        if str_list_a[index_a] < str_list_b[index_b]:\n            merged_list.append(str_list_a[index_a])\n            index_a += 1\n        else:\n            merged_list.append(str_list_b[index_b])\n            index_b += 1\n    \n    # Append remaining elements from first list, if any\n    while index_a < len(str_list_a):\n        merged_list.append(str_list_a[index_a])\n        index_a += 1\n    \n    # Append remaining elements from second list, if any\n    while index_b < len(str_list_b):\n        merged_list.append(str_list_b[index_b])\n        index_b += 1\n    \n    # Concatenate all strings in the merged list\n    result_string: str = \"\".join(merged_list)\n    \n    return result_string"}
{"origin_topic": "计算字符串中单词的平均长度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(s):\n    b = 0\n    x = 0\n    y = 0\n    z = 0\n    if len(s) == 0:\n        return 0\n    while y < len(s):\n        if s[y] != ' ':\n            z = z + 1\n            if y == len(s) - 1:\n                b = b + 1\n                x = x + z\n        else:\n            if z > 0:\n                b = b + 1\n                x = x + z\n                z = 0\n        y = y + 1\n    if b == 0:\n        return 0\n    else:\n        return x / b", "output": "from typing import Optional\n\ndef calculate_average_word_length(text: str) -> Optional[float]:\n    \"\"\"计算字符串中单词的平均长度。\n    \n    单词由非空格字符序列定义，由空格分隔。忽略前导、尾随和连续空格。\n    \n    Args:\n        text: 要分析的输入字符串。\n        \n    Returns:\n        单词的平均长度，如果字符串为空或不包含单词则返回0.0。\n        \n    Examples:\n        >>> calculate_average_word_length(\"hello world\")\n        5.0\n        >>> calculate_average_word_length(\"  Python  is   great!  \")\n        5.0\n        >>> calculate_average_word_length(\"\")\n        0.0\n        >>> calculate_average_word_length(\"   \")\n        0.0\n    \"\"\"\n    if not text:\n        return 0.0\n    \n    total_characters = 0\n    word_count = 0\n    current_word_length = 0\n    \n    for index, character in enumerate(text):\n        if character != ' ':\n            current_word_length += 1\n            # 处理字符串末尾的单词\n            if index == len(text) - 1:\n                word_count += 1\n                total_characters += current_word_length\n        else:\n            if current_word_length > 0:\n                word_count += 1\n                total_characters += current_word_length\n                current_word_length = 0\n    \n    if word_count == 0:\n        return 0.0\n    \n    return total_characters / word_count"}
{"origin_topic": "合并两个字典", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a, b):\n    c = {}\n    for d in a:\n        e = a[d]\n        c[d] = e\n    for g in b:\n        h = b[g]\n        c[g] = h\n    return c", "output": "from typing import Dict, TypeVar\n\nK = TypeVar('K')\nV = TypeVar('V')\n\ndef merge_dicts(\n    dict1: Dict[K, V],\n    dict2: Dict[K, V],\n) -> Dict[K, V]:\n    \"\"\"Merges two dictionaries into a new dictionary.\n\n    If both dictionaries contain the same key, the value from dict2 will\n    overwrite the value from dict1 in the resulting dictionary.\n\n    Args:\n        dict1: The first dictionary to merge.\n        dict2: The second dictionary to merge.\n\n    Returns:\n        A new dictionary containing all key-value pairs from both input\n        dictionaries, with dict2 values taking precedence for duplicate keys.\n\n    Examples:\n        >>> merge_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n        {'a': 1, 'b': 3, 'c': 4}\n    \"\"\"\n    result = dict1.copy()\n    result.update(dict2)\n    return result"}
{"origin_topic": "检查两个字符串是否为变位词（字母相同顺序不同）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a, b):\n    if len(a) != len(b):\n        return False\n    d1 = {}\n    d2 = {}\n    for i in range(len(a)):\n        c1 = a[i]\n        c2 = b[i]\n        if c1 in d1:\n            d1[c1] = d1[c1] + 1\n        else:\n            d1[c1] = 1\n        if c2 in d2:\n            d2[c2] = d2[c2] + 1\n        else:\n            d2[c2] = 1\n    for k in d1:\n        if k not in d2:\n            return False\n        if d1[k] != d2[k]:\n            return False\n    for k in d2:\n        if k not in d1:\n            return False\n    return True", "output": "from typing import Any, Dict\n\n\ndef are_frequency_dicts_equal(sequence_a: Any, sequence_b: Any) -> bool:\n    \"\"\"Check if two sequences have identical element frequency distributions.\n\n    This function compares two sequences by counting the frequency of each\n    element in both sequences and verifying that the frequency distributions\n    are identical. The sequences can contain any hashable elements.\n\n    Args:\n        sequence_a: First sequence to compare. Must support len() and indexing.\n        sequence_b: Second sequence to compare. Must support len() and indexing.\n\n    Returns:\n        True if both sequences have the same length and identical frequency\n        distributions for all elements, False otherwise.\n\n    Examples:\n        >>> are_frequency_dicts_equal([1, 2, 1], [2, 1, 1])\n        True\n        >>> are_frequency_dicts_equal('abc', 'cba')\n        True\n        >>> are_frequency_dicts_equal([1, 2, 3], [1, 2])\n        False\n        >>> are_frequency_dicts_equal([1, 2, 2], [1, 1, 2])\n        False\n    \"\"\"\n    if len(sequence_a) != len(sequence_b):\n        return False\n\n    frequency_a: Dict[Any, int] = {}\n    frequency_b: Dict[Any, int] = {}\n\n    for element_a, element_b in zip(sequence_a, sequence_b):\n        frequency_a[element_a] = frequency_a.get(element_a, 0) + 1\n        frequency_b[element_b] = frequency_b.get(element_b, 0) + 1\n\n    # Check if frequency distributions are identical\n    if frequency_a != frequency_b:\n        return False\n\n    return True"}
{"origin_topic": "计算阶乘", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(x):\n    if x == 0:\n        b = 1\n        return b\n    else:\n        c = 1\n        for d in range(1, x + 1):\n            e = c\n            f = d\n            g = e * f\n            c = g\n        return c", "output": "def factorial(n: int) -> int:\n    \"\"\"Calculate the factorial of a non-negative integer.\n    \n    Factorial is defined as the product of all positive integers from 1 to n.\n    By definition, factorial(0) = 1.\n    \n    Args:\n        n: A non-negative integer for which to calculate the factorial.\n        \n    Returns:\n        The factorial of n.\n        \n    Raises:\n        ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    \n    if n == 0:\n        return 1\n    \n    result = 1\n    for current_number in range(1, n + 1):\n        result *= current_number\n    \n    return result"}
{"origin_topic": "将给定的秒数转换为天、小时、分钟和秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a // 86400\n    x = a % 86400\n    c = x // 3600\n    d = x % 3600\n    e = d // 60\n    g = d % 60\n    h = b\n    i = c\n    j = e\n    k = g\n    l = h\n    m = i\n    n = j\n    o = k\n    p = l\n    q = m\n    r = n\n    s = o\n    t = p\n    u = q\n    v = r\n    w = s\n    return t, u, v, w", "output": "from typing import Tuple\n\n\ndef convert_seconds_to_dhms(total_seconds: int) -> Tuple[int, int, int, int]:\n    \"\"\"将总秒数转换为天、小时、分钟和秒的元组。\n\n    该函数将给定的总秒数分解为天、小时、分钟和秒的整数部分，\n    其中：\n    - 1天 = 86400秒\n    - 1小时 = 3600秒\n    - 1分钟 = 60秒\n\n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）。\n\n    Returns:\n        一个包含四个整数的元组，分别表示：\n        (days, hours, minutes, seconds)\n\n    Examples:\n        >>> convert_seconds_to_dhms(90061)\n        (1, 1, 1, 1)\n        >>> convert_seconds_to_dhms(86400)\n        (1, 0, 0, 0)\n        >>> convert_seconds_to_dhms(3661)\n        (0, 1, 1, 1)\n    \"\"\"\n    days = total_seconds // 86400\n    remaining_seconds = total_seconds % 86400\n\n    hours = remaining_seconds // 3600\n    remaining_seconds %= 3600\n\n    minutes = remaining_seconds // 60\n    seconds = remaining_seconds % 60\n\n    return days, hours, minutes, seconds"}
{"origin_topic": "检查一个字符串是否是有效的电子邮件格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if b.count('@') == 1:\n        c = b.split('@')\n        if len(c) == 2:\n            d = c[0]\n            e = c[1]\n            if d and e:\n                if '.' in e:\n                    f = e.split('.')\n                    if len(f) >= 2:\n                        for g in f:\n                            if not g:\n                                x = False\n                                break\n                        else:\n                            if b[0] != '.' and b[-1] != '.':\n                                if '..' not in b:\n                                    x = True\n    return x", "output": "from typing import Optional\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"验证电子邮件地址格式是否有效。\n    \n    基本验证规则：\n    1. 必须包含且仅包含一个 '@' 符号\n    2. '@' 前后必须有非空内容\n    3. 域名部分必须包含至少一个 '.'\n    4. 域名部分每个 '.' 分隔的段必须非空\n    5. 不能以 '.' 开头或结尾\n    6. 不能包含连续的 '..'\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果电子邮件格式有效返回 True，否则返回 False\n        \n    Examples:\n        >>> is_valid_email('user@example.com')\n        True\n        >>> is_valid_email('user@.com')\n        False\n        >>> is_valid_email('user@com')\n        False\n    \"\"\"\n    # 检查是否包含且仅包含一个 '@'\n    if email.count('@') != 1:\n        return False\n    \n    # 分割本地部分和域名部分\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    \n    local_part, domain_part = parts\n    \n    # 检查本地部分和域名部分是否非空\n    if not local_part or not domain_part:\n        return False\n    \n    # 检查域名部分是否包含 '.'\n    if '.' not in domain_part:\n        return False\n    \n    # 分割域名部分并检查每个段是否非空\n    domain_segments = domain_part.split('.')\n    if len(domain_segments) < 2:\n        return False\n    \n    for segment in domain_segments:\n        if not segment:\n            return False\n    \n    # 检查边界字符\n    if email.startswith('.') or email.endswith('.'):\n        return False\n    \n    # 检查是否包含连续的 '.'\n    if '..' in email:\n        return False\n    \n    return True"}
{"origin_topic": "将多个字典合并为一个（相同键则值相加）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def combine_dicts(*args):\n    result = {}\n    for d in args:\n        for k, v in d.items():\n            if k in result:\n                result[k] = result[k] + v\n            else:\n                result[k] = v\n    return result", "output": "from typing import Dict, Any, Iterable\n\n\ndef combine_dicts(*dicts: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"Combines multiple dictionaries by summing values for common keys.\n\n    This function takes multiple dictionaries as input and returns a new dictionary\n    where values for common keys are summed. If a key appears in only one dictionary,\n    its value is preserved as-is.\n\n    Args:\n        *dicts: Variable number of dictionaries to combine. Each dictionary should\n                have values that support the addition operator.\n\n    Returns:\n        A new dictionary containing the combined key-value pairs from all input\n        dictionaries. For keys present in multiple dictionaries, the value is the\n        sum of all corresponding values.\n\n    Raises:\n        TypeError: If any dictionary value does not support the addition operator.\n\n    Example:\n        >>> combine_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n        {'a': 1, 'b': 5, 'c': 4}\n        >>> combine_dicts({'x': [1, 2]}, {'x': [3, 4]})\n        {'x': [1, 2, 3, 4]}\n    \"\"\"\n    combined_result: Dict[Any, Any] = {}\n    \n    for current_dict in dicts:\n        for key, value in current_dict.items():\n            if key in combined_result:\n                combined_result[key] = combined_result[key] + value\n            else:\n                combined_result[key] = value\n    \n    return combined_result"}
{"origin_topic": "计算两个日期的天数差（简化版：假设每月30天）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b, x):\n    def c(y):\n        m = y // 10000\n        d = (y % 10000) // 100\n        e = y % 100\n        return m * 360 + d * 30 + e\n    f = c(b)\n    g = c(x)\n    h = f - g\n    if h < 0:\n        h = -h\n    return h", "output": "from typing import Callable\n\n\ndef calculate_date_difference(\n    start_date: int, end_date: int\n) -> int:\n    \"\"\"\n    Calculate the absolute difference between two dates in days.\n\n    The function expects dates in YYYYMMDD format (e.g., 20231225 for Dec 25, 2023).\n    It converts each date to a day count assuming:\n    - 360 days per year\n    - 30 days per month\n    - Actual day of month\n\n    Args:\n        start_date: The starting date in YYYYMMDD format.\n        end_date: The ending date in YYYYMMDD format.\n\n    Returns:\n        The absolute difference in days between the two dates.\n\n    Examples:\n        >>> calculate_date_difference(20230101, 20230115)\n        14\n        >>> calculate_date_difference(20231231, 20240101)\n        1\n    \"\"\"\n    def _convert_to_days(date_value: int) -> int:\n        \"\"\"\n        Convert a YYYYMMDD integer to total days using 360-day year, 30-day month.\n\n        Args:\n            date_value: Date in YYYYMMDD format.\n\n        Returns:\n            Total days from year 0 using simplified calendar.\n        \"\"\"\n        year = date_value // 10000\n        month = (date_value % 10000) // 100\n        day = date_value % 100\n        \n        return year * 360 + month * 30 + day\n\n    start_days = _convert_to_days(start_date)\n    end_days = _convert_to_days(end_date)\n    day_difference = start_days - end_days\n    \n    return abs(day_difference)"}
{"origin_topic": "将二进制字符串转换为十进制数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    x = len(a) - 1\n    for c in a:\n        if c == '1':\n            d = 2 ** x\n            b = b + d\n        x = x - 1\n    return b", "output": "def binary_string_to_int(binary_str: str) -> int:\n    \"\"\"Converts a binary string to its integer representation.\n\n    Args:\n        binary_str: A string consisting only of '0' and '1' characters.\n\n    Returns:\n        The integer value represented by the binary string.\n\n    Example:\n        >>> binary_string_to_int('1010')\n        10\n        >>> binary_string_to_int('1111')\n        15\n    \"\"\"\n    decimal_value = 0\n    exponent = len(binary_str) - 1\n\n    for digit in binary_str:\n        if digit == '1':\n            decimal_value += 2 ** exponent\n        exponent -= 1\n\n    return decimal_value"}
{"origin_topic": "打印斐波那契数列的前N项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def fibonacci_printer(n):\n    a = 0\n    b = 1\n    x = 0\n    result_list = []\n    if n >= 1:\n        result_list.append(a)\n    if n >= 2:\n        result_list.append(b)\n    while x < n - 2:\n        c = a + b\n        result_list.append(c)\n        a = b\n        b = c\n        x = x + 1\n    for item in result_list:\n        print(item)", "output": "from typing import List\n\n\ndef print_fibonacci_sequence(n: int) -> None:\n    \"\"\"Prints the first n numbers of the Fibonacci sequence.\n    \n    The Fibonacci sequence starts with 0 and 1. Each subsequent number\n    is the sum of the two preceding numbers.\n    \n    Args:\n        n: The number of Fibonacci numbers to print. Must be non-negative.\n        \n    Raises:\n        ValueError: If n is negative.\n        \n    Examples:\n        >>> print_fibonacci_sequence(5)\n        0\n        1\n        1\n        2\n        3\n    \"\"\"\n    if n < 0:\n        raise ValueError(f\"n must be non-negative, got {n}\")\n    \n    if n == 0:\n        return\n    \n    # Initialize the first two Fibonacci numbers\n    previous, current = 0, 1\n    fibonacci_numbers: List[int] = []\n    \n    # Handle the first number\n    fibonacci_numbers.append(previous)\n    \n    # Handle the second number if n >= 2\n    if n >= 2:\n        fibonacci_numbers.append(current)\n    \n    # Generate remaining Fibonacci numbers\n    for _ in range(2, n):\n        next_number = previous + current\n        fibonacci_numbers.append(next_number)\n        previous, current = current, next_number\n    \n    # Print all Fibonacci numbers\n    for number in fibonacci_numbers:\n        print(number)"}
{"origin_topic": "计算一个数字的平方根（使用牛顿法近似）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_square_root_using_newton_method_for_approximation_of_square_root_of_a_number(number_to_calculate_square_root_of):\n    if number_to_calculate_square_root_of < 0:\n        return None\n    if number_to_calculate_square_root_of == 0:\n        return 0\n    a = number_to_calculate_square_root_of\n    b = a / 2.0\n    while True:\n        x = b\n        b = (x + a / x) / 2.0\n        if abs(x - b) < 1e-10:\n            break\n    return b", "output": "\"\"\"Newton's method implementation for square root calculation.\"\"\"\n\nfrom typing import Optional\n\n\ndef sqrt_newton(number: float, tolerance: float = 1e-10) -> Optional[float]:\n    \"\"\"Calculate square root using Newton's method.\n    \n    Args:\n        number: The number to calculate the square root of.\n        tolerance: The precision tolerance for convergence. Defaults to 1e-10.\n    \n    Returns:\n        The square root of the number, or None if the input is negative.\n    \n    Raises:\n        ValueError: If tolerance is not positive.\n    \n    Examples:\n        >>> sqrt_newton(4.0)\n        2.0\n        >>> sqrt_newton(2.0)\n        1.4142135623730951\n        >>> sqrt_newton(-1.0) is None\n        True\n    \"\"\"\n    if tolerance <= 0:\n        raise ValueError(\"Tolerance must be positive.\")\n    \n    if number < 0:\n        return None\n    \n    if number == 0:\n        return 0.0\n    \n    # Initial guess: half of the input number\n    guess = number / 2.0\n    \n    while True:\n        previous_guess = guess\n        guess = (previous_guess + number / previous_guess) / 2.0\n        \n        if abs(previous_guess - guess) < tolerance:\n            break\n    \n    return guess"}
{"origin_topic": "统计文本文件中各单词的频率（假设文件内容已作为字符串给出）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    d = {}\n    w = ''\n    for c in s:\n        if c.isalpha():\n            w = w + c\n        else:\n            if w:\n                if w in d:\n                    d[w] = d[w] + 1\n                else:\n                    d[w] = 1\n                w = ''\n    if w:\n        if w in d:\n            d[w] = d[w] + 1\n        else:\n            d[w] = 1\n    return d", "output": "from typing import Dict\n\n\ndef count_words(text: str) -> Dict[str, int]:\n    \"\"\"Count occurrences of words in a string.\n    \n    A word is defined as a sequence of alphabetic characters (a-z, A-Z).\n    Non-alphabetic characters are treated as word separators.\n    \n    Args:\n        text: Input string containing words to be counted.\n        \n    Returns:\n        Dictionary mapping each word to its frequency count.\n        \n    Examples:\n        >>> count_words(\"hello world hello\")\n        {'hello': 2, 'world': 1}\n        \n        >>> count_words(\"apple, banana; apple!\")\n        {'apple': 2, 'banana': 1}\n    \"\"\"\n    word_counts: Dict[str, int] = {}\n    current_word: str = ''\n    \n    for character in text:\n        if character.isalpha():\n            current_word += character\n        else:\n            if current_word:\n                word_counts[current_word] = word_counts.get(current_word, 0) + 1\n                current_word = ''\n    \n    # Handle the last word if the string doesn't end with a separator\n    if current_word:\n        word_counts[current_word] = word_counts.get(current_word, 0) + 1\n    \n    return word_counts"}
{"origin_topic": "将字符串反转输出", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    x = len(a) - 1\n    while x >= 0:\n        b = b + a[x]\n        x = x - 1\n    return b", "output": "def reverse_string(input_string: str) -> str:\n    \"\"\"Reverses the order of characters in a given string.\n    \n    Args:\n        input_string: The string to be reversed.\n        \n    Returns:\n        The reversed string.\n        \n    Examples:\n        >>> reverse_string(\"hello\")\n        'olleh'\n        >>> reverse_string(\"\")\n        ''\n        >>> reverse_string(\"a\")\n        'a'\n    \"\"\"\n    reversed_chars = \"\"\n    current_index = len(input_string) - 1\n    \n    while current_index >= 0:\n        reversed_chars += input_string[current_index]\n        current_index -= 1\n        \n    return reversed_chars"}
{"origin_topic": "将字符串转换为字典，统计每个字符出现次数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = {}\n    for d in b:\n        e = False\n        for f in c.keys():\n            if f == d:\n                e = True\n                break\n        if e:\n            c[d] = c[d] + 1\n        else:\n            c[d] = 1\n    return c", "output": "from typing import Dict, Hashable, Iterable\n\n\ndef count_frequency(items: Iterable[Hashable]) -> Dict[Hashable, int]:\n    \"\"\"Count the frequency of each unique item in the input iterable.\n\n    Args:\n        items: An iterable of hashable items (e.g., strings, numbers, tuples)\n               whose frequencies are to be counted.\n\n    Returns:\n        A dictionary where keys are the unique items from the input,\n        and values are their corresponding frequencies (counts).\n\n    Examples:\n        >>> count_frequency(['apple', 'banana', 'apple', 'orange'])\n        {'apple': 2, 'banana': 1, 'orange': 1}\n        >>> count_frequency([1, 2, 1, 1, 3, 2])\n        {1: 3, 2: 2, 3: 1}\n    \"\"\"\n    frequency_map: Dict[Hashable, int] = {}\n    \n    for item in items:\n        if item in frequency_map:\n            frequency_map[item] += 1\n        else:\n            frequency_map[item] = 1\n    \n    return frequency_map"}
{"origin_topic": "反转给定的字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    l = len(s)\n    i = l - 1\n    while i >= 0:\n        r = r + s[i]\n        i = i - 1\n    return r", "output": "def reverse_string(input_string: str) -> str:\n    \"\"\"Reverses the order of characters in a given string.\n    \n    Args:\n        input_string: The string to be reversed.\n        \n    Returns:\n        A new string with characters in reverse order.\n        \n    Examples:\n        >>> reverse_string(\"hello\")\n        'olleh'\n        >>> reverse_string(\"\")\n        ''\n        >>> reverse_string(\"a\")\n        'a'\n    \"\"\"\n    reversed_chars = []\n    for i in range(len(input_string) - 1, -1, -1):\n        reversed_chars.append(input_string[i])\n    return ''.join(reversed_chars)"}
{"origin_topic": "计算一个字符串中特定字符的出现次数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a, b):\n    x = 0\n    for i in range(len(a)):\n        if a[i] == b:\n            x = x + 1\n        else:\n            x = x + 0\n    return x", "output": "from typing import List, Any\n\n\ndef count_occurrences(sequence: List[Any], target: Any) -> int:\n    \"\"\"Count the number of occurrences of target element in sequence.\n    \n    Args:\n        sequence: List of elements to search through.\n        target: Element to count occurrences of.\n    \n    Returns:\n        Integer count of how many times target appears in sequence.\n    \n    Examples:\n        >>> count_occurrences([1, 2, 3, 2, 4], 2)\n        2\n        >>> count_occurrences(['a', 'b', 'a', 'c'], 'a')\n        2\n        >>> count_occurrences([], 5)\n        0\n    \"\"\"\n    count = 0\n    for element in sequence:\n        if element == target:\n            count += 1\n    return count"}
{"origin_topic": "检查括号是否匹配（只考虑圆括号）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    for c in b:\n        if c == '(':\n            x.append(c)\n        elif c == ')':\n            if len(x) == 0:\n                return False\n            else:\n                x.pop()\n    if len(x) == 0:\n        return True\n    else:\n        return False", "output": "from typing import List\n\n\ndef is_balanced_parentheses(expression: str) -> bool:\n    \"\"\"检查括号表达式是否平衡。\n\n    一个平衡的括号表达式满足以下条件：\n    1. 每个左括号都有对应的右括号\n    2. 括号的嵌套顺序正确\n    3. 右括号不会出现在对应的左括号之前\n\n    Args:\n        expression: 要检查的字符串表达式，应仅包含括号字符\n\n    Returns:\n        True 如果括号平衡，否则 False\n\n    Examples:\n        >>> is_balanced_parentheses(\"(())\")\n        True\n        >>> is_balanced_parentheses(\"())(\")\n        False\n        >>> is_balanced_parentheses(\"((())\")\n        False\n    \"\"\"\n    stack: List[str] = []\n    \n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:  # 栈为空时遇到右括号\n                return False\n            stack.pop()\n    \n    return not stack  # 栈为空表示所有括号都匹配"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件地址（简单规则，包含'@'和'.'）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = False\n    d = 0\n    e = 0\n    for f in b:\n        if f == '@':\n            d = d + 1\n        if f == '.':\n            e = e + 1\n    if d == 1:\n        if e >= 1:\n            g = b.find('@')\n            h = b.find('.')\n            if g < h:\n                if g > 0:\n                    if h < len(b) - 1:\n                        c = True\n    return c", "output": "from typing import Union\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"验证字符串是否为有效的电子邮件地址格式。\n    \n    基本验证规则：\n    1. 必须包含且仅包含一个 '@' 符号\n    2. 必须至少包含一个 '.' 符号\n    3. '@' 必须在 '.' 之前出现\n    4. '@' 不能是第一个字符\n    5. '.' 不能是最后一个字符\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果符合基本电子邮件格式则返回 True，否则返回 False\n        \n    Examples:\n        >>> is_valid_email('test@example.com')\n        True\n        >>> is_valid_email('invalid.email')\n        False\n        >>> is_valid_email('@example.com')\n        False\n    \"\"\"\n    # 统计特殊字符的出现次数\n    at_count = 0\n    dot_count = 0\n    \n    for char in email:\n        if char == '@':\n            at_count += 1\n        elif char == '.':\n            dot_count += 1\n    \n    # 基础验证：必须恰好有一个 '@' 且至少有一个 '.'\n    if at_count != 1 or dot_count < 1:\n        return False\n    \n    # 获取字符位置\n    at_position = email.find('@')\n    dot_position = email.find('.')\n    \n    # 验证字符位置关系\n    return (\n        at_position < dot_position and  # '@' 必须在 '.' 之前\n        at_position > 0 and            # '@' 不能是第一个字符\n        dot_position < len(email) - 1  # '.' 不能是最后一个字符\n    )"}
{"origin_topic": "生成并返回斐波那契数列的前N项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def get_fibonacci_sequence(N):\n    result_list = []\n    if N <= 0:\n        return result_list\n    elif N == 1:\n        result_list.append(0)\n        return result_list\n    elif N == 2:\n        result_list.append(0)\n        result_list.append(1)\n        return result_list\n    else:\n        result_list.append(0)\n        result_list.append(1)\n        a = 0\n        b = 1\n        count = 2\n        while count < N:\n            x = a + b\n            result_list.append(x)\n            a = b\n            b = x\n            count = count + 1\n        return result_list", "output": "from typing import List\n\n\ndef generate_fibonacci_sequence(sequence_length: int) -> List[int]:\n    \"\"\"Generates the first N numbers of the Fibonacci sequence.\n\n    The Fibonacci sequence starts with 0 and 1. Each subsequent number is the\n    sum of the two preceding numbers.\n\n    Args:\n        sequence_length: The number of Fibonacci numbers to generate.\n            Must be a non-negative integer.\n\n    Returns:\n        A list containing the first `sequence_length` Fibonacci numbers.\n        Returns an empty list if `sequence_length` <= 0.\n\n    Examples:\n        >>> generate_fibonacci_sequence(0)\n        []\n        >>> generate_fibonacci_sequence(1)\n        [0]\n        >>> generate_fibonacci_sequence(5)\n        [0, 1, 1, 2, 3]\n    \"\"\"\n    if sequence_length <= 0:\n        return []\n\n    fibonacci_numbers: List[int] = [0]\n    if sequence_length == 1:\n        return fibonacci_numbers\n\n    fibonacci_numbers.append(1)\n    if sequence_length == 2:\n        return fibonacci_numbers\n\n    previous, current = 0, 1\n    # We already have the first two numbers in the list\n    numbers_generated = 2\n\n    while numbers_generated < sequence_length:\n        next_number = previous + current\n        fibonacci_numbers.append(next_number)\n        previous, current = current, next_number\n        numbers_generated += 1\n\n    return fibonacci_numbers"}
{"origin_topic": "将字符串按单词分割成列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = \"\"\n    for i in range(len(a)):\n        if a[i] != \" \":\n            x = x + a[i]\n        else:\n            if x != \"\":\n                b.append(x)\n                x = \"\"\n    if x != \"\":\n        b.append(x)\n    return b", "output": "from typing import List\n\n\ndef split_string_by_spaces(input_string: str) -> List[str]:\n    \"\"\"Splits a string into substrings based on space characters.\n    \n    This function processes a string character by character, accumulating\n    non-space characters into substrings. When a space is encountered,\n    the accumulated substring is added to the result list if it's non-empty.\n    Multiple consecutive spaces are treated as a single delimiter.\n    \n    Args:\n        input_string: The string to be split. Can contain any characters.\n        \n    Returns:\n        A list of non-empty substrings from the original string, separated\n        by spaces. If the input string contains only spaces, returns an\n        empty list.\n        \n    Examples:\n        >>> split_string_by_spaces(\"hello world\")\n        ['hello', 'world']\n        >>> split_string_by_spaces(\"  multiple   spaces  \")\n        ['multiple', 'spaces']\n        >>> split_string_by_spaces(\"\")\n        []\n        >>> split_string_by_spaces(\"nospaces\")\n        ['nospaces']\n    \"\"\"\n    result: List[str] = []\n    current_word: str = \"\"\n    \n    for character in input_string:\n        if character != \" \":\n            current_word += character\n        else:\n            if current_word:\n                result.append(current_word)\n                current_word = \"\"\n    \n    # Handle the last word if it exists\n    if current_word:\n        result.append(current_word)\n    \n    return result"}
{"origin_topic": "将一个字符串中的所有单词倒序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b.split()\n    e = len(d)\n    f = e - 1\n    while f >= 0:\n        g = d[f]\n        c.append(g)\n        f = f - 1\n    h = ' '.join(c)\n    return h", "output": "def reverse_words(text: str) -> str:\n    \"\"\"Reverses the order of words in a given string.\n\n    This function splits the input string into individual words, reverses their\n    order, and then joins them back into a single string with spaces between words.\n\n    Args:\n        text: The input string containing words to be reversed.\n\n    Returns:\n        A new string with the words in reverse order.\n\n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"Python is awesome\")\n        'awesome is Python'\n    \"\"\"\n    words = text.split()\n    reversed_words = []\n    \n    # Iterate through words in reverse order\n    for i in range(len(words) - 1, -1, -1):\n        reversed_words.append(words[i])\n    \n    return ' '.join(reversed_words)"}
{"origin_topic": "统计字符串中单词的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = 0\n    d = False\n    for e in b:\n        if e == ' ':\n            if d:\n                c = c + 1\n                d = False\n        else:\n            if not d:\n                d = True\n    if d:\n        c = c + 1\n    return c", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a given string.\n\n    Words are defined as sequences of non-space characters separated by one or\n    more spaces. Leading and trailing spaces are ignored.\n\n    Args:\n        text: The input string to count words in.\n\n    Returns:\n        The number of words in the input string.\n\n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n        >>> count_words(\"SingleWord\")\n        1\n    \"\"\"\n    word_count = 0\n    in_word = False\n\n    for char in text:\n        if char == ' ':\n            if in_word:\n                word_count += 1\n                in_word = False\n        else:\n            if not in_word:\n                in_word = True\n\n    # Count the last word if the string doesn't end with a space\n    if in_word:\n        word_count += 1\n\n    return word_count"}
{"origin_topic": "统计一个句子中的单词数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    if s == \"\":\n        return 0\n    else:\n        c = 0\n        i = 0\n        n = len(s)\n        while i < n:\n            while i < n and s[i] == ' ':\n                i += 1\n            if i < n:\n                c += 1\n                while i < n and s[i] != ' ':\n                    i += 1\n        return c", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a string.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    Leading, trailing, and multiple consecutive spaces are handled correctly.\n    \n    Args:\n        text: The input string to count words in.\n        \n    Returns:\n        The number of words in the input string.\n        \n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n        >>> count_words(\"   \")\n        0\n    \"\"\"\n    if not text:\n        return 0\n    \n    word_count = 0\n    index = 0\n    text_length = len(text)\n    \n    while index < text_length:\n        # Skip leading spaces\n        while index < text_length and text[index] == ' ':\n            index += 1\n        \n        # If we found a non-space character, we have a word\n        if index < text_length:\n            word_count += 1\n            \n            # Skip the word characters\n            while index < text_length and text[index] != ' ':\n                index += 1\n    \n    return word_count"}
{"origin_topic": "将字符串中的所有单词反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = s.split()\n    for x in b:\n        c = list(x)\n        d = []\n        for y in range(len(c) - 1, -1, -1):\n            d.append(c[y])\n        e = ''.join(d)\n        a.append(e)\n    g = ' '.join(a)\n    return g", "output": "def reverse_words_in_string(input_string: str) -> str:\n    \"\"\"Reverses the characters in each word of a given string.\n\n    This function splits the input string into words, reverses the characters\n    within each word, and then joins the reversed words back into a single\n    string with spaces preserved.\n\n    Example:\n        reverse_words_in_string(\"hello world\") -> \"olleh dlrow\"\n\n    Args:\n        input_string: The string whose words should be reversed.\n\n    Returns:\n        A new string where each word's characters are reversed, but word\n        order and spacing are preserved.\n    \"\"\"\n    words = input_string.split()\n    reversed_words = []\n\n    for word in words:\n        # Reverse the characters in the word using slicing\n        reversed_word = word[::-1]\n        reversed_words.append(reversed_word)\n\n    # Join the reversed words back with spaces\n    return ' '.join(reversed_words)"}
{"origin_topic": "将一个字典按键排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(x):\n    y = {}\n    z = list(x.keys())\n    for i in range(len(z)):\n        for j in range(len(z) - i - 1):\n            if z[j] > z[j + 1]:\n                t = z[j]\n                z[j] = z[j + 1]\n                z[j + 1] = t\n    for k in z:\n        y[k] = x[k]\n    return y", "output": "from typing import Dict, Any, List\n\n\ndef sort_dict_by_keys(input_dict: Dict[Any, Any]) -> Dict[Any, Any]:\n    \"\"\"Sorts a dictionary by its keys in ascending order using bubble sort.\n    \n    This function creates a new dictionary with the same key-value pairs as the\n    input dictionary, but with keys sorted in ascending order. The sorting is\n    performed using the bubble sort algorithm.\n    \n    Args:\n        input_dict: The dictionary to be sorted by keys.\n        \n    Returns:\n        A new dictionary with keys sorted in ascending order.\n        \n    Example:\n        >>> sort_dict_by_keys({'c': 3, 'a': 1, 'b': 2})\n        {'a': 1, 'b': 2, 'c': 3}\n    \"\"\"\n    sorted_keys: List[Any] = list(input_dict.keys())\n    dict_length: int = len(sorted_keys)\n    \n    # Bubble sort implementation\n    for i in range(dict_length):\n        for j in range(dict_length - i - 1):\n            if sorted_keys[j] > sorted_keys[j + 1]:\n                # Swap adjacent elements\n                sorted_keys[j], sorted_keys[j + 1] = sorted_keys[j + 1], sorted_keys[j]\n    \n    # Create new dictionary with sorted keys\n    sorted_dict: Dict[Any, Any] = {}\n    for key in sorted_keys:\n        sorted_dict[key] = input_dict[key]\n    \n    return sorted_dict"}
{"origin_topic": "计算字符串中字母和数字的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = 0\n    b = 0\n    for x in s:\n        if (x >= 'a' and x <= 'z') or (x >= 'A' and x <= 'Z'):\n            a = a + 1\n        elif x >= '0' and x <= '9':\n            b = b + 1\n    return a, b", "output": "from typing import Tuple\n\n\ndef count_letters_and_digits(input_string: str) -> Tuple[int, int]:\n    \"\"\"统计字符串中字母和数字的数量。\n\n    遍历输入字符串，分别统计英文字母（大小写）和数字字符的数量。\n\n    Args:\n        input_string: 需要统计的字符串。\n\n    Returns:\n        包含两个整数的元组，第一个是字母数量，第二个是数字数量。\n\n    Examples:\n        >>> count_letters_and_digits(\"Hello123\")\n        (5, 3)\n        >>> count_letters_and_digits(\"Python 3.9\")\n        (6, 2)\n    \"\"\"\n    letter_count = 0\n    digit_count = 0\n\n    for character in input_string:\n        if character.isalpha():\n            letter_count += 1\n        elif character.isdigit():\n            digit_count += 1\n\n    return letter_count, digit_count"}
{"origin_topic": "将字符串中的所有元音字母替换为星号", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = list(s)\n    b = []\n    for x in a:\n        if x == 'a' or x == 'e' or x == 'i' or x == 'o' or x == 'u' or x == 'A' or x == 'E' or x == 'I' or x == 'O' or x == 'U':\n            b.append('*')\n        else:\n            b.append(x)\n    c = ''.join(b)\n    return c", "output": "from typing import List\n\n\ndef replace_vowels_with_asterisk(input_string: str) -> str:\n    \"\"\"将输入字符串中的所有元音字母替换为星号(*)。\n\n    元音字母包括：a, e, i, o, u 及其大写形式。\n\n    Args:\n        input_string: 需要处理的原始字符串\n\n    Returns:\n        处理后的字符串，其中所有元音字母已被替换为星号(*)\n\n    Examples:\n        >>> replace_vowels_with_asterisk(\"Hello World\")\n        'H*ll* W*rld'\n        >>> replace_vowels_with_asterisk(\"AEIOUaeiou\")\n        '**********'\n    \"\"\"\n    VOWELS: set[str] = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    characters: List[str] = list(input_string)\n    processed_characters: List[str] = []\n    \n    for character in characters:\n        if character in VOWELS:\n            processed_characters.append('*')\n        else:\n            processed_characters.append(character)\n    \n    return ''.join(processed_characters)"}
{"origin_topic": "找出一个数的二进制表示中1的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_ones_in_binary_representation_of_a_number(n):\n    if n < 0:\n        n = abs(n)\n    a = 0\n    while n > 0:\n        b = n % 2\n        if b == 1:\n            a = a + 1\n        n = n // 2\n    if n == 0 and a == 0:\n        a = 0\n    return a", "output": "def count_set_bits(n: int) -> int:\n    \"\"\"Count the number of 1 bits in the binary representation of an integer.\n    \n    This function uses the standard bit counting algorithm by repeatedly\n    checking the least significant bit and right-shifting the number.\n    \n    Args:\n        n: An integer whose set bits are to be counted. Handles negative\n            numbers by taking their absolute value.\n    \n    Returns:\n        The number of 1 bits in the binary representation of the absolute\n        value of n.\n    \n    Examples:\n        >>> count_set_bits(5)  # binary: 101\n        2\n        >>> count_set_bits(0)  # binary: 0\n        0\n        >>> count_set_bits(-3)  # binary of abs(-3): 11\n        2\n    \"\"\"\n    if n < 0:\n        n = abs(n)\n    \n    count = 0\n    while n > 0:\n        if n & 1:  # Check if least significant bit is 1\n            count += 1\n        n >>= 1  # Right shift by 1 (equivalent to n // 2)\n    \n    return count"}
{"origin_topic": "将字符串中的所有小写字母转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        if d == 'a':\n            c = c + 'A'\n        elif d == 'b':\n            c = c + 'B'\n        elif d == 'c':\n            c = c + 'C'\n        elif d == 'd':\n            c = c + 'D'\n        elif d == 'e':\n            c = c + 'E'\n        elif d == 'f':\n            c = c + 'F'\n        elif d == 'g':\n            c = c + 'G'\n        elif d == 'h':\n            c = c + 'H'\n        elif d == 'i':\n            c = c + 'I'\n        elif d == 'j':\n            c = c + 'J'\n        elif d == 'k':\n            c = c + 'K'\n        elif d == 'l':\n            c = c + 'L'\n        elif d == 'm':\n            c = c + 'M'\n        elif d == 'n':\n            c = c + 'N'\n        elif d == 'o':\n            c = c + 'O'\n        elif d == 'p':\n            c = c + 'P'\n        elif d == 'q':\n            c = c + 'Q'\n        elif d == 'r':\n            c = c + 'R'\n        elif d == 's':\n            c = c + 'S'\n        elif d == 't':\n            c = c + 'T'\n        elif d == 'u':\n            c = c + 'U'\n        elif d == 'v':\n            c = c + 'V'\n        elif d == 'w':\n            c = c + 'W'\n        elif d == 'x':\n            c = c + 'X'\n        elif d == 'y':\n            c = c + 'Y'\n        elif d == 'z':\n            c = c + 'Z'\n        else:\n            c = c + d\n    return c", "output": "def convert_lowercase_to_uppercase(input_string: str) -> str:\n    \"\"\"将字符串中的小写字母转换为大写字母，其他字符保持不变。\n    \n    该函数遍历输入字符串，将小写字母(a-z)转换为对应的大写字母(A-Z)，\n    非小写字母字符保持原样。\n    \n    Args:\n        input_string: 需要转换的输入字符串\n    \n    Returns:\n        转换后的字符串，其中所有小写字母已转换为大写字母\n        \n    Examples:\n        >>> convert_lowercase_to_uppercase(\"hello123\")\n        'HELLO123'\n        >>> convert_lowercase_to_uppercase(\"Python 3.9\")\n        'PYTHON 3.9'\n    \"\"\"\n    result = \"\"\n    \n    for character in input_string:\n        if 'a' <= character <= 'z':\n            # 利用ASCII码特性：小写字母比对应大写字母的ASCII码大32\n            uppercase_char = chr(ord(character) - 32)\n            result += uppercase_char\n        else:\n            result += character\n    \n    return result"}
{"origin_topic": "反转字符串并输出", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    x = len(a) - 1\n    while x >= 0:\n        b = b + a[x]\n        x = x - 1\n    print(b)", "output": "def reverse_string(input_string: str) -> None:\n    \"\"\"Reverses the given string and prints the result.\n    \n    Args:\n        input_string: The string to be reversed.\n    \n    Returns:\n        None. The reversed string is printed to stdout.\n    \n    Example:\n        >>> reverse_string(\"hello\")\n        olleh\n    \"\"\"\n    reversed_chars = []\n    \n    # Iterate from the end to the beginning of the string\n    for i in range(len(input_string) - 1, -1, -1):\n        reversed_chars.append(input_string[i])\n    \n    reversed_string = ''.join(reversed_chars)\n    print(reversed_string)"}
{"origin_topic": "验证电子邮件地址格式（简单版）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    if a.count('@') == 1:\n        x = a.split('@')\n        if len(x) == 2:\n            y = x[0]\n            z = x[1]\n            if y and z:\n                if '.' in z:\n                    m = z.split('.')\n                    if len(m) >= 2:\n                        for n in m:\n                            if not n:\n                                b = False\n                                break\n                        else:\n                            b = True\n    return b", "output": "from typing import Optional\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"验证电子邮件地址的基本格式是否有效。\n    \n    此函数执行基本的电子邮件格式验证，检查：\n    1. 是否包含且仅包含一个 '@' 符号\n    2. '@' 符号前后都有内容\n    3. 域名部分包含至少一个 '.' 符号\n    4. 域名中每个部分都不为空\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果电子邮件格式基本有效返回 True，否则返回 False\n        \n    Examples:\n        >>> is_valid_email('user@example.com')\n        True\n        >>> is_valid_email('invalid@email')\n        False\n        >>> is_valid_email('@example.com')\n        False\n    \"\"\"\n    # 检查是否包含且仅包含一个 '@' 符号\n    if email.count('@') != 1:\n        return False\n    \n    # 分割本地部分和域名部分\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    \n    local_part, domain_part = parts\n    \n    # 检查本地部分和域名部分是否都非空\n    if not local_part or not domain_part:\n        return False\n    \n    # 检查域名部分是否包含 '.' 符号\n    if '.' not in domain_part:\n        return False\n    \n    # 分割域名部分并检查每个部分是否非空\n    domain_components = domain_part.split('.')\n    if len(domain_components) < 2:\n        return False\n    \n    # 检查域名中每个部分都不为空\n    for component in domain_components:\n        if not component:\n            return False\n    \n    return True"}
{"origin_topic": "找出一个字符串中所有数字的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def find_sum_of_numbers_in_string(input_string):\n    total_sum = 0\n    current_number_string = \"\"\n    for character in input_string:\n        if character.isdigit():\n            current_number_string = current_number_string + character\n        else:\n            if current_number_string != \"\":\n                total_sum = total_sum + int(current_number_string)\n                current_number_string = \"\"\n    if current_number_string != \"\":\n        total_sum = total_sum + int(current_number_string)\n    return total_sum", "output": "def extract_and_sum_numbers(text: str) -> int:\n    \"\"\"Extracts all consecutive digit sequences from a string and returns their sum.\n    \n    This function scans the input string character by character, accumulating\n    consecutive digits into numbers. When a non-digit character is encountered\n    or the string ends, the accumulated digits are converted to an integer and\n    added to the running total.\n    \n    Examples:\n        >>> extract_and_sum_numbers(\"abc123def45gh6\")\n        174\n        >>> extract_and_sum_numbers(\"no numbers here\")\n        0\n        >>> extract_and_sum_numbers(\"100 200 300\")\n        600\n    \n    Args:\n        text: The input string from which to extract and sum numbers.\n    \n    Returns:\n        The sum of all consecutive digit sequences found in the input string.\n    \"\"\"\n    total_sum = 0\n    current_digits = \"\"\n    \n    for char in text:\n        if char.isdigit():\n            current_digits += char\n        else:\n            if current_digits:\n                total_sum += int(current_digits)\n                current_digits = \"\"\n    \n    # Handle any trailing digits at the end of the string\n    if current_digits:\n        total_sum += int(current_digits)\n    \n    return total_sum"}
{"origin_topic": "移除字符串中的所有元音字母", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    r = \"\"\n    for c in s:\n        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u':\n            x = 0\n        elif c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U':\n            y = 0\n        else:\n            r = r + c\n    return r", "output": "def remove_vowels(text: str) -> str:\n    \"\"\"Removes all vowel characters (both lowercase and uppercase) from the input string.\n\n    Args:\n        text: The input string from which vowels will be removed.\n\n    Returns:\n        A new string containing only the non-vowel characters from the input.\n\n    Examples:\n        >>> remove_vowels(\"Hello World!\")\n        'Hll Wrld!'\n        >>> remove_vowels(\"AEIOUaeiou\")\n        ''\n        >>> remove_vowels(\"Python 3.9\")\n        'Pythn 3.9'\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    result_chars = []\n    \n    for character in text:\n        if character not in vowels:\n            result_chars.append(character)\n    \n    return \"\".join(result_chars)"}
{"origin_topic": "将字符串拆分成单词列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    for x in s:\n        if x == ' ':\n            if b != '':\n                a.append(b)\n                b = ''\n        else:\n            b = b + x\n    if b != '':\n        a.append(b)\n    return a", "output": "from typing import List\n\n\ndef split_string_by_spaces(input_string: str) -> List[str]:\n    \"\"\"Splits a string into words based on spaces, ignoring multiple spaces.\n    \n    This function processes a string character by character, accumulating\n    characters into words until a space is encountered. Multiple consecutive\n    spaces are treated as a single delimiter.\n    \n    Args:\n        input_string: The string to be split into words.\n        \n    Returns:\n        A list of words extracted from the input string. Returns an empty\n        list if the input string contains no non-space characters.\n        \n    Examples:\n        >>> split_string_by_spaces(\"hello world\")\n        ['hello', 'world']\n        >>> split_string_by_spaces(\"  multiple   spaces  here  \")\n        ['multiple', 'spaces', 'here']\n        >>> split_string_by_spaces(\"\")\n        []\n        >>> split_string_by_spaces(\"   \")\n        []\n    \"\"\"\n    words: List[str] = []\n    current_word: str = ''\n    \n    for character in input_string:\n        if character == ' ':\n            if current_word:\n                words.append(current_word)\n                current_word = ''\n        else:\n            current_word += character\n    \n    # Append the last word if it exists\n    if current_word:\n        words.append(current_word)\n    \n    return words"}
{"origin_topic": "将字符串中的所有数字替换为'#'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for y in b:\n        if y == \"0\" or y == \"1\" or y == \"2\" or y == \"3\" or y == \"4\" or y == \"5\" or y == \"6\" or y == \"7\" or y == \"8\" or y == \"9\":\n            x = x + \"#\"\n        else:\n            x = x + y\n    return x", "output": "def mask_digits(text: str) -> str:\n    \"\"\"Replaces all digit characters in the input string with '#'.\n    \n    Args:\n        text: The input string that may contain digits.\n    \n    Returns:\n        A new string where all digit characters ('0'-'9') are replaced\n        with '#' characters, while all other characters remain unchanged.\n    \n    Examples:\n        >>> mask_digits(\"abc123def456\")\n        'abc###def###'\n        >>> mask_digits(\"No digits here!\")\n        'No digits here!'\n        >>> mask_digits(\"\")\n        ''\n    \"\"\"\n    masked_text = []\n    \n    for character in text:\n        if character.isdigit():\n            masked_text.append(\"#\")\n        else:\n            masked_text.append(character)\n    \n    return \"\".join(masked_text)"}
{"origin_topic": "将一个字典按值排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(input_dict):\n    sorted_items = []\n    for key, value in input_dict.items():\n        sorted_items.append((key, value))\n    for i in range(len(sorted_items)):\n        for j in range(len(sorted_items) - 1):\n            if sorted_items[j][1] > sorted_items[j + 1][1]:\n                temp = sorted_items[j]\n                sorted_items[j] = sorted_items[j + 1]\n                sorted_items[j + 1] = temp\n    result_dict = {}\n    for item in sorted_items:\n        result_dict[item[0]] = item[1]\n    return result_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary values\n\ndef sort_dict_by_value(input_dict: Dict[str, T]) -> Dict[str, T]:\n    \"\"\"Sorts a dictionary by its values in ascending order.\n    \n    This function creates a new dictionary with the same key-value pairs as the\n    input dictionary, but sorted by the values in ascending order. The sorting\n    algorithm used is bubble sort, which is suitable for small datasets.\n    \n    Args:\n        input_dict: A dictionary with string keys and comparable values.\n        \n    Returns:\n        A new dictionary containing the same key-value pairs as input_dict,\n        sorted by values in ascending order.\n        \n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n        \n    Note:\n        For large dictionaries, consider using Python's built-in sorted()\n        function with a custom key for better performance.\n    \"\"\"\n    # Convert dictionary items to a list of tuples\n    items_list = [(key, value) for key, value in input_dict.items()]\n    \n    # Sort items using bubble sort algorithm\n    item_count = len(items_list)\n    for outer_index in range(item_count):\n        for inner_index in range(item_count - 1):\n            current_item = items_list[inner_index]\n            next_item = items_list[inner_index + 1]\n            \n            if current_item[1] > next_item[1]:\n                # Swap items if current value is greater than next value\n                items_list[inner_index], items_list[inner_index + 1] = \\\n                    items_list[inner_index + 1], items_list[inner_index]\n    \n    # Reconstruct dictionary from sorted items\n    sorted_dict = {key: value for key, value in items_list}\n    \n    return sorted_dict"}
{"origin_topic": "计算一个字符串中大写字母的数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_uppercase(s):\n    result = 0\n    for char in s:\n        if char.isupper():\n            result = result + 1\n        else:\n            pass\n    return result", "output": "def count_uppercase_characters(text: str) -> int:\n    \"\"\"Counts the number of uppercase characters in a given string.\n\n    Args:\n        text: The input string to analyze.\n\n    Returns:\n        The count of uppercase characters in the input string.\n\n    Examples:\n        >>> count_uppercase_characters(\"Hello World\")\n        2\n        >>> count_uppercase_characters(\"lowercase\")\n        0\n        >>> count_uppercase_characters(\"UPPERCASE\")\n        9\n    \"\"\"\n    uppercase_count = 0\n    for character in text:\n        if character.isupper():\n            uppercase_count += 1\n    return uppercase_count"}
{"origin_topic": "移除字符串首尾的空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    y = 0\n    while y < len(b):\n        if b[y] != \" \":\n            break\n        y = y + 1\n    z = len(b) - 1\n    while z >= 0:\n        if b[z] != \" \":\n            break\n        z = z - 1\n    if y > z:\n        return \"\"\n    for i in range(y, z + 1):\n        x = x + b[i]\n    return x", "output": "def strip_custom(text: str) -> str:\n    \"\"\"Removes leading and trailing whitespace from a string.\n    \n    This function implements custom whitespace stripping logic similar to str.strip(),\n    but operates at a character level without using built-in string methods.\n    \n    Args:\n        text: The input string to process. If empty or contains only whitespace,\n              an empty string will be returned.\n    \n    Returns:\n        A new string with leading and trailing whitespace removed. If the input\n        contains only whitespace or is empty, returns an empty string.\n    \n    Examples:\n        >>> strip_custom(\"  hello world  \")\n        'hello world'\n        >>> strip_custom(\"   \")\n        ''\n        >>> strip_custom(\"no_spaces\")\n        'no_spaces'\n    \"\"\"\n    if not text:\n        return \"\"\n    \n    # Find first non-whitespace character from the start\n    start_index = 0\n    while start_index < len(text) and text[start_index] == \" \":\n        start_index += 1\n    \n    # Find last non-whitespace character from the end\n    end_index = len(text) - 1\n    while end_index >= 0 and text[end_index] == \" \":\n        end_index -= 1\n    \n    # If start_index exceeds end_index, the string contains only whitespace\n    if start_index > end_index:\n        return \"\"\n    \n    # Build the result string from the identified range\n    result_chars = []\n    for i in range(start_index, end_index + 1):\n        result_chars.append(text[i])\n    \n    return \"\".join(result_chars)"}
{"origin_topic": "检查密码强度（长度、大小写、数字）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_password_strength(a):\n    b = False\n    x = False\n    y = False\n    z = False\n    if len(a) >= 8:\n        b = True\n    for i in a:\n        if i.isupper():\n            x = True\n        if i.islower():\n            y = True\n        if i.isdigit():\n            z = True\n    if b and x and y and z:\n        return True\n    else:\n        return False", "output": "from typing import Union\n\n\ndef check_password_strength(password: Union[str, bytes]) -> bool:\n    \"\"\"检查密码强度是否符合基本安全要求。\n\n    密码必须满足以下所有条件：\n    1. 长度至少为8个字符\n    2. 至少包含一个大写字母\n    3. 至少包含一个小写字母\n    4. 至少包含一个数字\n\n    Args:\n        password: 待检查的密码字符串或字节串\n\n    Returns:\n        True 如果密码满足所有强度要求，否则返回 False\n\n    Raises:\n        TypeError: 如果输入不是字符串或字节串类型\n    \"\"\"\n    # 验证输入类型\n    if not isinstance(password, (str, bytes)):\n        raise TypeError(f\"密码必须是字符串或字节串类型，但收到 {type(password)}\")\n\n    # 将字节串转换为字符串以便处理\n    if isinstance(password, bytes):\n        password = password.decode('utf-8', errors='ignore')\n\n    # 初始化检查标志\n    has_minimum_length = len(password) >= 8\n    has_uppercase = False\n    has_lowercase = False\n    has_digit = False\n\n    # 遍历密码字符进行检查\n    for character in password:\n        if character.isupper():\n            has_uppercase = True\n        elif character.islower():\n            has_lowercase = True\n        elif character.isdigit():\n            has_digit = True\n\n        # 如果所有条件都已满足，提前退出循环\n        if has_uppercase and has_lowercase and has_digit:\n            break\n\n    # 返回所有条件是否都满足\n    return all([has_minimum_length, has_uppercase, has_lowercase, has_digit])"}
{"origin_topic": "将字符串中的元音字母移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    v = \"aeiouAEIOU\"\n    r = \"\"\n    for c in s:\n        flag = False\n        for vc in v:\n            if c == vc:\n                flag = True\n                break\n        if not flag:\n            r = r + c\n    return r", "output": "def remove_vowels(text: str) -> str:\n    \"\"\"Removes all vowels (both lowercase and uppercase) from the input string.\n\n    Args:\n        text: The input string from which vowels will be removed.\n\n    Returns:\n        A new string with all vowels removed. Non-vowel characters remain in their\n        original order.\n\n    Examples:\n        >>> remove_vowels(\"Hello World\")\n        'Hll Wrld'\n        >>> remove_vowels(\"AEIOUaeiou\")\n        ''\n        >>> remove_vowels(\"bcdfg\")\n        'bcdfg'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result_chars = []\n    \n    for character in text:\n        if character not in vowels:\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "将一个字符串按单词反转顺序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    c = 0\n    d = len(s)\n    while c < d:\n        e = s[c]\n        if e == ' ':\n            if b != '':\n                a.append(b)\n                b = ''\n        else:\n            b = b + e\n        c = c + 1\n    if b != '':\n        a.append(b)\n    x = len(a)\n    y = []\n    z = x - 1\n    while z >= 0:\n        y.append(a[z])\n        z = z - 1\n    result = ''\n    if len(y) > 0:\n        for i in range(len(y)):\n            result = result + y[i]\n            if i != len(y) - 1:\n                result = result + ' '\n    return result", "output": "def reverse_words(s: str) -> str:\n    \"\"\"Reverses the order of words in a string while preserving word boundaries.\n\n    Words are defined as non-space characters separated by spaces. Multiple spaces\n    between words are treated as single delimiters in the output.\n\n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  multiple   spaces   between   words  \")\n        'words between spaces multiple'\n\n    Args:\n        s: Input string containing words separated by spaces.\n\n    Returns:\n        String with words in reverse order, separated by single spaces.\n        Returns empty string if input contains no words.\n    \"\"\"\n    words = []\n    current_word = []\n    \n    # Parse words from input string\n    for char in s:\n        if char == ' ':\n            if current_word:\n                words.append(''.join(current_word))\n                current_word = []\n        else:\n            current_word.append(char)\n    \n    # Add the last word if present\n    if current_word:\n        words.append(''.join(current_word))\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join reversed words with single spaces\n    return ' '.join(reversed_words)"}
{"origin_topic": "将CSV字符串解析为列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    c = b.split(\"\\n\")\n    for d in c:\n        if d:\n            e = []\n            f = d.split(\",\")\n            for g in f:\n                e.append(g)\n            x.append(e)\n    return x", "output": "from typing import List\n\n\ndef parse_csv_string(csv_string: str) -> List[List[str]]:\n    \"\"\"Parse a CSV-formatted string into a 2D list of strings.\n    \n    Args:\n        csv_string: A string containing CSV data with rows separated by newlines\n                   and columns separated by commas.\n    \n    Returns:\n        A 2D list where each inner list represents a row of CSV data.\n        Empty rows in the input are ignored.\n    \n    Example:\n        >>> parse_csv_string(\"a,b,c\\\\n1,2,3\\\\n\")\n        [['a', 'b', 'c'], ['1', '2', '3']]\n    \"\"\"\n    parsed_data: List[List[str]] = []\n    \n    # Split the input string into rows\n    rows = csv_string.strip().split(\"\\n\")\n    \n    for row in rows:\n        # Skip empty rows\n        if not row:\n            continue\n            \n        # Split each row into columns\n        columns = row.split(\",\")\n        parsed_data.append(columns)\n    \n    return parsed_data"}
{"origin_topic": "计算字符串中数字的总和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = 0\n    b = 0\n    for x in s:\n        if x == '0' or x == '1' or x == '2' or x == '3' or x == '4' or x == '5' or x == '6' or x == '7' or x == '8' or x == '9':\n            b = int(x)\n            a = a + b\n        else:\n            continue\n    return a", "output": "def sum_digits_in_string(input_string: str) -> int:\n    \"\"\"计算字符串中所有数字字符的数值总和。\n    \n    遍历输入字符串中的每个字符，如果字符是数字（0-9），则将其转换为整数并累加。\n    忽略所有非数字字符。\n    \n    Args:\n        input_string: 需要处理的字符串，可能包含数字和非数字字符。\n        \n    Returns:\n        字符串中所有数字字符的数值总和。如果没有数字字符，则返回0。\n        \n    Examples:\n        >>> sum_digits_in_string(\"abc123\")\n        6\n        >>> sum_digits_in_string(\"a1b2c3\")\n        6\n        >>> sum_digits_in_string(\"no digits\")\n        0\n    \"\"\"\n    total_sum = 0\n    \n    for character in input_string:\n        if character.isdigit():\n            digit_value = int(character)\n            total_sum += digit_value\n    \n    return total_sum"}
{"origin_topic": "将字符串按单词反转（保留空格）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    x = 0\n    while x < len(s):\n        if s[x] != ' ':\n            b = b + s[x]\n        else:\n            if b != '':\n                a.append(b)\n                b = ''\n            a.append(' ')\n        x = x + 1\n    if b != '':\n        a.append(b)\n    c = []\n    y = len(a) - 1\n    while y >= 0:\n        c.append(a[y])\n        y = y - 1\n    d = ''\n    z = 0\n    while z < len(c):\n        d = d + c[z]\n        z = z + 1\n    return d", "output": "def reverse_words(s: str) -> str:\n    \"\"\"Reverse the order of words in a string while preserving spaces.\n    \n    This function splits the input string into words and spaces, reverses their\n    order, and then reconstructs the string. Multiple consecutive spaces are\n    preserved in the output.\n    \n    Args:\n        s: The input string to process.\n        \n    Returns:\n        A new string with words in reverse order, preserving original spacing.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  multiple   spaces  here  \")\n        '  here   spaces  multiple  '\n    \"\"\"\n    # Step 1: Tokenize the string into words and spaces\n    tokens = []\n    current_word = ''\n    \n    for char in s:\n        if char != ' ':\n            current_word += char\n        else:\n            # If we have accumulated a word, add it to tokens\n            if current_word:\n                tokens.append(current_word)\n                current_word = ''\n            # Add the space as a separate token\n            tokens.append(' ')\n    \n    # Add the last word if it exists\n    if current_word:\n        tokens.append(current_word)\n    \n    # Step 2: Reverse the tokens\n    reversed_tokens = tokens[::-1]\n    \n    # Step 3: Reconstruct the string from reversed tokens\n    return ''.join(reversed_tokens)"}
{"origin_topic": "找出字符串中的所有数字并求和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    t = \"\"\n    r = 0\n    for c in s:\n        if c.isdigit():\n            t = t + c\n        else:\n            if t != \"\":\n                r = r + int(t)\n                t = \"\"\n    if t != \"\":\n        r = r + int(t)\n    return r", "output": "def sum_numbers_in_string(text: str) -> int:\n    \"\"\"计算字符串中所有连续数字字符组成的整数的总和。\n    \n    函数遍历输入字符串，识别连续的数值字符序列，将每个序列转换为整数后累加。\n    非数字字符作为数值序列的分隔符。\n    \n    示例:\n        >>> sum_numbers_in_string(\"abc123def45gh6\")\n        174  # 123 + 45 + 6\n    \n    Args:\n        text: 可能包含数字和非数字字符的输入字符串。\n    \n    Returns:\n        字符串中所有连续数字序列的整数总和。\n    \n    Raises:\n        ValueError: 如果数字序列超过Python整数的表示范围。\n    \"\"\"\n    current_number_str = \"\"\n    total_sum = 0\n    \n    for character in text:\n        if character.isdigit():\n            current_number_str += character\n        else:\n            if current_number_str:\n                total_sum += int(current_number_str)\n                current_number_str = \"\"\n    \n    # 处理字符串末尾可能存在的数字序列\n    if current_number_str:\n        total_sum += int(current_number_str)\n    \n    return total_sum"}
{"origin_topic": "将字符串中的元音字母替换为*", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = \"\"\n    for c in b:\n        if c == 'a' or c == 'e' or c == 'i' or c == 'o' or c == 'u' or c == 'A' or c == 'E' or c == 'I' or c == 'O' or c == 'U':\n            x = x + '*'\n        else:\n            x = x + c\n    return x", "output": "def replace_vowels_with_asterisk(input_string: str) -> str:\n    \"\"\"Replaces all vowel characters (both uppercase and lowercase) with asterisks.\n    \n    Args:\n        input_string: The original string to process.\n    \n    Returns:\n        A new string where all vowels (a, e, i, o, u) in both cases are replaced by '*'.\n    \n    Examples:\n        >>> replace_vowels_with_asterisk(\"Hello World\")\n        'H*ll* W*rld'\n        >>> replace_vowels_with_asterisk(\"AEIOUaeiou\")\n        '**********'\n        >>> replace_vowels_with_asterisk(\"xyz\")\n        'xyz'\n    \"\"\"\n    VOWELS = set(\"aeiouAEIOU\")\n    result_chars = []\n    \n    for character in input_string:\n        if character in VOWELS:\n            result_chars.append('*')\n        else:\n            result_chars.append(character)\n    \n    return ''.join(result_chars)"}
{"origin_topic": "获取字典中所有的键", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def get_keys_from_dict(x):\n    result = []\n    for a in x:\n        b = a\n        result.append(b)\n    return result", "output": "from typing import Dict, List, Any\n\n\ndef get_dict_keys(input_dict: Dict[Any, Any]) -> List[Any]:\n    \"\"\"Extracts all keys from a dictionary and returns them as a list.\n    \n    Args:\n        input_dict: The dictionary from which to extract keys.\n        \n    Returns:\n        A list containing all keys from the input dictionary.\n        \n    Examples:\n        >>> get_dict_keys({'a': 1, 'b': 2})\n        ['a', 'b']\n        >>> get_dict_keys({})\n        []\n    \"\"\"\n    return list(input_dict.keys())"}
{"origin_topic": "检查一个字符串是否为有效的电子邮件格式（简化）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = False\n    if isinstance(a, str):\n        x = len(a)\n        if x > 0:\n            y = 0\n            for z in a:\n                if z == \"@\":\n                    y = y + 1\n            if y == 1:\n                p = a.split(\"@\")\n                q = p[0]\n                r = p[1]\n                if len(q) > 0 and len(r) > 0:\n                    if \".\" in r:\n                        b = True\n    return b", "output": "from typing import Union\n\n\ndef is_valid_email(email: Union[str, object]) -> bool:\n    \"\"\"验证字符串是否为有效的电子邮件地址格式。\n\n    基本验证规则：\n    1. 输入必须是字符串类型\n    2. 必须包含且仅包含一个 '@' 符号\n    3. '@' 符号前后都必须有内容\n    4. '@' 符号后必须包含 '.' 符号\n\n    Args:\n        email: 待验证的输入值\n\n    Returns:\n        True 如果输入是有效的电子邮件格式，否则 False\n\n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"invalid.email\")\n        False\n        >>> is_valid_email(123)\n        False\n    \"\"\"\n    # 类型检查\n    if not isinstance(email, str):\n        return False\n\n    # 长度检查\n    if len(email) == 0:\n        return False\n\n    # 检查 '@' 符号数量\n    at_symbol_count = email.count('@')\n    if at_symbol_count != 1:\n        return False\n\n    # 分割本地部分和域名部分\n    local_part, domain_part = email.split('@')\n\n    # 检查本地部分和域名部分是否为空\n    if len(local_part) == 0 or len(domain_part) == 0:\n        return False\n\n    # 检查域名部分是否包含点号\n    if '.' not in domain_part:\n        return False\n\n    return True"}
{"origin_topic": "统计一个文本文件中单词的数量（模拟给定字符串）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    c = b.split()\n    for d in c:\n        if d != '':\n            x = x + 1\n        else:\n            x = x + 0\n    return x", "output": "def count_non_empty_words(text: str) -> int:\n    \"\"\"Counts the number of non-empty words in a given string.\n\n    Words are defined as substrings separated by whitespace. Empty strings\n    resulting from consecutive whitespace or leading/trailing whitespace\n    are not counted.\n\n    Args:\n        text: The input string to analyze.\n\n    Returns:\n        The number of non-empty words in the input string.\n\n    Examples:\n        >>> count_non_empty_words(\"hello world\")\n        2\n        >>> count_non_empty_words(\"  hello   world  \")\n        2\n        >>> count_non_empty_words(\"\")\n        0\n    \"\"\"\n    if not text:\n        return 0\n    \n    words = text.split()\n    return len(words)"}
{"origin_topic": "计算字符串的字母数字字符数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    c = 0\n    for i in range(len(s)):\n        ch = s[i]\n        if (ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or (ch >= '0' and ch <= '9'):\n            c = c + 1\n        else:\n            c = c + 0\n    return c", "output": "def count_alphanumeric_characters(text: str) -> int:\n    \"\"\"Counts the number of alphanumeric characters in a string.\n    \n    Alphanumeric characters are defined as:\n    - Lowercase letters (a-z)\n    - Uppercase letters (A-Z)\n    - Digits (0-9)\n    \n    Args:\n        text: The input string to analyze.\n    \n    Returns:\n        The count of alphanumeric characters in the input string.\n    \n    Examples:\n        >>> count_alphanumeric_characters(\"Hello123!\")\n        8\n        >>> count_alphanumeric_characters(\"Test@2024\")\n        8\n        >>> count_alphanumeric_characters(\"\")\n        0\n    \"\"\"\n    count = 0\n    for character in text:\n        if character.isalnum():\n            count += 1\n    return count"}
{"origin_topic": "计算两个矩阵的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_matrix_sum(a, b):\n    result = []\n    for i in range(len(a)):\n        row = []\n        for j in range(len(a[0])):\n            x = a[i][j] + b[i][j]\n            row.append(x)\n        result.append(row)\n    return result", "output": "from typing import List, TypeVar\n\nMatrix = List[List[float]]\nT = TypeVar('T', int, float, complex)\n\n\ndef add_matrices(matrix_a: Matrix, matrix_b: Matrix) -> Matrix:\n    \"\"\"Adds two matrices element-wise.\n\n    Both input matrices must have identical dimensions. The function performs\n    element-wise addition, returning a new matrix where each element is the sum\n    of corresponding elements from the input matrices.\n\n    Args:\n        matrix_a: First matrix as a 2D list of numbers.\n        matrix_b: Second matrix as a 2D list of numbers.\n\n    Returns:\n        A new matrix where result[i][j] = matrix_a[i][j] + matrix_b[i][j].\n\n    Raises:\n        ValueError: If input matrices have different dimensions.\n        TypeError: If inputs are not valid 2D lists or contain non-numeric types.\n\n    Example:\n        >>> add_matrices([[1, 2], [3, 4]], [[5, 6], [7, 8]])\n        [[6, 8], [10, 12]]\n    \"\"\"\n    # Validate input dimensions\n    if len(matrix_a) != len(matrix_b):\n        raise ValueError(\n            f'Matrices must have same number of rows. '\n            f'Got {len(matrix_a)} and {len(matrix_b)}.'\n        )\n    \n    if not matrix_a or not matrix_b:\n        return []\n    \n    rows = len(matrix_a)\n    cols = len(matrix_a[0])\n    \n    # Validate column consistency\n    if any(len(row) != cols for row in matrix_a):\n        raise ValueError('matrix_a has inconsistent column counts.')\n    \n    if any(len(row) != len(matrix_b[0]) for row in matrix_b):\n        raise ValueError('matrix_b has inconsistent column counts.')\n    \n    if cols != len(matrix_b[0]):\n        raise ValueError(\n            f'Matrices must have same number of columns. '\n            f'Got {cols} and {len(matrix_b[0])}.'\n        )\n    \n    # Perform element-wise addition\n    result_matrix: Matrix = []\n    for row_index in range(rows):\n        result_row: List[T] = []\n        for col_index in range(cols):\n            try:\n                sum_value = matrix_a[row_index][col_index] + matrix_b[row_index][col_index]\n                result_row.append(sum_value)\n            except (TypeError, IndexError) as e:\n                raise TypeError(\n                    f'Invalid matrix elements at position [{row_index}][{col_index}]: {e}'\n                )\n        result_matrix.append(result_row)\n    \n    return result_matrix"}
{"origin_topic": "找出一个字符串中最长的单词", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split()\n    d = 0\n    e = \"\"\n    for f in c:\n        g = len(f)\n        if g > d:\n            d = g\n            e = f\n    return e", "output": "def find_longest_word(text: str) -> str:\n    \"\"\"Finds and returns the longest word in a given text string.\n    \n    Words are defined as sequences of characters separated by whitespace.\n    If multiple words share the maximum length, returns the first occurrence.\n    \n    Args:\n        text: The input string to search for the longest word.\n        \n    Returns:\n        The longest word found in the input text.\n        \n    Examples:\n        >>> find_longest_word(\"The quick brown fox jumps\")\n        'quick'\n        >>> find_longest_word(\"Hello world\")\n        'Hello'\n    \"\"\"\n    words = text.split()\n    \n    if not words:\n        return \"\"\n    \n    longest_word = words[0]\n    max_length = len(longest_word)\n    \n    for word in words[1:]:\n        current_length = len(word)\n        if current_length > max_length:\n            max_length = current_length\n            longest_word = word\n            \n    return longest_word"}
{"origin_topic": "统计一段文本中每个单词的出现频率", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    d = {}\n    w = ''\n    for c in s:\n        if c.isalpha():\n            w = w + c\n        else:\n            if w:\n                if w in d:\n                    d[w] = d[w] + 1\n                else:\n                    d[w] = 1\n                w = ''\n    if w:\n        if w in d:\n            d[w] = d[w] + 1\n        else:\n            d[w] = 1\n    return d", "output": "from typing import Dict\n\n\ndef count_words(text: str) -> Dict[str, int]:\n    \"\"\"统计文本中单词的出现频率。\n    \n    该函数遍历输入字符串，识别连续的字母字符作为单词，\n    忽略非字母字符，并返回每个单词出现次数的字典。\n    \n    Args:\n        text: 需要统计单词频率的输入字符串。\n    \n    Returns:\n        一个字典，键为单词（字符串），值为该单词出现的次数（整数）。\n    \n    Examples:\n        >>> count_words(\"hello world! hello everyone.\")\n        {'hello': 2, 'world': 1, 'everyone': 1}\n    \"\"\"\n    word_counts: Dict[str, int] = {}\n    current_word: str = ''\n    \n    for character in text:\n        if character.isalpha():\n            current_word += character\n        else:\n            if current_word:\n                word_counts[current_word] = word_counts.get(current_word, 0) + 1\n                current_word = ''\n    \n    # 处理文本末尾可能存在的单词\n    if current_word:\n        word_counts[current_word] = word_counts.get(current_word, 0) + 1\n    \n    return word_counts"}
{"origin_topic": "将时间从秒转换为分钟和秒", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_time(a):\n    b = a // 60\n    x = a % 60\n    if b == 0:\n        if x == 0:\n            return \"0分钟0秒\"\n        else:\n            return \"0分钟\" + str(x) + \"秒\"\n    else:\n        if x == 0:\n            return str(b) + \"分钟0秒\"\n        else:\n            return str(b) + \"分钟\" + str(x) + \"秒\"", "output": "def convert_seconds_to_minutes_and_seconds(total_seconds: int) -> str:\n    \"\"\"将总秒数转换为分钟和秒的字符串表示。\n    \n    例如：\n        65 -> \"1分钟5秒\"\n        120 -> \"2分钟0秒\"\n        0 -> \"0分钟0秒\"\n    \n    Args:\n        total_seconds: 需要转换的总秒数（非负整数）\n    \n    Returns:\n        格式为\"{minutes}分钟{seconds}秒\"的字符串\n    \n    Raises:\n        ValueError: 如果输入为负数\n    \"\"\"\n    if total_seconds < 0:\n        raise ValueError(\"输入秒数不能为负数\")\n    \n    minutes = total_seconds // 60\n    seconds = total_seconds % 60\n    \n    return f\"{minutes}分钟{seconds}秒\""}
{"origin_topic": "移除字符串中的所有标点符号", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x.isalpha() or x.isdigit() or x == \" \":\n            b = b + x\n        else:\n            continue\n    return b", "output": "def filter_alphanumeric_and_spaces(input_string: str) -> str:\n    \"\"\"Filters a string to keep only alphanumeric characters and spaces.\n\n    This function iterates through each character in the input string and\n    retains only those that are either letters (a-z, A-Z), digits (0-9),\n    or space characters. All other characters (punctuation, symbols, etc.)\n    are removed.\n\n    Args:\n        input_string: The string to be filtered.\n\n    Returns:\n        A new string containing only alphanumeric characters and spaces\n        from the input string.\n\n    Examples:\n        >>> filter_alphanumeric_and_spaces(\"Hello, World! 123\")\n        'Hello World 123'\n        >>> filter_alphanumeric_and_spaces(\"Email: test@example.com\")\n        'Email testexamplecom'\n    \"\"\"\n    filtered_chars = []\n    for char in input_string:\n        if char.isalnum() or char == \" \":\n            filtered_chars.append(char)\n    return \"\".join(filtered_chars)"}
{"origin_topic": "计算一个数字的平方根（使用牛顿法）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def compute_square_root(number):\n    if number < 0:\n        return None\n    if number == 0:\n        return 0\n    a = number\n    b = number / 2.0\n    while True:\n        x = b\n        b = (x + a / x) / 2.0\n        if abs(x - b) < 1e-10:\n            break\n    return b", "output": "\"\"\"Square root calculation using Newton's method.\"\"\"\n\nfrom typing import Optional\n\n\ndef compute_square_root(number: float) -> Optional[float]:\n    \"\"\"Calculate the square root of a non-negative number using Newton's method.\n    \n    Args:\n        number: The number to compute the square root for. Must be non-negative.\n        \n    Returns:\n        The square root of the number, or None if the input is negative.\n        \n    Raises:\n        ValueError: If the input is negative (alternative to returning None).\n        \n    Examples:\n        >>> compute_square_root(4.0)\n        2.0\n        >>> compute_square_root(0.0)\n        0.0\n        >>> compute_square_root(-1.0)\n        None\n    \"\"\"\n    if number < 0:\n        return None\n    \n    if number == 0:\n        return 0.0\n    \n    # Newton's method for square root approximation\n    current_approximation = number / 2.0\n    previous_approximation: float\n    tolerance = 1e-10\n    \n    while True:\n        previous_approximation = current_approximation\n        current_approximation = (\n            previous_approximation + number / previous_approximation\n        ) / 2.0\n        \n        if abs(previous_approximation - current_approximation) < tolerance:\n            break\n    \n    return current_approximation"}
{"origin_topic": "移除字符串中的空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x != \" \":\n            b = b + x\n        else:\n            b = b\n    return b", "output": "def remove_spaces(input_string: str) -> str:\n    \"\"\"Removes all space characters from the input string.\n    \n    Args:\n        input_string: The string from which spaces will be removed.\n        \n    Returns:\n        A new string with all space characters removed.\n        \n    Examples:\n        >>> remove_spaces(\"hello world\")\n        'helloworld'\n        >>> remove_spaces(\"  test  string  \")\n        'teststring'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character != \" \":\n            result += character\n    return result"}
{"origin_topic": "计算字符串中每个字符的ASCII值之和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = 0\n    for d in b:\n        e = ord(d)\n        c = c + e\n    return c", "output": "def calculate_character_sum(text: str) -> int:\n    \"\"\"计算字符串中所有字符的Unicode码点之和。\n\n    该函数遍历输入字符串中的每个字符，将其转换为对应的Unicode码点值，\n    并累加所有码点值返回总和。\n\n    Args:\n        text: 需要计算字符码点和的输入字符串。\n\n    Returns:\n        字符串中所有字符Unicode码点值的总和。\n\n    Examples:\n        >>> calculate_character_sum(\"abc\")\n        294  # 97 + 98 + 99 = 294\n        >>> calculate_character_sum(\"\")\n        0\n    \"\"\"\n    total_sum = 0\n    for character in text:\n        code_point = ord(character)\n        total_sum += code_point\n    return total_sum"}
{"origin_topic": "计算斐波那契数列的前N项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    else:\n        a = 0\n        b = 1\n        x = [a, b]\n        for i in range(2, n):\n            c = a + b\n            x.append(c)\n            a = b\n            b = c\n        return x", "output": "from typing import List\n\n\ndef generate_fibonacci_sequence(length: int) -> List[int]:\n    \"\"\"生成指定长度的斐波那契数列。\n    \n    斐波那契数列定义：\n    F(0) = 0\n    F(1) = 1\n    F(n) = F(n-1) + F(n-2) (n ≥ 2)\n    \n    Args:\n        length: 需要生成的斐波那契数列长度，必须为非负整数。\n        \n    Returns:\n        包含指定长度斐波那契数列的列表。\n        如果length为0，返回空列表。\n        如果length为1，返回[0]。\n        如果length≥2，返回[0, 1, ...]。\n        \n    Raises:\n        ValueError: 如果length为负数。\n    \"\"\"\n    if length < 0:\n        raise ValueError(f\"长度不能为负数，当前值: {length}\")\n    \n    if length == 0:\n        return []\n    \n    if length == 1:\n        return [0]\n    \n    # 初始化前两个斐波那契数\n    fibonacci_sequence = [0, 1]\n    \n    # 如果只需要前两个数，直接返回\n    if length == 2:\n        return fibonacci_sequence\n    \n    # 计算剩余的斐波那契数\n    previous, current = 0, 1\n    for _ in range(2, length):\n        next_value = previous + current\n        fibonacci_sequence.append(next_value)\n        previous, current = current, next_value\n    \n    return fibonacci_sequence"}
{"origin_topic": "将字符串转换为摩斯电码", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---',\n        'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-',\n        'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',\n        '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',\n        '6': '-....', '7': '--...', '8': '---..', '9': '----.',\n        ' ': ' '\n    }\n    d = ''\n    e = b.upper()\n    for f in e:\n        if f in c:\n            g = c[f]\n            d = d + g\n            if f != ' ':\n                d = d + ' '\n        else:\n            h = ''\n            d = d + h\n    i = d.strip()\n    return i", "output": "from typing import Dict, Optional\n\n\ndef text_to_morse(text: str) -> str:\n    \"\"\"Converts alphanumeric text to Morse code representation.\n    \n    Args:\n        text: Input string containing letters, numbers, and spaces.\n              Non-alphanumeric characters are ignored.\n    \n    Returns:\n        Morse code representation of the input text with single spaces\n        between characters and no trailing spaces.\n    \n    Example:\n        >>> text_to_morse(\"Hello World\")\n        '.... . .-.. .-.. ---   .-- --- .-. .-.. -..'\n    \"\"\"\n    # International Morse code mapping\n    MORSE_CODE_MAP: Dict[str, str] = {\n        # Letters\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', \n        'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---',\n        'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', \n        'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-',\n        'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', \n        'Z': '--..',\n        # Numbers\n        '0': '-----', '1': '.----', '2': '..---', '3': '...--', \n        '4': '....-', '5': '.....', '6': '-....', '7': '--...', \n        '8': '---..', '9': '----.',\n        # Space (special handling)\n        ' ': ' '\n    }\n    \n    morse_result_parts: list[str] = []\n    normalized_text: str = text.upper()\n    \n    for character in normalized_text:\n        morse_code: Optional[str] = MORSE_CODE_MAP.get(character)\n        \n        if morse_code is not None:\n            morse_result_parts.append(morse_code)\n            # Add space between characters (but not after a word space)\n            if character != ' ':\n                morse_result_parts.append(' ')\n    \n    # Join all parts and remove trailing space\n    morse_result: str = ''.join(morse_result_parts).rstrip()\n    return morse_result"}
{"origin_topic": "检查一个数字是否为阿姆斯特朗数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_number(num):\n    if isinstance(num, int) and num >= 0:\n        temp = num\n        length = 0\n        while temp > 0:\n            temp = temp // 10\n            length = length + 1\n        temp = num\n        result = 0\n        while temp > 0:\n            digit = temp % 10\n            product = 1\n            for i in range(length):\n                product = product * digit\n            result = result + product\n            temp = temp // 10\n        if result == num:\n            return True\n        else:\n            return False\n    else:\n        return False", "output": "def is_armstrong_number(number: int) -> bool:\n    \"\"\"Check if a given integer is an Armstrong (Narcissistic) number.\n    \n    An Armstrong number is a number that is equal to the sum of its own digits\n    each raised to the power of the number of digits.\n    \n    Args:\n        number: The integer to check. Must be non-negative.\n        \n    Returns:\n        True if the number is an Armstrong number, False otherwise.\n        Returns False for negative numbers or non-integer inputs.\n        \n    Examples:\n        >>> is_armstrong_number(153)\n        True  # 1³ + 5³ + 3³ = 153\n        >>> is_armstrong_number(9474)\n        True  # 9⁴ + 4⁴ + 7⁴ + 4⁴ = 9474\n        >>> is_armstrong_number(123)\n        False\n    \"\"\"\n    if not isinstance(number, int) or number < 0:\n        return False\n    \n    if number == 0:\n        return True  # 0 is considered an Armstrong number (0¹ = 0)\n    \n    # Calculate number of digits\n    digit_count = 0\n    temp_number = number\n    while temp_number > 0:\n        temp_number //= 10\n        digit_count += 1\n    \n    # Calculate sum of digits raised to the power of digit_count\n    temp_number = number\n    armstrong_sum = 0\n    \n    while temp_number > 0:\n        digit = temp_number % 10\n        armstrong_sum += digit ** digit_count\n        temp_number //= 10\n    \n    return armstrong_sum == number"}
{"origin_topic": "计算一个句子中的平均单词长度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    if not s:\n        return 0\n    a = []\n    b = ''\n    for x in s:\n        if x.isalpha():\n            b = b + x\n        else:\n            if b:\n                a.append(b)\n                b = ''\n    if b:\n        a.append(b)\n    if not a:\n        return 0\n    c = 0\n    for d in a:\n        c = c + len(d)\n    e = c / len(a)\n    return e", "output": "from typing import List\n\n\ndef calculate_average_word_length(text: str) -> float:\n    \"\"\"计算字符串中单词的平均长度。\n    \n    单词定义为连续的字母字符序列，非字母字符作为分隔符。\n    忽略空字符串和纯非字母字符串。\n    \n    Args:\n        text: 输入字符串，可能包含字母和非字母字符\n        \n    Returns:\n        单词的平均长度。如果输入为空或没有有效单词，返回0.0\n        \n    Examples:\n        >>> calculate_average_word_length(\"Hello world!\")\n        5.0\n        >>> calculate_average_word_length(\"Python 3.9 is awesome\")\n        4.8\n        >>> calculate_average_word_length(\"123!@#\")\n        0.0\n        >>> calculate_average_word_length(\"\")\n        0.0\n    \"\"\"\n    if not text:\n        return 0.0\n    \n    words: List[str] = []\n    current_word: str = ''\n    \n    # 提取所有单词\n    for character in text:\n        if character.isalpha():\n            current_word += character\n        else:\n            if current_word:\n                words.append(current_word)\n                current_word = ''\n    \n    # 处理末尾可能存在的单词\n    if current_word:\n        words.append(current_word)\n    \n    # 如果没有找到有效单词，返回0\n    if not words:\n        return 0.0\n    \n    # 计算总长度和平均长度\n    total_length: int = sum(len(word) for word in words)\n    average_length: float = total_length / len(words)\n    \n    return average_length"}
{"origin_topic": "判断一个字符串是否以元音字母开头", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string_start(input_string):\n    if len(input_string) > 0:\n        first_char = input_string[0].lower()\n        vowels = ['a', 'e', 'i', 'o', 'u']\n        result = False\n        for vowel in vowels:\n            if first_char == vowel:\n                result = True\n                break\n        return result\n    else:\n        return False", "output": "from typing import List\n\n\ndef starts_with_vowel(text: str) -> bool:\n    \"\"\"Checks if the given string starts with a vowel (case-insensitive).\n\n    Args:\n        text: The input string to check.\n\n    Returns:\n        True if the string starts with a vowel (a, e, i, o, u), False otherwise.\n        Returns False for empty strings.\n\n    Examples:\n        >>> starts_with_vowel(\"apple\")\n        True\n        >>> starts_with_vowel(\"Banana\")\n        False\n        >>> starts_with_vowel(\"\")\n        False\n        >>> starts_with_vowel(\"orange\")\n        True\n    \"\"\"\n    if not text:\n        return False\n\n    first_character: str = text[0].lower()\n    vowels: List[str] = ['a', 'e', 'i', 'o', 'u']\n    \n    return first_character in vowels"}
{"origin_topic": "将字符串中每个单词的首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b.split()\n    for e in d:\n        f = \"\"\n        for g in range(len(e)):\n            if g == 0:\n                h = e[g].upper()\n                f = f + h\n            else:\n                i = e[g].lower()\n                f = f + i\n        c.append(f)\n    j = \" \".join(c)\n    return j", "output": "def format_title_case(text: str) -> str:\n    \"\"\"Convert a string to title case format.\n\n    This function takes a string input and converts it to title case format,\n    where each word starts with an uppercase letter and all other characters\n    are lowercase. Words are separated by whitespace.\n\n    Args:\n        text: The input string to be converted to title case.\n\n    Returns:\n        A string in title case format.\n\n    Examples:\n        >>> format_title_case(\"hello world\")\n        'Hello World'\n        >>> format_title_case(\"tEsT sTrInG\")\n        'Test String'\n        >>> format_title_case(\"\")\n        ''\n    \"\"\"\n    if not text:\n        return \"\"\n\n    words = text.split()\n    formatted_words = []\n\n    for word in words:\n        if not word:\n            formatted_words.append(\"\")\n            continue\n\n        # Capitalize first character and lowercase the rest\n        formatted_word = word[0].upper() + word[1:].lower()\n        formatted_words.append(formatted_word)\n\n    return \" \".join(formatted_words)"}
{"origin_topic": "计算数字的平方根（使用牛顿法近似）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b\n    if c == 0:\n        return 0\n    d = c / 2.0\n    e = 0\n    while True:\n        f = d\n        g = (f + c / f) / 2.0\n        h = abs(g - f)\n        if h < 0.00001:\n            return g\n        d = g\n        e = e + 1\n        if e > 1000:\n            return g", "output": "\"\"\"Newton-Raphson method for square root approximation.\"\"\"\n\nfrom typing import Optional\n\n\ndef newton_sqrt(number: float, tolerance: float = 1e-5, max_iterations: int = 1000) -> Optional[float]:\n    \"\"\"Calculate the square root of a number using the Newton-Raphson method.\n    \n    Args:\n        number: The number to calculate the square root of. Must be non-negative.\n        tolerance: The acceptable error tolerance for convergence.\n        max_iterations: Maximum number of iterations before giving up.\n    \n    Returns:\n        The approximate square root of the number, or None if number is negative.\n    \n    Raises:\n        ValueError: If number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Cannot calculate square root of negative number\")\n    \n    if number == 0:\n        return 0.0\n    \n    # Initial guess: half of the input number\n    current_guess = number / 2.0\n    iteration_count = 0\n    \n    while True:\n        previous_guess = current_guess\n        # Newton-Raphson update formula for square root\n        current_guess = (previous_guess + number / previous_guess) / 2.0\n        \n        error = abs(current_guess - previous_guess)\n        \n        if error < tolerance:\n            return current_guess\n        \n        iteration_count += 1\n        \n        if iteration_count > max_iterations:\n            # Return best estimate even if tolerance not met\n            return current_guess"}
{"origin_topic": "编写函数计算两个数字的最大公约数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_gcd_of_two_numbers(number_one, number_two):\n    if number_one == 0 and number_two == 0:\n        return 0\n    elif number_one == 0:\n        return abs(number_two)\n    elif number_two == 0:\n        return abs(number_one)\n    else:\n        temporary_variable_one = abs(number_one)\n        temporary_variable_two = abs(number_two)\n        while temporary_variable_two != 0:\n            temporary_variable_three = temporary_variable_two\n            temporary_variable_two = temporary_variable_one % temporary_variable_two\n            temporary_variable_one = temporary_variable_three\n        result_value = temporary_variable_one\n        return result_value", "output": "from typing import Union\n\n\ndef greatest_common_divisor(a: int, b: int) -> Union[int, None]:\n    \"\"\"Calculate the greatest common divisor of two integers.\n    \n    Uses the Euclidean algorithm to compute GCD. Handles edge cases including:\n    - Both numbers zero (returns 0)\n    - One number zero (returns absolute value of the other)\n    - Negative numbers (uses absolute values)\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        Greatest common divisor as a non-negative integer, or 0 if both inputs are 0.\n        \n    Examples:\n        >>> greatest_common_divisor(48, 18)\n        6\n        >>> greatest_common_divisor(-48, 18)\n        6\n        >>> greatest_common_divisor(0, 5)\n        5\n        >>> greatest_common_divisor(0, 0)\n        0\n    \"\"\"\n    if a == 0 and b == 0:\n        return 0\n    \n    if a == 0:\n        return abs(b)\n    \n    if b == 0:\n        return abs(a)\n    \n    # Use Euclidean algorithm with absolute values\n    x = abs(a)\n    y = abs(b)\n    \n    while y != 0:\n        remainder = x % y\n        x = y\n        y = remainder\n    \n    return x"}
{"origin_topic": "检查字符串是否只包含数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = True\n    for x in a:\n        if x not in \"0123456789\":\n            b = False\n            break\n    if b == True:\n        return True\n    else:\n        return False", "output": "from typing import Iterable\n\n\ndef contains_only_digits(input_string: str) -> bool:\n    \"\"\"检查字符串是否仅包含数字字符。\n\n    遍历输入字符串中的每个字符，检查其是否在数字字符集('0'-'9')中。\n    如果发现任何非数字字符，立即返回False；否则返回True。\n\n    Args:\n        input_string: 需要检查的字符串。\n\n    Returns:\n        bool: 如果字符串仅包含数字字符返回True，否则返回False。\n\n    Examples:\n        >>> contains_only_digits(\"12345\")\n        True\n        >>> contains_only_digits(\"12a45\")\n        False\n        >>> contains_only_digits(\"\")\n        True\n    \"\"\"\n    for character in input_string:\n        if character not in \"0123456789\":\n            return False\n    return True"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件格式（简单版）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(s):\n    if not isinstance(s, str):\n        return False\n    if len(s) == 0:\n        return False\n    parts = s.split('@')\n    if len(parts) != 2:\n        return False\n    left_part = parts[0]\n    right_part = parts[1]\n    if len(left_part) == 0:\n        return False\n    if len(right_part) == 0:\n        return False\n    if '.' not in right_part:\n        return False\n    dot_parts = right_part.split('.')\n    if len(dot_parts) < 2:\n        return False\n    for segment in dot_parts:\n        if len(segment) == 0:\n            return False\n    return True", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Union\n\n\ndef validate_email_format(email_address: Union[str, bytes]) -> bool:\n    \"\"\"Validates if a string conforms to basic email format requirements.\n    \n    This function performs basic structural validation of email addresses.\n    It checks for the presence of '@' symbol, non-empty local and domain parts,\n    and ensures the domain contains at least one dot with non-empty segments.\n    \n    Note: This is a basic validation and does not check RFC compliance,\n          DNS records, or special email address formats.\n    \n    Args:\n        email_address: The email address to validate. Can be string or bytes.\n    \n    Returns:\n        True if the email address meets basic format requirements, False otherwise.\n    \n    Examples:\n        >>> validate_email_format('user@example.com')\n        True\n        >>> validate_email_format('invalid.email')\n        False\n        >>> validate_email_format('')\n        False\n    \"\"\"\n    # Handle bytes input by converting to string\n    if isinstance(email_address, bytes):\n        email_address = email_address.decode('utf-8', errors='ignore')\n    \n    # Type check - must be string after potential bytes conversion\n    if not isinstance(email_address, str):\n        return False\n    \n    # Empty string check\n    if not email_address:\n        return False\n    \n    # Split into local and domain parts\n    email_parts = email_address.split('@')\n    \n    # Must have exactly one '@' symbol\n    if len(email_parts) != 2:\n        return False\n    \n    local_part, domain_part = email_parts\n    \n    # Both parts must be non-empty\n    if not local_part or not domain_part:\n        return False\n    \n    # Domain must contain at least one dot\n    if '.' not in domain_part:\n        return False\n    \n    # Split domain by dots and validate each segment\n    domain_segments = domain_part.split('.')\n    \n    # Must have at least two segments (e.g., 'example.com')\n    if len(domain_segments) < 2:\n        return False\n    \n    # Each domain segment must be non-empty\n    for segment in domain_segments:\n        if not segment:\n            return False\n    \n    return True"}
{"origin_topic": "将字符串反转单词顺序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = ''\n    for x in s:\n        if x == ' ':\n            if b:\n                a.append(b)\n                b = ''\n        else:\n            b = b + x\n    if b:\n        a.append(b)\n    c = []\n    d = len(a) - 1\n    while d >= 0:\n        c.append(a[d])\n        d = d - 1\n    e = ''\n    for y in range(len(c)):\n        e = e + c[y]\n        if y != len(c) - 1:\n            e = e + ' '\n    return e", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverses the order of words in a given sentence.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    Multiple spaces are treated as a single delimiter. Leading and trailing\n    spaces are ignored.\n    \n    Args:\n        sentence: The input string containing words to be reversed.\n        \n    Returns:\n        A new string with words in reverse order, separated by single spaces.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  multiple   spaces   between   words  \")\n        'words between spaces multiple'\n    \"\"\"\n    words = []\n    current_word = []\n    \n    # Extract words from the sentence\n    for char in sentence:\n        if char == ' ':\n            if current_word:\n                words.append(''.join(current_word))\n                current_word = []\n        else:\n            current_word.append(char)\n    \n    # Add the last word if present\n    if current_word:\n        words.append(''.join(current_word))\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join words with single spaces\n    return ' '.join(reversed_words)"}
{"origin_topic": "将字典按值进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(d):\n    result = []\n    for key in d:\n        result.append((key, d[key]))\n    for i in range(len(result)):\n        for j in range(len(result) - 1):\n            if result[j][1] > result[j + 1][1]:\n                temp = result[j]\n                result[j] = result[j + 1]\n                result[j + 1] = temp\n    final_output = {}\n    for item in result:\n        final_output[item[0]] = item[1]\n    return final_output", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')\nK = TypeVar('K')\nV = TypeVar('V')\n\n\ndef sort_dict_by_value(input_dict: Dict[K, V]) -> Dict[K, V]:\n    \"\"\"Sorts a dictionary by its values in ascending order.\n\n    This function takes a dictionary and returns a new dictionary with the same\n    key-value pairs, sorted by the values in ascending order. The original\n    dictionary remains unchanged.\n\n    Args:\n        input_dict: The dictionary to be sorted by values.\n\n    Returns:\n        A new dictionary containing the same key-value pairs as `input_dict`,\n        sorted by values in ascending order.\n\n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n\n    Note:\n        This implementation uses bubble sort which has O(n²) time complexity.\n        For production use with large dictionaries, consider using Python's\n        built-in `sorted()` function with `operator.itemgetter()`.\n    \"\"\"\n    # Convert dictionary items to a list of tuples\n    items = list(input_dict.items())\n    \n    # Sort items using bubble sort (preserving original algorithm structure)\n    for i in range(len(items)):\n        for j in range(len(items) - 1):\n            if items[j][1] > items[j + 1][1]:\n                # Swap adjacent elements\n                items[j], items[j + 1] = items[j + 1], items[j]\n    \n    # Convert sorted items back to dictionary\n    sorted_dict = dict(items)\n    \n    return sorted_dict"}
{"origin_topic": "验证一个电子邮件地址的格式是否有效", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if b.count('@') == 1:\n        y = b.split('@')\n        if len(y) == 2:\n            z = y[0]\n            w = y[1]\n            if z and w:\n                if '.' in w:\n                    v = w.split('.')\n                    if len(v) >= 2:\n                        for u in v:\n                            if u:\n                                continue\n                            else:\n                                return x\n                        x = True\n                    else:\n                        return x\n                else:\n                    return x\n            else:\n                return x\n        else:\n            return x\n    else:\n        return x\n    return x", "output": "def is_valid_email(email: str) -> bool:\n    \"\"\"验证字符串是否为有效的电子邮件地址格式。\n    \n    基本验证规则：\n    1. 必须包含且仅包含一个 '@' 符号\n    2. '@' 前后都必须有内容\n    3. 域名部分必须包含至少一个 '.'\n    4. '.' 分隔的每个部分都必须有内容\n    \n    Args:\n        email: 待验证的电子邮件地址字符串\n        \n    Returns:\n        bool: 如果符合基本电子邮件格式返回 True，否则返回 False\n        \n    Examples:\n        >>> is_valid_email('user@example.com')\n        True\n        >>> is_valid_email('user@.com')\n        False\n        >>> is_valid_email('@example.com')\n        False\n    \"\"\"\n    # 检查是否包含且仅包含一个 '@' 符号\n    if email.count('@') != 1:\n        return False\n    \n    # 分割本地部分和域名部分\n    parts = email.split('@')\n    if len(parts) != 2:\n        return False\n    \n    local_part, domain = parts\n    \n    # 检查本地部分和域名部分是否都非空\n    if not local_part or not domain:\n        return False\n    \n    # 检查域名是否包含点号\n    if '.' not in domain:\n        return False\n    \n    # 分割域名并检查每个部分是否非空\n    domain_parts = domain.split('.')\n    if len(domain_parts) < 2:\n        return False\n    \n    # 验证域名每个部分都非空\n    for part in domain_parts:\n        if not part:\n            return False\n    \n    return True"}
{"origin_topic": "找出字符串中的所有数字并计算平均值", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = 0\n    e = 0\n    f = \"\"\n    g = False\n    for h in b:\n        i = ord(h)\n        if i >= 48 and i <= 57:\n            f = f + h\n            g = True\n        else:\n            if g == True:\n                j = int(f)\n                c.append(j)\n                f = \"\"\n                g = False\n    if g == True:\n        k = int(f)\n        c.append(k)\n    if len(c) > 0:\n        for l in c:\n            d = d + l\n        m = d / len(c)\n        return m\n    else:\n        return 0", "output": "from typing import List, Union\n\n\ndef extract_and_average_numbers(text: str) -> float:\n    \"\"\"从字符串中提取所有连续数字并计算它们的平均值。\n    \n    函数遍历输入字符串，识别连续的数字字符序列，将它们转换为整数，\n    然后计算这些整数的平均值。如果字符串中没有数字，则返回0。\n    \n    Args:\n        text: 要处理的输入字符串\n        \n    Returns:\n        提取出的所有数字的平均值，如果没有数字则返回0.0\n        \n    Examples:\n        >>> extract_and_average_numbers(\"abc123def45gh6\")\n        58.0  # (123 + 45 + 6) / 3 = 58.0\n        \n        >>> extract_and_average_numbers(\"no numbers here\")\n        0.0\n    \"\"\"\n    numbers: List[int] = []\n    current_number_str = \"\"\n    is_building_number = False\n    \n    for char in text:\n        char_code = ord(char)\n        if 48 <= char_code <= 57:  # 数字字符 '0'-'9'\n            current_number_str += char\n            is_building_number = True\n        else:\n            if is_building_number:\n                numbers.append(int(current_number_str))\n                current_number_str = \"\"\n                is_building_number = False\n    \n    # 处理字符串末尾的数字\n    if is_building_number:\n        numbers.append(int(current_number_str))\n    \n    if not numbers:\n        return 0.0\n    \n    total_sum = sum(numbers)\n    average = total_sum / len(numbers)\n    return average"}
{"origin_topic": "实现一个简单的登录验证系统", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b, x):\n    c = []\n    for d in b:\n        c.append(d)\n    e = {}\n    for f in c:\n        g = f.split(\",\")\n        if len(g) == 2:\n            h = g[0]\n            i = g[1]\n            e[h] = i\n    j = input(\"请输入用户名:\")\n    k = input(\"请输入密码:\")\n    l = False\n    for m in e:\n        if m == j:\n            n = e[m]\n            if n == k:\n                l = True\n            else:\n                l = False\n        else:\n            l = False\n    if l == True:\n        return \"登录成功\"\n    else:\n        return \"登录失败\"", "output": "from typing import Dict, List, Optional\n\n\ndef authenticate_user(credentials_data: List[str], \n                      username: Optional[str] = None,\n                      password: Optional[str] = None) -> str:\n    \"\"\"\n    验证用户凭据是否与提供的凭证数据匹配。\n\n    该函数从给定的凭证数据列表中解析用户名-密码对，然后验证输入的用户名和密码\n    是否与任何存储的凭据匹配。\n\n    Args:\n        credentials_data: 包含逗号分隔的用户名-密码对的字符串列表\n        username: 要验证的用户名。如果为None，将通过标准输入提示用户输入\n        password: 要验证的密码。如果为None，将通过标准输入提示用户输入\n\n    Returns:\n        \"登录成功\" 如果凭据匹配，否则返回 \"登录失败\"\n\n    Example:\n        >>> credentials = [\"alice,secret123\", \"bob,password456\"]\n        >>> authenticate_user(credentials, \"alice\", \"secret123\")\n        '登录成功'\n    \"\"\"\n    \n    # 解析凭证数据为字典\n    credentials_dict: Dict[str, str] = {}\n    \n    for credential_entry in credentials_data:\n        # 分割每行凭证数据\n        credential_parts = credential_entry.split(\",\")\n        \n        # 只处理格式正确的凭证（用户名,密码）\n        if len(credential_parts) == 2:\n            username_from_data = credential_parts[0].strip()\n            password_from_data = credential_parts[1].strip()\n            credentials_dict[username_from_data] = password_from_data\n    \n    # 获取用户输入（如果未作为参数提供）\n    if username is None:\n        username = input(\"请输入用户名: \").strip()\n    \n    if password is None:\n        password = input(\"请输入密码: \").strip()\n    \n    # 验证凭据\n    is_authenticated = False\n    \n    # 检查用户名是否存在且密码匹配\n    if username in credentials_dict:\n        stored_password = credentials_dict[username]\n        is_authenticated = (stored_password == password)\n    \n    return \"登录成功\" if is_authenticated else \"登录失败\""}
{"origin_topic": "模拟一个简单的登录验证（用户名密码匹配）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b, x):\n    if b == \"admin\":\n        if x == \"123456\":\n            return True\n        else:\n            return False\n    else:\n        if b == \"user\":\n            if x == \"password\":\n                return True\n            else:\n                return False\n        else:\n            if b == \"guest\":\n                if x == \"guest\":\n                    return True\n                else:\n                    return False\n            else:\n                return False", "output": "from typing import Union\n\n\ndef authenticate_user(user_role: str, password: str) -> bool:\n    \"\"\"验证用户凭据是否有效。\n\n    根据用户角色验证对应的密码是否正确。\n\n    Args:\n        user_role: 用户角色，支持 'admin'、'user'、'guest'\n        password: 用户输入的密码\n\n    Returns:\n        bool: 验证结果，True表示验证成功，False表示验证失败\n\n    Examples:\n        >>> authenticate_user('admin', '123456')\n        True\n        >>> authenticate_user('user', 'wrong')\n        False\n        >>> authenticate_user('unknown', 'any')\n        False\n    \"\"\"\n    # 定义角色与对应密码的映射关系\n    role_password_map = {\n        'admin': '123456',\n        'user': 'password',\n        'guest': 'guest',\n    }\n    \n    # 检查用户角色是否存在，并验证密码\n    if user_role in role_password_map:\n        return role_password_map[user_role] == password\n    \n    return False"}
{"origin_topic": "对字典按值进行排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def sort_dict_by_value(input_dict):\n    result_list = []\n    for key_item in input_dict:\n        temp_pair = (key_item, input_dict[key_item])\n        result_list.append(temp_pair)\n    for i in range(len(result_list)):\n        for j in range(len(result_list) - 1):\n            if result_list[j][1] > result_list[j + 1][1]:\n                temporary_holder = result_list[j]\n                result_list[j] = result_list[j + 1]\n                result_list[j + 1] = temporary_holder\n    final_output_dict = {}\n    for pair in result_list:\n        final_output_dict[pair[0]] = pair[1]\n    return final_output_dict", "output": "from typing import Dict, Any, TypeVar\n\nT = TypeVar('T')  # Generic type for dictionary values\n\ndef sort_dict_by_value(input_dict: Dict[str, T]) -> Dict[str, T]:\n    \"\"\"Sorts a dictionary by its values in ascending order.\n    \n    This function creates a new dictionary with the same key-value pairs\n    as the input, but sorted by the values. The sorting is stable and\n    preserves the original order of items with equal values.\n    \n    Args:\n        input_dict: A dictionary to be sorted by values. Values must be\n            comparable (support the '>' operator).\n    \n    Returns:\n        A new dictionary with items sorted by values in ascending order.\n    \n    Raises:\n        TypeError: If dictionary values are not comparable.\n    \n    Example:\n        >>> sort_dict_by_value({'a': 3, 'b': 1, 'c': 2})\n        {'b': 1, 'c': 2, 'a': 3}\n    \"\"\"\n    # Convert dictionary items to list of (key, value) tuples\n    items = list(input_dict.items())\n    \n    # Sort items by value using Python's built-in sorted function\n    # This is more efficient and readable than bubble sort\n    sorted_items = sorted(items, key=lambda item: item[1])\n    \n    # Convert sorted items back to dictionary\n    # Python 3.7+ preserves insertion order, so the sorted order is maintained\n    sorted_dict = dict(sorted_items)\n    \n    return sorted_dict"}
{"origin_topic": "将句子中的单词按字母顺序排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split()\n    d = []\n    for e in c:\n        f = list(e)\n        g = []\n        for h in f:\n            g.append(h)\n        i = sorted(g)\n        j = ''.join(i)\n        d.append(j)\n    k = sorted(d)\n    l = ' '.join(k)\n    return l", "output": "def sort_letters_in_words(text: str) -> str:\n    \"\"\"Sort letters within each word and then sort the resulting words alphabetically.\n    \n    This function takes a string, splits it into words, sorts the letters within each word,\n    and then sorts the resulting words alphabetically before joining them back into a string.\n    \n    Args:\n        text: Input string containing words separated by spaces.\n        \n    Returns:\n        A string where each word's letters are sorted alphabetically, and all words\n        are sorted alphabetically and joined with spaces.\n        \n    Examples:\n        >>> sort_letters_in_words(\"hello world\")\n        'ehllo dlorw'\n        >>> sort_letters_in_words(\"python code\")\n        'hnopty cdeo'\n    \"\"\"\n    words = text.split()\n    sorted_words = []\n    \n    for word in words:\n        # Convert word to list of characters, sort them, and join back\n        sorted_letters = sorted(list(word))\n        sorted_word = ''.join(sorted_letters)\n        sorted_words.append(sorted_word)\n    \n    # Sort all the transformed words alphabetically\n    alphabetically_sorted_words = sorted(sorted_words)\n    \n    # Join the sorted words back into a single string\n    result = ' '.join(alphabetically_sorted_words)\n    \n    return result"}
{"origin_topic": "将字符串的首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    if b == \"\":\n        return \"\"\n    x = list(b)\n    y = x[0]\n    z = y.upper()\n    x[0] = z\n    result = \"\"\n    for i in x:\n        result = result + i\n    return result", "output": "def capitalize_first_character(input_string: str) -> str:\n    \"\"\"Capitalizes the first character of a string.\n\n    Args:\n        input_string: The string to process. If empty, returns an empty string.\n\n    Returns:\n        The input string with its first character converted to uppercase.\n        Returns an empty string if input is empty.\n\n    Examples:\n        >>> capitalize_first_character(\"hello\")\n        'Hello'\n        >>> capitalize_first_character(\"\")\n        ''\n        >>> capitalize_first_character(\"world\")\n        'World'\n    \"\"\"\n    if not input_string:\n        return \"\"\n\n    characters = list(input_string)\n    first_character = characters[0]\n    capitalized_first_character = first_character.upper()\n    characters[0] = capitalized_first_character\n    \n    return \"\".join(characters)"}
{"origin_topic": "将字符串按单词分割并排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = 0\n    y = \"\"\n    while x < len(a):\n        if a[x] != \" \":\n            y = y + a[x]\n        else:\n            if y != \"\":\n                b.append(y)\n                y = \"\"\n        x = x + 1\n    if y != \"\":\n        b.append(y)\n    for i in range(len(b)):\n        for j in range(len(b) - 1):\n            if b[j] > b[j + 1]:\n                t = b[j]\n                b[j] = b[j + 1]\n                b[j + 1] = t\n    return b", "output": "from typing import List\n\n\ndef tokenize_and_sort_string(input_string: str) -> List[str]:\n    \"\"\"Tokenizes a string by spaces and returns sorted tokens.\n    \n    Splits the input string into tokens using space as delimiter, removes empty\n    tokens, and returns the tokens sorted in ascending order using bubble sort.\n    \n    Args:\n        input_string: The string to be tokenized and sorted.\n        \n    Returns:\n        A list of non-empty tokens sorted in ascending order.\n        \n    Examples:\n        >>> tokenize_and_sort_string(\"hello world python\")\n        ['hello', 'python', 'world']\n        \n        >>> tokenize_and_sort_string(\"  apple  banana   cherry  \")\n        ['apple', 'banana', 'cherry']\n    \"\"\"\n    tokens: List[str] = []\n    current_token: str = \"\"\n    \n    # Tokenize the string\n    for character in input_string:\n        if character != \" \":\n            current_token += character\n        else:\n            if current_token:\n                tokens.append(current_token)\n                current_token = \"\"\n    \n    # Add the last token if it exists\n    if current_token:\n        tokens.append(current_token)\n    \n    # Sort tokens using bubble sort\n    token_count = len(tokens)\n    for i in range(token_count):\n        for j in range(token_count - 1):\n            if tokens[j] > tokens[j + 1]:\n                # Swap tokens\n                tokens[j], tokens[j + 1] = tokens[j + 1], tokens[j]\n    \n    return tokens"}
{"origin_topic": "将阿拉伯数字转换为罗马数字（1-1000）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_number_to_roman_numeral(input_value):\n    if input_value < 1 or input_value > 1000:\n        return \"\"\n\n    roman_symbols_list = [\n        (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n        (\"C\", 100), (\"XC\", 90), (\"L\", 50), (\"XL\", 40),\n        (\"X\", 10), (\"IX\", 9), (\"V\", 5), (\"IV\", 4), (\"I\", 1)\n    ]\n\n    current_value = input_value\n    result_string = \"\"\n\n    for symbol_pair in roman_symbols_list:\n        roman_char = symbol_pair[0]\n        numeric_value = symbol_pair[1]\n\n        while current_value >= numeric_value:\n            result_string = result_string + roman_char\n            current_value = current_value - numeric_value\n\n    return result_string", "output": "def convert_number_to_roman_numeral(number: int) -> str:\n    \"\"\"Converts an integer to its Roman numeral representation.\n\n    Args:\n        number: An integer between 1 and 1000 (inclusive) to convert.\n\n    Returns:\n        The Roman numeral string representation of the input number.\n        Returns an empty string if the input is outside the valid range.\n\n    Raises:\n        TypeError: If the input is not an integer.\n    \"\"\"\n    if not isinstance(number, int):\n        raise TypeError(f\"Input must be an integer, got {type(number).__name__}\")\n\n    if number < 1 or number > 1000:\n        return \"\"\n\n    roman_numerals = [\n        (\"M\", 1000),\n        (\"CM\", 900),\n        (\"D\", 500),\n        (\"CD\", 400),\n        (\"C\", 100),\n        (\"XC\", 90),\n        (\"L\", 50),\n        (\"XL\", 40),\n        (\"X\", 10),\n        (\"IX\", 9),\n        (\"V\", 5),\n        (\"IV\", 4),\n        (\"I\", 1),\n    ]\n\n    remaining_value = number\n    result = []\n\n    for numeral, value in roman_numerals:\n        while remaining_value >= value:\n            result.append(numeral)\n            remaining_value -= value\n\n    return \"\".join(result)"}
{"origin_topic": "将两个字典合并，如果有重复键则值相加", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def merge_dicts(a, b):\n    result = {}\n    for key in a:\n        if key in result:\n            result[key] = result[key] + a[key]\n        else:\n            result[key] = a[key]\n    for key in b:\n        if key in result:\n            result[key] = result[key] + b[key]\n        else:\n            result[key] = b[key]\n    return result", "output": "from typing import Dict, TypeVar\n\nT = TypeVar('T', int, float, str, list, dict)  # 支持常见可合并类型\n\ndef merge_dicts_with_addition(\n    dict_a: Dict[str, T], \n    dict_b: Dict[str, T]\n) -> Dict[str, T]:\n    \"\"\"\n    合并两个字典，对相同键的值执行加法操作。\n    \n    此函数将两个字典合并为一个新字典。如果键在两个字典中都存在，\n    则对应的值会相加；如果键只存在于一个字典中，则直接复制到结果中。\n    \n    注意：此函数假设值类型支持加法操作（如数字、字符串、列表等）。\n    \n    Args:\n        dict_a: 第一个输入字典\n        dict_b: 第二个输入字典\n    \n    Returns:\n        合并后的新字典，包含两个输入字典的所有键值对，\n        相同键的值已相加。\n    \n    Examples:\n        >>> merge_dicts_with_addition({'a': 1, 'b': 2}, {'a': 3, 'c': 4})\n        {'a': 4, 'b': 2, 'c': 4}\n        \n        >>> merge_dicts_with_addition({'x': 'hello'}, {'x': ' world'})\n        {'x': 'hello world'}\n    \n    Raises:\n        TypeError: 如果相同键的值类型不支持加法操作\n    \"\"\"\n    merged_result: Dict[str, T] = {}\n    \n    # 处理第一个字典的所有键值对\n    for key, value in dict_a.items():\n        merged_result[key] = value\n    \n    # 处理第二个字典，对相同键的值执行加法\n    for key, value in dict_b.items():\n        if key in merged_result:\n            try:\n                merged_result[key] = merged_result[key] + value\n            except TypeError as e:\n                raise TypeError(\n                    f\"Values for key '{key}' cannot be added: \"\n                    f\"{type(merged_result[key])} + {type(value)}\"\n                ) from e\n        else:\n            merged_result[key] = value\n    \n    return merged_result"}
{"origin_topic": "验证邮箱地址的简单格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if b is not None:\n        if isinstance(b, str):\n            if len(b) > 0:\n                if '@' in b:\n                    parts = b.split('@')\n                    if len(parts) == 2:\n                        if len(parts[0]) > 0:\n                            if len(parts[1]) > 0:\n                                if '.' in parts[1]:\n                                    more_parts = parts[1].split('.')\n                                    if len(more_parts) >= 2:\n                                        for p in more_parts:\n                                            if len(p) == 0:\n                                                x = False\n                                                break\n                                        else:\n                                            x = True\n    return x", "output": "from typing import Optional\n\n\ndef is_valid_email(email: Optional[str]) -> bool:\n    \"\"\"验证给定的字符串是否为有效的电子邮件地址格式。\n    \n    基本验证规则：\n    1. 输入不能为None\n    2. 必须包含且仅包含一个'@'符号\n    3. '@'前必须有内容（本地部分）\n    4. '@'后必须有内容（域名部分）\n    5. 域名部分必须包含至少一个'.'符号\n    6. 域名部分每个由'.'分隔的段都不能为空\n    \n    Args:\n        email: 待验证的电子邮件地址字符串，可为None\n        \n    Returns:\n        bool: 如果输入是有效的电子邮件地址格式则返回True，否则返回False\n        \n    Examples:\n        >>> is_valid_email(\"user@example.com\")\n        True\n        >>> is_valid_email(\"user@com\")\n        False\n        >>> is_valid_email(None)\n        False\n        >>> is_valid_email(\"\")\n        False\n    \"\"\"\n    # 基础检查：输入不能为None\n    if email is None:\n        return False\n    \n    # 检查是否为字符串类型\n    if not isinstance(email, str):\n        return False\n    \n    # 检查字符串长度\n    if len(email) == 0:\n        return False\n    \n    # 检查是否包含'@'符号\n    if '@' not in email:\n        return False\n    \n    # 分割本地部分和域名部分\n    local_part, domain_part = email.split('@', 1)\n    \n    # 检查是否只有一个'@'符号\n    if len(local_part) == 0 or len(domain_part) == 0:\n        return False\n    \n    # 检查域名部分是否包含'.'符号\n    if '.' not in domain_part:\n        return False\n    \n    # 分割域名部分并检查每个段\n    domain_segments = domain_part.split('.')\n    \n    # 域名部分必须至少有两个段（如example.com）\n    if len(domain_segments) < 2:\n        return False\n    \n    # 检查每个域名段是否非空\n    for segment in domain_segments:\n        if len(segment) == 0:\n            return False\n    \n    return True"}
{"origin_topic": "将一个字符串中的所有字母转换为大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        e = d\n        if e.isalpha():\n            f = e.upper()\n            c = c + f\n        else:\n            g = e\n            c = c + g\n    return c", "output": "def process_string(input_string: str) -> str:\n    \"\"\"Processes a string by converting all alphabetic characters to uppercase.\n    \n    This function iterates through each character in the input string, converts\n    alphabetic characters to uppercase, and leaves non-alphabetic characters\n    unchanged. The processed characters are concatenated to form the output string.\n    \n    Args:\n        input_string: The string to be processed.\n        \n    Returns:\n        A new string where all alphabetic characters are converted to uppercase\n        and non-alphabetic characters remain unchanged.\n        \n    Examples:\n        >>> process_string(\"Hello, World! 123\")\n        'HELLO, WORLD! 123'\n        >>> process_string(\"abc123def\")\n        'ABC123DEF'\n    \"\"\"\n    result_string = \"\"\n    \n    for character in input_string:\n        if character.isalpha():\n            processed_character = character.upper()\n        else:\n            processed_character = character\n        result_string += processed_character\n    \n    return result_string"}
{"origin_topic": "计算数字的各位数字之和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_sum_of_digits(number):\n    a = str(number)\n    b = 0\n    for x in a:\n        b = b + int(x)\n    return b", "output": "def calculate_sum_of_digits(number: int) -> int:\n    \"\"\"计算整数的各位数字之和。\n\n    该函数将整数转换为字符串，遍历每个字符（数字），\n    将其转换回整数并累加，最后返回总和。\n\n    Args:\n        number: 需要计算各位数字之和的整数。\n\n    Returns:\n        输入整数各位数字的总和。\n\n    Examples:\n        >>> calculate_sum_of_digits(123)\n        6\n        >>> calculate_sum_of_digits(9876)\n        30\n        >>> calculate_sum_of_digits(0)\n        0\n    \"\"\"\n    number_str = str(number)\n    digit_sum = 0\n    \n    for digit_char in number_str:\n        digit_sum += int(digit_char)\n    \n    return digit_sum"}
{"origin_topic": "检查一个字符串是否为有效的数字", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if b is not None:\n        if isinstance(b, str):\n            if b != \"\":\n                c = b.strip()\n                if c != \"\":\n                    d = c.lstrip('-')\n                    if d != \"\":\n                        e = d.replace('.', '', 1)\n                        if e != \"\":\n                            if e.isdigit():\n                                x = True\n                            else:\n                                x = False\n                        else:\n                            x = False\n                    else:\n                        x = False\n                else:\n                    x = False\n            else:\n                x = False\n        else:\n            x = False\n    else:\n        x = False\n    return x", "output": "\"\"\"Module for validating numeric string representations.\"\"\"\n\nfrom typing import Union\n\n\ndef is_valid_numeric_string(value: Union[str, None]) -> bool:\n    \"\"\"Check if a string represents a valid integer or decimal number.\n    \n    Valid numeric strings:\n    - Non-empty strings containing only digits\n    - May contain leading minus sign for negative numbers\n    - May contain a single decimal point for decimal numbers\n    - Leading/trailing whitespace is ignored\n    \n    Args:\n        value: The string to validate, or None\n        \n    Returns:\n        True if the string represents a valid number, False otherwise\n        \n    Examples:\n        >>> is_valid_numeric_string(\"123\")\n        True\n        >>> is_valid_numeric_string(\"-123.45\")\n        True\n        >>> is_valid_numeric_string(\"\")\n        False\n        >>> is_valid_numeric_string(\"12.34.56\")\n        False\n        >>> is_valid_numeric_string(\"abc\")\n        False\n        >>> is_valid_numeric_string(None)\n        False\n    \"\"\"\n    if value is None:\n        return False\n    \n    if not isinstance(value, str):\n        return False\n    \n    stripped_value = value.strip()\n    if not stripped_value:\n        return False\n    \n    # Remove leading minus sign for negative numbers\n    value_without_sign = stripped_value.lstrip('-')\n    if not value_without_sign:\n        return False\n    \n    # Remove at most one decimal point for decimal numbers\n    value_without_decimal = value_without_sign.replace('.', '', 1)\n    if not value_without_decimal:\n        return False\n    \n    return value_without_decimal.isdigit()"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件格式（简单规则：包含@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(s):\n    a = False\n    b = False\n    for x in s:\n        if x == '@':\n            a = True\n        if x == '.':\n            b = True\n    if a == True and b == True:\n        return True\n    else:\n        return False", "output": "def is_valid_email_format(email: str) -> bool:\n    \"\"\"检查字符串是否符合基本的电子邮件格式要求。\n    \n    该函数执行简单的格式检查，验证字符串中是否同时包含 '@' 和 '.' 字符。\n    注意：这只是一个基本的格式检查，不验证电子邮件地址的实际有效性。\n    \n    Args:\n        email: 待检查的电子邮件地址字符串。\n    \n    Returns:\n        如果字符串同时包含 '@' 和 '.' 字符则返回 True，否则返回 False。\n    \n    Examples:\n        >>> is_valid_email_format(\"user@example.com\")\n        True\n        >>> is_valid_email_format(\"invalid-email\")\n        False\n        >>> is_valid_email_format(\"user@domain\")\n        False\n    \"\"\"\n    has_at_symbol = False\n    has_dot = False\n    \n    for character in email:\n        if character == '@':\n            has_at_symbol = True\n        elif character == '.':\n            has_dot = True\n        \n        # 提前退出优化：如果已经找到两个字符，可以提前结束循环\n        if has_at_symbol and has_dot:\n            break\n    \n    return has_at_symbol and has_dot"}
{"origin_topic": "检查密码强度（至少8位，含大小写字母和数字）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_password_strength(password):\n    a = len(password)\n    if a < 8:\n        return False\n    b = False\n    c = False\n    d = False\n    for x in password:\n        if x.isdigit():\n            b = True\n        if x.islower():\n            c = True\n        if x.isupper():\n            d = True\n    if b and c and d:\n        return True\n    else:\n        return False", "output": "from typing import Union\n\n\ndef check_password_strength(password: str) -> bool:\n    \"\"\"检查密码强度是否符合安全要求。\n    \n    密码必须满足以下所有条件：\n    1. 长度至少为8个字符\n    2. 至少包含一个数字\n    3. 至少包含一个小写字母\n    4. 至少包含一个大写字母\n    \n    Args:\n        password: 待检查的密码字符串\n        \n    Returns:\n        bool: 如果密码符合所有强度要求返回True，否则返回False\n        \n    Examples:\n        >>> check_password_strength(\"Weak123\")\n        False\n        >>> check_password_strength(\"StrongPassword123\")\n        True\n    \"\"\"\n    # 检查最小长度要求\n    if len(password) < 8:\n        return False\n    \n    # 初始化标志位\n    has_digit = False\n    has_lowercase = False\n    has_uppercase = False\n    \n    # 遍历密码字符检查各类字符是否存在\n    for character in password:\n        if character.isdigit():\n            has_digit = True\n        elif character.islower():\n            has_lowercase = True\n        elif character.isupper():\n            has_uppercase = True\n        \n        # 如果所有条件都已满足，提前返回\n        if has_digit and has_lowercase and has_uppercase:\n            return True\n    \n    # 检查所有条件是否满足\n    return has_digit and has_lowercase and has_uppercase"}
{"origin_topic": "将一个字符串中的数字提取出来并求和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = \"\"\n    e = False\n    for f in b:\n        if f.isdigit():\n            d = d + f\n            e = True\n        else:\n            if e:\n                c.append(int(d))\n                d = \"\"\n                e = False\n    if e:\n        c.append(int(d))\n    g = 0\n    for h in c:\n        g = g + h\n    return g", "output": "from typing import List\n\n\ndef sum_numbers_from_string(text: str) -> int:\n    \"\"\"Extracts and sums all consecutive digit sequences from a string.\n    \n    This function scans the input string character by character, identifies\n    consecutive digit sequences, converts them to integers, and returns their sum.\n    \n    Args:\n        text: The input string that may contain digit sequences.\n    \n    Returns:\n        The sum of all integer values extracted from consecutive digit sequences.\n    \n    Examples:\n        >>> sum_numbers_from_string(\"abc123def45gh6\")\n        174\n        >>> sum_numbers_from_string(\"no numbers here\")\n        0\n        >>> sum_numbers_from_string(\"100 200 300\")\n        600\n    \"\"\"\n    extracted_numbers: List[int] = []\n    current_number_str: str = \"\"\n    in_number: bool = False\n    \n    for char in text:\n        if char.isdigit():\n            current_number_str += char\n            in_number = True\n        else:\n            if in_number:\n                extracted_numbers.append(int(current_number_str))\n                current_number_str = \"\"\n                in_number = False\n    \n    # Handle case where string ends with a number\n    if in_number:\n        extracted_numbers.append(int(current_number_str))\n    \n    total_sum: int = 0\n    for number in extracted_numbers:\n        total_sum += number\n    \n    return total_sum"}
{"origin_topic": "验证一个字符串是否为有效的电子邮件格式（简单检查@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(input_string):\n    if input_string is None:\n        return False\n    if not isinstance(input_string, str):\n        return False\n    if len(input_string) == 0:\n        return False\n    at_symbol_count = 0\n    for character in input_string:\n        if character == '@':\n            at_symbol_count = at_symbol_count + 1\n    if at_symbol_count != 1:\n        return False\n    dot_symbol_present = False\n    for character in input_string:\n        if character == '.':\n            dot_symbol_present = True\n            break\n    if not dot_symbol_present:\n        return False\n    at_symbol_index = -1\n    for index in range(len(input_string)):\n        if input_string[index] == '@':\n            at_symbol_index = index\n            break\n    if at_symbol_index <= 0:\n        return False\n    if at_symbol_index >= len(input_string) - 1:\n        return False\n    dot_symbol_after_at = False\n    for index in range(at_symbol_index + 1, len(input_string)):\n        if input_string[index] == '.':\n            dot_symbol_after_at = True\n            break\n    if not dot_symbol_after_at:\n        return False\n    return True", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_email_format(email: Optional[str]) -> bool:\n    \"\"\"Validates if a string follows basic email format requirements.\n    \n    This function performs basic email format validation by checking:\n    1. Input is a non-empty string\n    2. Contains exactly one '@' symbol\n    3. Contains at least one '.' symbol\n    4. '@' symbol is not at the beginning or end\n    5. There's at least one '.' after the '@' symbol\n    \n    Note: This is a basic format check and does not validate against RFC 5322\n    or check domain existence.\n    \n    Args:\n        email: The string to validate as an email address.\n        \n    Returns:\n        True if the string meets basic email format requirements, False otherwise.\n        \n    Examples:\n        >>> is_valid_email_format(\"user@example.com\")\n        True\n        >>> is_valid_email_format(\"invalid.email\")\n        False\n        >>> is_valid_email_format(None)\n        False\n    \"\"\"\n    # Early return for invalid input types\n    if not isinstance(email, str):\n        return False\n    \n    # Early return for empty string\n    if not email:\n        return False\n    \n    # Check for exactly one '@' symbol\n    at_symbol_count = email.count('@')\n    if at_symbol_count != 1:\n        return False\n    \n    # Check for at least one '.' symbol\n    if '.' not in email:\n        return False\n    \n    # Find '@' position and validate it's not at edges\n    at_symbol_index = email.find('@')\n    if at_symbol_index <= 0 or at_symbol_index >= len(email) - 1:\n        return False\n    \n    # Check there's at least one '.' after '@'\n    domain_part = email[at_symbol_index + 1:]\n    if '.' not in domain_part:\n        return False\n    \n    return True"}
{"origin_topic": "验证密码强度（至少8位，包含字母和数字）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_password_strength(a):\n    b = False\n    x = False\n    if len(a) >= 8:\n        for c in a:\n            if c.isalpha():\n                b = True\n            if c.isdigit():\n                x = True\n        if b and x:\n            return True\n        else:\n            return False\n    else:\n        return False", "output": "from typing import Union\n\n\ndef check_password_strength(password: str) -> bool:\n    \"\"\"检查密码强度是否符合基本要求。\n    \n    密码必须满足以下条件：\n    1. 长度至少为8个字符\n    2. 至少包含一个字母\n    3. 至少包含一个数字\n    \n    Args:\n        password: 待检查的密码字符串\n        \n    Returns:\n        bool: 如果密码符合所有强度要求返回True，否则返回False\n        \n    Examples:\n        >>> check_password_strength(\"password123\")\n        True\n        >>> check_password_strength(\"short\")\n        False\n        >>> check_password_strength(\"onlyletters\")\n        False\n        >>> check_password_strength(\"12345678\")\n        False\n    \"\"\"\n    # 检查密码长度\n    if len(password) < 8:\n        return False\n    \n    # 初始化标志位\n    has_letter = False\n    has_digit = False\n    \n    # 遍历密码字符，检查是否包含字母和数字\n    for character in password:\n        if character.isalpha():\n            has_letter = True\n        if character.isdigit():\n            has_digit = True\n        \n        # 如果已经找到字母和数字，提前退出循环\n        if has_letter and has_digit:\n            break\n    \n    # 返回检查结果\n    return has_letter and has_digit"}
{"origin_topic": "检查一个字符串是否包含所有英文字母（忽略大小写）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check(s):\n    a = \"abcdefghijklmnopqrstuvwxyz\"\n    b = s.lower()\n    c = []\n    for d in b:\n        if d in a:\n            if d not in c:\n                c.append(d)\n    e = len(c)\n    f = len(a)\n    if e == f:\n        return True\n    else:\n        return False", "output": "def is_pangram(s: str) -> bool:\n    \"\"\"Check if a string contains every letter of the alphabet at least once.\n\n    A pangram is a sentence containing every letter of the alphabet at least once.\n    This function is case-insensitive and ignores non-alphabetic characters.\n\n    Args:\n        s: The input string to check.\n\n    Returns:\n        True if the string is a pangram, False otherwise.\n\n    Examples:\n        >>> is_pangram(\"The quick brown fox jumps over the lazy dog\")\n        True\n        >>> is_pangram(\"Hello World\")\n        False\n    \"\"\"\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    normalized_string = s.lower()\n    unique_letters = set()\n\n    for character in normalized_string:\n        if character in alphabet:\n            unique_letters.add(character)\n\n    return len(unique_letters) == len(alphabet)"}
{"origin_topic": "将两个字典合并为一个（如果键冲突，取第二个字典的值）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def combine_two_dictionaries_into_one(dictionary_one, dictionary_two):\n    resulting_dictionary = {}\n    for each_key in dictionary_one:\n        resulting_dictionary[each_key] = dictionary_one[each_key]\n    for each_key in dictionary_two:\n        resulting_dictionary[each_key] = dictionary_two[each_key]\n    return resulting_dictionary", "output": "from typing import Dict, Any\n\n\ndef merge_dictionaries(\n    first_dict: Dict[Any, Any], \n    second_dict: Dict[Any, Any]\n) -> Dict[Any, Any]:\n    \"\"\"Merges two dictionaries into a new dictionary.\n    \n    If both dictionaries contain the same key, the value from the second\n    dictionary will overwrite the value from the first dictionary in the\n    resulting merged dictionary.\n    \n    Args:\n        first_dict: The first dictionary to merge.\n        second_dict: The second dictionary to merge, whose values take\n            precedence for overlapping keys.\n    \n    Returns:\n        A new dictionary containing all key-value pairs from both input\n        dictionaries, with second_dict's values taking precedence for\n        duplicate keys.\n    \n    Example:\n        >>> merge_dictionaries({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n        {'a': 1, 'b': 3, 'c': 4}\n    \"\"\"\n    merged_dict = {**first_dict, **second_dict}\n    return merged_dict"}
{"origin_topic": "将一个字符串按单词首字母排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = s.split()\n    b = []\n    for x in a:\n        b.append(x)\n    c = []\n    for y in b:\n        c.append(y)\n    d = []\n    for z in c:\n        d.append(z)\n    e = sorted(d, key=lambda m: m[0].lower() if m and m[0].isalpha() else m[0] if m else '')\n    result = ''\n    for n in e:\n        result = result + n + ' '\n    final_result = result.strip()\n    return final_result", "output": "from typing import List\n\n\ndef sort_words_by_first_letter(text: str) -> str:\n    \"\"\"Sort words in a string by their first letter, case-insensitively.\n    \n    Words are sorted alphabetically based on the first character, ignoring case.\n    Non-alphabetic first characters are sorted by their actual character value.\n    Empty strings are handled appropriately.\n    \n    Args:\n        text: Input string containing words to be sorted.\n        \n    Returns:\n        A new string with words sorted by first letter, separated by single spaces.\n        \n    Examples:\n        >>> sort_words_by_first_letter(\"banana apple cherry\")\n        'apple banana cherry'\n        \n        >>> sort_words_by_first_letter(\"123 abc 456 def\")\n        '123 456 abc def'\n    \"\"\"\n    # Split input into individual words\n    words: List[str] = text.split()\n    \n    # Create a copy of the words list for clarity (though not strictly necessary)\n    words_copy: List[str] = words.copy()\n    \n    # Sort words based on their first character\n    # Handle empty strings and non-alphabetic characters appropriately\n    sorted_words: List[str] = sorted(\n        words_copy,\n        key=lambda word: (\n            word[0].lower() if word and word[0].isalpha()\n            else word[0] if word\n            else ''\n        )\n    )\n    \n    # Join sorted words with single spaces\n    result: str = ' '.join(sorted_words)\n    \n    return result"}
{"origin_topic": "验证邮箱格式（简单规则）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(email_string):\n    if not isinstance(email_string, str):\n        return False\n    if len(email_string) == 0:\n        return False\n    if email_string.count('@') != 1:\n        return False\n    parts = email_string.split('@')\n    if len(parts) != 2:\n        return False\n    left_part = parts[0]\n    right_part = parts[1]\n    if len(left_part) == 0:\n        return False\n    if len(right_part) == 0:\n        return False\n    if '.' not in right_part:\n        return False\n    dot_parts = right_part.split('.')\n    if len(dot_parts) < 2:\n        return False\n    for segment in dot_parts:\n        if len(segment) == 0:\n            return False\n    return True", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Union\n\n\ndef validate_email_format(email: Union[str, bytes]) -> bool:\n    \"\"\"Validate the format of an email address.\n    \n    This function performs basic email format validation according to RFC 5322\n    simplified rules. It checks for:\n    - Proper string type\n    - Single '@' character\n    - Non-empty local part (before '@')\n    - Non-empty domain part (after '@')\n    - At least one '.' in domain part\n    - Non-empty segments in domain part\n    \n    Args:\n        email: The email address to validate. Can be string or bytes.\n    \n    Returns:\n        True if the email format is valid, False otherwise.\n    \n    Examples:\n        >>> validate_email_format('user@example.com')\n        True\n        >>> validate_email_format('invalid.email')\n        False\n        >>> validate_email_format('')\n        False\n    \"\"\"\n    # Convert bytes to string if necessary\n    if isinstance(email, bytes):\n        email = email.decode('utf-8', errors='ignore')\n    elif not isinstance(email, str):\n        return False\n    \n    # Check for empty string\n    if not email:\n        return False\n    \n    # Validate '@' character count and position\n    if email.count('@') != 1:\n        return False\n    \n    # Split into local and domain parts\n    local_part, domain_part = email.split('@', maxsplit=1)\n    \n    # Validate local part\n    if not local_part:\n        return False\n    \n    # Validate domain part\n    if not domain_part:\n        return False\n    \n    # Check for at least one dot in domain\n    if '.' not in domain_part:\n        return False\n    \n    # Split domain into segments and validate each\n    domain_segments = domain_part.split('.')\n    if len(domain_segments) < 2:\n        return False\n    \n    # Ensure no empty segments in domain\n    if any(not segment for segment in domain_segments):\n        return False\n    \n    return True"}
{"origin_topic": "计算两个日期的天数差（假设输入为字符串'YYYY-MM-DD'）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b, x):\n    def c(d):\n        e = d.split('-')\n        f = int(e[0])\n        g = int(e[1])\n        h = int(e[2])\n        i = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        j = 0\n        for k in range(1, f):\n            if (k % 4 == 0 and k % 100 != 0) or (k % 400 == 0):\n                j = j + 366\n            else:\n                j = j + 365\n        if (f % 4 == 0 and f % 100 != 0) or (f % 400 == 0):\n            i[1] = 29\n        for l in range(0, g - 1):\n            j = j + i[l]\n        j = j + h\n        return j\n    m = c(b)\n    n = c(x)\n    o = m - n\n    if o < 0:\n        o = -o\n    return o", "output": "from typing import Tuple\n\n\ndef calculate_days_between_dates(date1: str, date2: str) -> int:\n    \"\"\"Calculate the absolute number of days between two dates in YYYY-MM-DD format.\n    \n    Args:\n        date1: First date string in YYYY-MM-DD format\n        date2: Second date string in YYYY-MM-DD format\n        \n    Returns:\n        Absolute number of days between the two dates\n        \n    Raises:\n        ValueError: If date strings are not in correct format or contain invalid values\n    \"\"\"\n    \n    def _date_to_days(date_str: str) -> int:\n        \"\"\"Convert a YYYY-MM-DD date string to total days since year 0.\n        \n        Args:\n            date_str: Date string in YYYY-MM-DD format\n            \n        Returns:\n            Total number of days since year 0\n            \n        Raises:\n            ValueError: If date string is not in correct format or contains invalid values\n        \"\"\"\n        try:\n            year_str, month_str, day_str = date_str.split('-')\n            year = int(year_str)\n            month = int(month_str)\n            day = int(day_str)\n        except ValueError:\n            raise ValueError(f\"Invalid date format: {date_str}. Expected YYYY-MM-DD\")\n        \n        # Validate month and day ranges\n        if not (1 <= month <= 12):\n            raise ValueError(f\"Invalid month: {month}. Must be between 1 and 12\")\n        if not (1 <= day <= 31):\n            raise ValueError(f\"Invalid day: {day}. Must be between 1 and 31\")\n        \n        # Days in each month for non-leap year\n        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        \n        # Adjust for leap year\n        def _is_leap_year(y: int) -> bool:\n            \"\"\"Check if a year is a leap year.\"\"\"\n            return (y % 4 == 0 and y % 100 != 0) or (y % 400 == 0)\n        \n        if _is_leap_year(year):\n            days_in_month[1] = 29\n        \n        # Validate day against month\n        if day > days_in_month[month - 1]:\n            raise ValueError(\n                f\"Invalid day: {day} for month {month}. \"\n                f\"Maximum days in this month: {days_in_month[month - 1]}\"\n            )\n        \n        # Calculate total days\n        total_days = 0\n        \n        # Add days from previous years\n        for y in range(1, year):\n            total_days += 366 if _is_leap_year(y) else 365\n        \n        # Add days from previous months in current year\n        for m in range(month - 1):\n            total_days += days_in_month[m]\n        \n        # Add days in current month\n        total_days += day\n        \n        return total_days\n    \n    # Convert both dates to days and calculate difference\n    days1 = _date_to_days(date1)\n    days2 = _date_to_days(date2)\n    \n    return abs(days1 - days2)"}
{"origin_topic": "将两个字典合并", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def combine_two_dictionaries_into_one(dictionary_one, dictionary_two):\n    resulting_dictionary = {}\n    for each_key in dictionary_one:\n        resulting_dictionary[each_key] = dictionary_one[each_key]\n    for each_key in dictionary_two:\n        resulting_dictionary[each_key] = dictionary_two[each_key]\n    return resulting_dictionary", "output": "from typing import Dict, TypeVar, Union\n\nK = TypeVar('K')\nV = TypeVar('V')\n\n\ndef merge_dictionaries(\n    first_dict: Dict[K, V],\n    second_dict: Dict[K, V],\n) -> Dict[K, V]:\n    \"\"\"Merges two dictionaries, with values from the second dict taking precedence.\n\n    This function combines two dictionaries into a single dictionary. When both\n    dictionaries contain the same key, the value from the second dictionary will\n    overwrite the value from the first dictionary.\n\n    Args:\n        first_dict: The first dictionary to merge.\n        second_dict: The second dictionary to merge. Values from this dictionary\n            will take precedence in case of key conflicts.\n\n    Returns:\n        A new dictionary containing the merged key-value pairs from both input\n        dictionaries.\n\n    Example:\n        >>> merge_dictionaries({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n        {'a': 1, 'b': 3, 'c': 4}\n    \"\"\"\n    return {**first_dict, **second_dict}"}
{"origin_topic": "找出字符串中所有单词的长度列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(s):\n    b = []\n    x = 0\n    y = 0\n    z = len(s)\n    while x < z:\n        if s[x] != ' ':\n            y = y + 1\n        else:\n            if y > 0:\n                b.append(y)\n                y = 0\n        x = x + 1\n    if y > 0:\n        b.append(y)\n    return b", "output": "from typing import List\n\n\ndef count_word_lengths(text: str) -> List[int]:\n    \"\"\"计算字符串中每个单词的长度。\n    \n    该函数遍历输入字符串，识别连续的字母序列（单词），\n    并返回每个单词的长度列表。单词由空格分隔。\n    \n    Args:\n        text: 输入字符串，包含由空格分隔的单词。\n    \n    Returns:\n        一个整数列表，包含输入字符串中每个单词的长度。\n        如果输入为空字符串或仅包含空格，则返回空列表。\n    \n    Examples:\n        >>> count_word_lengths(\"hello world\")\n        [5, 5]\n        >>> count_word_lengths(\"Python is  great\")\n        [6, 2, 5]\n        >>> count_word_lengths(\"\")\n        []\n    \"\"\"\n    word_lengths: List[int] = []\n    current_length: int = 0\n    text_length: int = len(text)\n    index: int = 0\n    \n    while index < text_length:\n        if text[index] != ' ':\n            current_length += 1\n        else:\n            if current_length > 0:\n                word_lengths.append(current_length)\n                current_length = 0\n        index += 1\n    \n    # 处理字符串末尾的最后一个单词\n    if current_length > 0:\n        word_lengths.append(current_length)\n    \n    return word_lengths"}
{"origin_topic": "计算两个日期之间的天数差（简化版，假设每月30天）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b, x):\n    def c(y):\n        m = y // 10000\n        d = (y % 10000) // 100\n        e = y % 100\n        return m * 360 + (d - 1) * 30 + e\n    f = c(b)\n    g = c(x)\n    h = g - f\n    if h < 0:\n        h = -h\n    return h", "output": "from typing import Callable\n\n\ndef calculate_date_difference(start_date: int, end_date: int) -> int:\n    \"\"\"Calculate the absolute difference between two dates in days.\n    \n    Dates are represented as integers in YYYYMMDD format and are converted\n    to a simplified day count where each month has exactly 30 days.\n    \n    Args:\n        start_date: The starting date in YYYYMMDD format.\n        end_date: The ending date in YYYYMMDD format.\n    \n    Returns:\n        The absolute difference in days between the two dates.\n    \n    Example:\n        >>> calculate_date_difference(20230101, 20230115)\n        14\n    \"\"\"\n    \n    def _convert_to_days(date_int: int) -> int:\n        \"\"\"Convert a YYYYMMDD integer to a simplified day count.\n        \n        Assumes each month has exactly 30 days for calculation purposes.\n        \n        Args:\n            date_int: Date in YYYYMMDD format.\n        \n        Returns:\n            Number of days since year 0 (simplified calendar).\n        \"\"\"\n        year = date_int // 10000\n        month = (date_int % 10000) // 100\n        day = date_int % 100\n        \n        # Simplified calculation: 360 days per year, 30 days per month\n        return year * 360 + (month - 1) * 30 + day\n    \n    start_days = _convert_to_days(start_date)\n    end_days = _convert_to_days(end_date)\n    day_difference = end_days - start_days\n    \n    return abs(day_difference)"}
{"origin_topic": "将一个字符串中的单词顺序反转", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def reverse_words_in_string(input_string):\n    if not input_string:\n        return \"\"\n    words_list = []\n    current_word = \"\"\n    for character in input_string:\n        if character == \" \":\n            if current_word:\n                words_list.append(current_word)\n                current_word = \"\"\n        else:\n            current_word = current_word + character\n    if current_word:\n        words_list.append(current_word)\n    reversed_words_list = []\n    for index in range(len(words_list) - 1, -1, -1):\n        reversed_words_list.append(words_list[index])\n    result_string = \"\"\n    for i in range(len(reversed_words_list)):\n        result_string = result_string + reversed_words_list[i]\n        if i != len(reversed_words_list) - 1:\n            result_string = result_string + \" \"\n    return result_string", "output": "def reverse_words_in_string(input_string: str) -> str:\n    \"\"\"Reverses the order of words in a given string while preserving spaces.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    The function handles multiple spaces and empty strings appropriately.\n    \n    Args:\n        input_string: The string whose words need to be reversed.\n        \n    Returns:\n        A new string with words in reverse order. Returns empty string for empty input.\n        \n    Examples:\n        >>> reverse_words_in_string(\"hello world\")\n        'world hello'\n        >>> reverse_words_in_string(\"  multiple   spaces  \")\n        'spaces multiple'\n        >>> reverse_words_in_string(\"\")\n        ''\n    \"\"\"\n    if not input_string:\n        return \"\"\n    \n    words: list[str] = []\n    current_word: str = \"\"\n    \n    # Parse words from input string\n    for char in input_string:\n        if char == \" \":\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n        else:\n            current_word += char\n    \n    # Add the last word if exists\n    if current_word:\n        words.append(current_word)\n    \n    # Reverse the list of words\n    reversed_words: list[str] = []\n    for index in range(len(words) - 1, -1, -1):\n        reversed_words.append(words[index])\n    \n    # Join reversed words with single spaces\n    result: str = \"\"\n    for i, word in enumerate(reversed_words):\n        result += word\n        if i != len(reversed_words) - 1:\n            result += \" \"\n    \n    return result"}
{"origin_topic": "检查密码强度（至少8位，包含字母和数字）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_password_strength(a):\n    b = False\n    x = False\n    if len(a) >= 8:\n        for c in a:\n            if c.isalpha():\n                b = True\n            if c.isdigit():\n                x = True\n        if b and x:\n            return True\n        else:\n            return False\n    else:\n        return False", "output": "from typing import Union\n\n\ndef check_password_strength(password: str) -> bool:\n    \"\"\"检查密码强度是否符合基本要求。\n\n    密码必须满足以下条件：\n    1. 长度至少为8个字符\n    2. 至少包含一个字母\n    3. 至少包含一个数字\n\n    Args:\n        password: 待检查的密码字符串\n\n    Returns:\n        True 如果密码满足所有强度要求，否则返回 False\n\n    Examples:\n        >>> check_password_strength(\"password123\")\n        True\n        >>> check_password_strength(\"short\")\n        False\n        >>> check_password_strength(\"onlyletters\")\n        False\n        >>> check_password_strength(\"12345678\")\n        False\n    \"\"\"\n    if len(password) < 8:\n        return False\n\n    has_letter = False\n    has_digit = False\n\n    for character in password:\n        if character.isalpha():\n            has_letter = True\n        elif character.isdigit():\n            has_digit = True\n\n        # 提前退出优化：如果已经找到字母和数字，可以提前返回\n        if has_letter and has_digit:\n            return True\n\n    return has_letter and has_digit"}
{"origin_topic": "将时间字符串转换为分钟数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = a.split(':')\n    x = 0\n    if len(b) == 2:\n        x = int(b[0]) * 60 + int(b[1])\n    elif len(b) == 3:\n        x = int(b[0]) * 60 * 60 + int(b[1]) * 60 + int(b[2])\n        x = x // 60\n    else:\n        x = 0\n    return x", "output": "from typing import Union\n\n\ndef parse_time_to_minutes(time_string: str) -> int:\n    \"\"\"将时间字符串转换为分钟数。\n    \n    支持以下格式：\n    - \"HH:MM\" → 小时*60 + 分钟\n    - \"HH:MM:SS\" → (小时*3600 + 分钟*60 + 秒) // 60\n    其他格式返回0\n    \n    Args:\n        time_string: 时间字符串，格式为\"HH:MM\"或\"HH:MM:SS\"\n    \n    Returns:\n        对应的分钟数（整数）\n    \n    Raises:\n        ValueError: 如果时间字符串包含非数字字符\n    \"\"\"\n    if not time_string:\n        return 0\n    \n    time_parts = time_string.split(':')\n    \n    try:\n        if len(time_parts) == 2:\n            hours, minutes = map(int, time_parts)\n            return hours * 60 + minutes\n            \n        elif len(time_parts) == 3:\n            hours, minutes, seconds = map(int, time_parts)\n            total_seconds = hours * 3600 + minutes * 60 + seconds\n            return total_seconds // 60\n            \n        else:\n            return 0\n            \n    except ValueError as e:\n        raise ValueError(f\"时间字符串 '{time_string}' 包含非数字字符\") from e"}
{"origin_topic": "检查一个字符串是否为有效的URL", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = False\n    if isinstance(b, str):\n        if b.startswith('http://') or b.startswith('https://'):\n            if ' ' not in b:\n                if '.' in b:\n                    if len(b) > 10:\n                        if '://' in b:\n                            x = True\n    return x", "output": "from typing import Union\n\n\ndef is_valid_url(url_candidate: Union[str, object]) -> bool:\n    \"\"\"验证输入是否为有效的URL字符串。\n    \n    检查字符串是否满足以下条件：\n    1. 以 'http://' 或 'https://' 开头\n    2. 不包含空格\n    3. 包含点号（.）\n    4. 长度大于10个字符\n    5. 包含 '://' 协议分隔符\n    \n    Args:\n        url_candidate: 待验证的输入，通常应为字符串\n    \n    Returns:\n        bool: 如果输入是有效的URL字符串则返回True，否则返回False\n    \n    Examples:\n        >>> is_valid_url('https://www.google.com')\n        True\n        >>> is_valid_url('invalid url')\n        False\n        >>> is_valid_url(123)\n        False\n    \"\"\"\n    # 类型检查：确保输入是字符串\n    if not isinstance(url_candidate, str):\n        return False\n    \n    # 检查URL的基本格式要求\n    has_valid_protocol = (\n        url_candidate.startswith('http://') or \n        url_candidate.startswith('https://')\n    )\n    has_no_spaces = ' ' not in url_candidate\n    has_dot = '.' in url_candidate\n    is_long_enough = len(url_candidate) > 10\n    has_protocol_separator = '://' in url_candidate\n    \n    # 所有条件必须同时满足\n    return all([\n        has_valid_protocol,\n        has_no_spaces,\n        has_dot,\n        is_long_enough,\n        has_protocol_separator\n    ])"}
{"origin_topic": "计算字符串中数字的和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    for i in b:\n        if i == '0':\n            x = x + 0\n        elif i == '1':\n            x = x + 1\n        elif i == '2':\n            x = x + 2\n        elif i == '3':\n            x = x + 3\n        elif i == '4':\n            x = x + 4\n        elif i == '5':\n            x = x + 5\n        elif i == '6':\n            x = x + 6\n        elif i == '7':\n            x = x + 7\n        elif i == '8':\n            x = x + 8\n        elif i == '9':\n            x = x + 9\n        else:\n            x = x + 0\n    return x", "output": "from typing import Iterable\n\n\ndef sum_digits_in_string(digit_string: Iterable[str]) -> int:\n    \"\"\"计算字符串中所有数字字符的数值总和。\n    \n    遍历输入的可迭代字符串，将每个数字字符转换为对应的整数值并累加。\n    非数字字符将被视为0处理。\n    \n    Args:\n        digit_string: 包含数字字符的可迭代对象（如字符串）\n    \n    Returns:\n        所有数字字符对应数值的总和\n    \n    Examples:\n        >>> sum_digits_in_string(\"123\")\n        6\n        >>> sum_digits_in_string(\"1a2b3c\")\n        6\n        >>> sum_digits_in_string([\"1\", \"2\", \"3\"])\n        6\n    \"\"\"\n    total = 0\n    \n    for character in digit_string:\n        if character.isdigit():\n            total += int(character)\n        # 非数字字符自动跳过（相当于加0）\n    \n    return total"}
{"origin_topic": "将一个十进制数转换为二进制字符串", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    if a == 0:\n        return \"0\"\n    b = []\n    x = a\n    while x > 0:\n        b.append(x % 2)\n        x = x // 2\n    c = \"\"\n    for i in range(len(b) - 1, -1, -1):\n        c = c + str(b[i])\n    return c", "output": "def decimal_to_binary(decimal_number: int) -> str:\n    \"\"\"Convert a non-negative integer to its binary string representation.\n    \n    Args:\n        decimal_number: A non-negative integer to convert to binary.\n        \n    Returns:\n        A string representing the binary equivalent of the input number.\n        \n    Raises:\n        ValueError: If the input is negative.\n        \n    Examples:\n        >>> decimal_to_binary(0)\n        '0'\n        >>> decimal_to_binary(5)\n        '101'\n        >>> decimal_to_binary(10)\n        '1010'\n    \"\"\"\n    if decimal_number < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    current_number = decimal_number\n    \n    while current_number > 0:\n        binary_digits.append(current_number % 2)\n        current_number //= 2\n    \n    # Reverse the list and join digits to form binary string\n    binary_string = \"\".join(str(digit) for digit in reversed(binary_digits))\n    \n    return binary_string"}
{"origin_topic": "计算两个字符串的编辑距离（仅插入、删除、替换）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a, b):\n    m = len(a)\n    n = len(b)\n    d = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        d[i][0] = i\n    for j in range(n + 1):\n        d[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                x = 0\n            else:\n                x = 1\n            y = d[i - 1][j] + 1\n            z = d[i][j - 1] + 1\n            w = d[i - 1][j - 1] + x\n            if y <= z and y <= w:\n                d[i][j] = y\n            elif z <= y and z <= w:\n                d[i][j] = z\n            else:\n                d[i][j] = w\n    return d[m][n]", "output": "from typing import Sequence, TypeVar\n\nT = TypeVar('T')\n\n\ndef levenshtein_distance(seq1: Sequence[T], seq2: Sequence[T]) -> int:\n    \"\"\"\n    Calculate the Levenshtein distance (edit distance) between two sequences.\n\n    The Levenshtein distance is the minimum number of single-character edits\n    (insertions, deletions, or substitutions) required to change one sequence\n    into the other.\n\n    Args:\n        seq1: The first sequence to compare.\n        seq2: The second sequence to compare.\n\n    Returns:\n        The Levenshtein distance between seq1 and seq2.\n\n    Examples:\n        >>> levenshtein_distance(\"kitten\", \"sitting\")\n        3\n        >>> levenshtein_distance([1, 2, 3], [1, 3, 4])\n        2\n    \"\"\"\n    len_seq1 = len(seq1)\n    len_seq2 = len(seq2)\n\n    # Initialize the distance matrix\n    distance_matrix = [[0] * (len_seq2 + 1) for _ in range(len_seq1 + 1)]\n\n    # Initialize first row and column\n    for i in range(len_seq1 + 1):\n        distance_matrix[i][0] = i\n    for j in range(len_seq2 + 1):\n        distance_matrix[0][j] = j\n\n    # Fill the distance matrix\n    for i in range(1, len_seq1 + 1):\n        for j in range(1, len_seq2 + 1):\n            substitution_cost = 0 if seq1[i - 1] == seq2[j - 1] else 1\n\n            deletion_cost = distance_matrix[i - 1][j] + 1\n            insertion_cost = distance_matrix[i][j - 1] + 1\n            substitution_or_match_cost = distance_matrix[i - 1][j - 1] + substitution_cost\n\n            # Find the minimum cost operation\n            distance_matrix[i][j] = min(\n                deletion_cost,\n                insertion_cost,\n                substitution_or_match_cost\n            )\n\n    return distance_matrix[len_seq1][len_seq2]"}
{"origin_topic": "实现一个函数，返回两个日期的较早日期（格式：YYYY-MM-DD）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def get_earlier_date(a, b):\n    x = a.split('-')\n    y = b.split('-')\n    if int(x[0]) < int(y[0]):\n        return a\n    elif int(x[0]) > int(y[0]):\n        return b\n    else:\n        if int(x[1]) < int(y[1]):\n            return a\n        elif int(x[1]) > int(y[1]):\n            return b\n        else:\n            if int(x[2]) < int(y[2]):\n                return a\n            elif int(x[2]) > int(y[2]):\n                return b\n            else:\n                return a", "output": "from typing import Optional\n\n\ndef get_earlier_date(date_str1: str, date_str2: str) -> Optional[str]:\n    \"\"\"Returns the earlier of two dates in 'YYYY-MM-DD' format.\n    \n    Args:\n        date_str1: First date string in 'YYYY-MM-DD' format.\n        date_str2: Second date string in 'YYYY-MM-DD' format.\n    \n    Returns:\n        The earlier date string, or the first date if both are equal.\n        Returns None if either input is not in the correct format.\n    \n    Raises:\n        ValueError: If date strings are not in 'YYYY-MM-DD' format.\n    \"\"\"\n    try:\n        # Parse dates into comparable tuples\n        year1, month1, day1 = map(int, date_str1.split('-'))\n        year2, month2, day2 = map(int, date_str2.split('-'))\n        \n        date1_tuple = (year1, month1, day1)\n        date2_tuple = (year2, month2, day2)\n        \n        # Compare dates directly using tuple comparison\n        return date_str1 if date1_tuple <= date2_tuple else date_str2\n        \n    except (ValueError, AttributeError) as e:\n        raise ValueError(\n            f\"Invalid date format. Expected 'YYYY-MM-DD', \"\n            f\"got '{date_str1}' and '{date_str2}'\"\n        ) from e"}
{"origin_topic": "合并两个字典，如果有重复键则值相加", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def combine_dicts(dict_one, dict_two):\n    result_dictionary = {}\n    for key_item in dict_one:\n        if key_item in dict_two:\n            result_dictionary[key_item] = dict_one[key_item] + dict_two[key_item]\n        else:\n            result_dictionary[key_item] = dict_one[key_item]\n    for key_item in dict_two:\n        if key_item not in dict_one:\n            result_dictionary[key_item] = dict_two[key_item]\n    return result_dictionary", "output": "from typing import Dict, TypeVar\n\nT = TypeVar('T', int, float, str, list, tuple, set, dict)\n\n\ndef combine_dicts(\n    dict_one: Dict[str, T],\n    dict_two: Dict[str, T],\n) -> Dict[str, T]:\n    \"\"\"Combines two dictionaries by adding values for common keys.\n\n    This function merges two dictionaries by adding the values for keys that\n    appear in both dictionaries. For keys that appear in only one dictionary,\n    the value is preserved as-is. The operation assumes that the values support\n    the `+` operator.\n\n    Args:\n        dict_one: The first dictionary to combine.\n        dict_two: The second dictionary to combine.\n\n    Returns:\n        A new dictionary containing the combined key-value pairs.\n\n    Raises:\n        TypeError: If values for common keys do not support the `+` operator.\n\n    Examples:\n        >>> combine_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n        {'a': 1, 'b': 5, 'c': 4}\n        >>> combine_dicts({'x': [1, 2]}, {'x': [3, 4]})\n        {'x': [1, 2, 3, 4]}\n    \"\"\"\n    combined_dict: Dict[str, T] = {}\n\n    for key, value in dict_one.items():\n        if key in dict_two:\n            combined_dict[key] = value + dict_two[key]\n        else:\n            combined_dict[key] = value\n\n    for key, value in dict_two.items():\n        if key not in dict_one:\n            combined_dict[key] = value\n\n    return combined_dict"}
{"origin_topic": "计算数字的二进制表示", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(x):\n    if x == 0:\n        return \"0\"\n    b = \"\"\n    c = x\n    while c > 0:\n        d = c % 2\n        if d == 0:\n            b = \"0\" + b\n        else:\n            b = \"1\" + b\n        c = c // 2\n    return b", "output": "def decimal_to_binary_string(decimal_number: int) -> str:\n    \"\"\"Convert a non-negative integer to its binary string representation.\n    \n    Args:\n        decimal_number: A non-negative integer to convert to binary.\n        \n    Returns:\n        Binary string representation of the input number.\n        \n    Raises:\n        ValueError: If input is negative.\n        \n    Examples:\n        >>> decimal_to_binary_string(0)\n        '0'\n        >>> decimal_to_binary_string(5)\n        '101'\n        >>> decimal_to_binary_string(10)\n        '1010'\n    \"\"\"\n    if decimal_number < 0:\n        raise ValueError(\"Input must be non-negative\")\n    \n    if decimal_number == 0:\n        return \"0\"\n    \n    binary_digits = []\n    remaining_value = decimal_number\n    \n    while remaining_value > 0:\n        current_bit = remaining_value % 2\n        binary_digits.append(str(current_bit))\n        remaining_value //= 2\n    \n    # Reverse the list and join to get correct binary representation\n    return ''.join(reversed(binary_digits))"}
{"origin_topic": "统计一个文件中每个单词的出现次数（假设字符串输入）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    d = {}\n    w = ''\n    for c in s:\n        if c.isalpha():\n            w = w + c\n        else:\n            if w:\n                if w in d:\n                    d[w] = d[w] + 1\n                else:\n                    d[w] = 1\n                w = ''\n    if w:\n        if w in d:\n            d[w] = d[w] + 1\n        else:\n            d[w] = 1\n    return d", "output": "from typing import Dict\n\n\ndef count_words(text: str) -> Dict[str, int]:\n    \"\"\"统计文本中单词的出现频率。\n    \n    该函数遍历输入字符串，识别连续的字母字符作为单词，\n    并返回一个字典，其中键为单词，值为该单词出现的次数。\n    \n    Args:\n        text: 需要统计单词频率的输入字符串。\n    \n    Returns:\n        一个字典，包含单词及其出现次数。\n    \n    Examples:\n        >>> count_words(\"hello world hello\")\n        {'hello': 2, 'world': 1}\n        \n        >>> count_words(\"Python 3.9 is awesome!\")\n        {'Python': 1, 'is': 1, 'awesome': 1}\n    \"\"\"\n    word_count: Dict[str, int] = {}\n    current_word: str = ''\n    \n    for character in text:\n        if character.isalpha():\n            current_word += character\n        else:\n            if current_word:\n                word_count[current_word] = word_count.get(current_word, 0) + 1\n                current_word = ''\n    \n    # 处理文本以字母结尾的情况\n    if current_word:\n        word_count[current_word] = word_count.get(current_word, 0) + 1\n    \n    return word_count"}
{"origin_topic": "将一个句子中的单词按字母顺序排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = s.split()\n    b = []\n    for x in a:\n        b.append(x)\n    c = []\n    for y in b:\n        d = list(y)\n        e = []\n        for z in d:\n            e.append(z)\n        e.sort()\n        g = \"\"\n        for h in e:\n            g = g + h\n        c.append(g)\n    i = \" \".join(c)\n    return i", "output": "from typing import List\n\n\ndef sort_characters_in_words(text: str) -> str:\n    \"\"\"Sort characters alphabetically within each word of the input string.\n    \n    This function splits the input string into words, sorts the characters\n    within each word alphabetically, and then joins the words back together.\n    \n    Args:\n        text: The input string containing words to process.\n        \n    Returns:\n        A string where each word's characters are sorted alphabetically.\n        \n    Examples:\n        >>> sort_characters_in_words(\"hello world\")\n        'ehllo dlorw'\n        >>> sort_characters_in_words(\"python programming\")\n        'hnopty aggimmnoprr'\n    \"\"\"\n    words: List[str] = text.split()\n    sorted_words: List[str] = []\n    \n    for word in words:\n        # Convert word to list of characters, sort them, and join back\n        sorted_chars: List[str] = sorted(word)\n        sorted_word: str = \"\".join(sorted_chars)\n        sorted_words.append(sorted_word)\n    \n    # Join sorted words back into a single string\n    result: str = \" \".join(sorted_words)\n    return result"}
{"origin_topic": "检查一个字符串是否为有效的电子邮件地址（简单规则，包含@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email(x):\n    a = False\n    b = False\n    for y in x:\n        if y == '@':\n            a = True\n        if y == '.':\n            b = True\n    if a == True and b == True:\n        return True\n    else:\n        return False", "output": "def is_valid_email_format(email: str) -> bool:\n    \"\"\"检查字符串是否符合基本的电子邮件格式要求。\n    \n    基本格式检查：字符串中必须同时包含 '@' 和 '.' 字符。\n    注意：这只是一个非常基础的格式检查，不验证电子邮件地址的实际有效性。\n    \n    Args:\n        email: 待检查的电子邮件地址字符串。\n        \n    Returns:\n        如果字符串包含 '@' 和 '.' 字符则返回 True，否则返回 False。\n        \n    Examples:\n        >>> is_valid_email_format(\"user@example.com\")\n        True\n        >>> is_valid_email_format(\"invalid-email\")\n        False\n        >>> is_valid_email_format(\"user@com\")\n        False\n    \"\"\"\n    has_at_symbol = False\n    has_dot = False\n    \n    for character in email:\n        if character == '@':\n            has_at_symbol = True\n        elif character == '.':\n            has_dot = True\n            \n        # 提前退出优化：如果两个字符都已找到，可以提前结束循环\n        if has_at_symbol and has_dot:\n            break\n    \n    return has_at_symbol and has_dot"}
{"origin_topic": "将英文句子中的单词顺序反转但单词内部不变", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = \"\"\n    for c in s:\n        if c == \" \":\n            if b != \"\":\n                a.append(b)\n                b = \"\"\n        else:\n            b = b + c\n    if b != \"\":\n        a.append(b)\n    x = []\n    y = len(a) - 1\n    while y >= 0:\n        x.append(a[y])\n        y = y - 1\n    z = \"\"\n    for i in range(len(x)):\n        z = z + x[i]\n        if i != len(x) - 1:\n            z = z + \" \"\n    return z", "output": "def reverse_words(sentence: str) -> str:\n    \"\"\"Reverse the order of words in a given sentence.\n    \n    Words are defined as non-space characters separated by spaces. Multiple\n    spaces between words are treated as a single delimiter.\n    \n    Args:\n        sentence: Input string containing words separated by spaces.\n        \n    Returns:\n        String with words in reverse order, separated by single spaces.\n        \n    Examples:\n        >>> reverse_words(\"hello world\")\n        'world hello'\n        >>> reverse_words(\"  multiple   spaces   between   words  \")\n        'words between spaces multiple'\n    \"\"\"\n    words = []\n    current_word = []\n    \n    # Parse words from the sentence\n    for char in sentence:\n        if char == \" \":\n            if current_word:\n                words.append(\"\".join(current_word))\n                current_word = []\n        else:\n            current_word.append(char)\n    \n    # Add the last word if it exists\n    if current_word:\n        words.append(\"\".join(current_word))\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join words with single spaces\n    return \" \".join(reversed_words)"}
{"origin_topic": "将两个字典合并，如果键冲突则值相加", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def combine_dicts(a, b):\n    result = {}\n    for key in a:\n        if key in b:\n            result[key] = a[key] + b[key]\n        else:\n            result[key] = a[key]\n    for key in b:\n        if key not in a:\n            result[key] = b[key]\n    return result", "output": "from typing import Dict, TypeVar\n\nT = TypeVar('T', int, float, str)  # 支持数值和字符串类型的合并\n\ndef merge_dictionaries_with_addition(\n    dict_a: Dict[str, T], \n    dict_b: Dict[str, T]\n) -> Dict[str, T]:\n    \"\"\"合并两个字典，对相同键的值执行加法操作。\n    \n    该函数将两个字典合并为一个新字典。对于在两个字典中都存在的键，\n    其值将被相加；对于只存在于一个字典中的键，其值将被直接保留。\n    \n    Args:\n        dict_a: 第一个输入字典，键为字符串，值为可相加的类型。\n        dict_b: 第二个输入字典，键为字符串，值为可相加的类型。\n    \n    Returns:\n        一个新的字典，包含两个输入字典的所有键。\n        对于相同键，值为两个字典对应值的和。\n    \n    Raises:\n        TypeError: 如果相同键对应的值类型不支持加法操作。\n    \n    Example:\n        >>> merge_dictionaries_with_addition({'a': 1, 'b': 2}, {'b': 3, 'c': 4})\n        {'a': 1, 'b': 5, 'c': 4}\n        >>> merge_dictionaries_with_addition({'x': 'hello'}, {'x': ' world'})\n        {'x': 'hello world'}\n    \"\"\"\n    merged_result: Dict[str, T] = {}\n    \n    # 处理dict_a中的所有键\n    for key, value in dict_a.items():\n        if key in dict_b:\n            # 相同键的值相加\n            merged_result[key] = value + dict_b[key]\n        else:\n            # 仅存在于dict_a的键\n            merged_result[key] = value\n    \n    # 处理仅存在于dict_b的键\n    for key, value in dict_b.items():\n        if key not in dict_a:\n            merged_result[key] = value\n    \n    return merged_result"}
{"origin_topic": "将字符串按空格分割成列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = []\n    x = 0\n    y = ''\n    while x < len(a):\n        if a[x] != ' ':\n            y = y + a[x]\n        else:\n            if y != '':\n                b.append(y)\n                y = ''\n        x = x + 1\n    if y != '':\n        b.append(y)\n    return b", "output": "from typing import List\n\n\ndef split_string_by_spaces(input_string: str) -> List[str]:\n    \"\"\"Splits a string into words using spaces as delimiters.\n    \n    This function processes a string character by character, accumulating\n    non-space characters into words and adding them to a list when a space\n    is encountered or at the end of the string. Multiple consecutive spaces\n    are treated as a single delimiter.\n    \n    Args:\n        input_string: The string to be split into words.\n    \n    Returns:\n        A list of words extracted from the input string. Returns an empty\n        list if the input string contains no non-space characters.\n    \n    Examples:\n        >>> split_string_by_spaces(\"hello world\")\n        ['hello', 'world']\n        >>> split_string_by_spaces(\"  multiple   spaces   \")\n        ['multiple', 'spaces']\n        >>> split_string_by_spaces(\"\")\n        []\n    \"\"\"\n    words: List[str] = []\n    current_word: str = \"\"\n    \n    for character in input_string:\n        if character != \" \":\n            current_word += character\n        else:\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n    \n    # Handle the last word if it exists\n    if current_word:\n        words.append(current_word)\n    \n    return words"}
{"origin_topic": "将一个字符串压缩，例如'aaabbc'压缩为'a3b2c1'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    if not s:\n        return \"\"\n    r = \"\"\n    c = s[0]\n    n = 0\n    for x in s:\n        if x == c:\n            n = n + 1\n        else:\n            r = r + c + str(n)\n            c = x\n            n = 1\n    r = r + c + str(n)\n    return r", "output": "def run_length_encode(input_string: str) -> str:\n    \"\"\"对输入字符串进行游程编码（Run-Length Encoding）。\n    \n    游程编码是一种简单的无损数据压缩方法，将连续重复的字符替换为\n    该字符及其出现次数的组合。\n    \n    Args:\n        input_string: 需要进行编码的字符串。\n        \n    Returns:\n        编码后的字符串。例如：\"aaabbc\" 会被编码为 \"a3b2c1\"。\n        \n    Examples:\n        >>> run_length_encode(\"aaabbc\")\n        'a3b2c1'\n        >>> run_length_encode(\"\")\n        ''\n        >>> run_length_encode(\"abc\")\n        'a1b1c1'\n    \"\"\"\n    if not input_string:\n        return \"\"\n    \n    encoded_string = \"\"\n    current_char = input_string[0]\n    char_count = 0\n    \n    for char in input_string:\n        if char == current_char:\n            char_count += 1\n        else:\n            encoded_string += current_char + str(char_count)\n            current_char = char\n            char_count = 1\n    \n    # 处理最后一组字符\n    encoded_string += current_char + str(char_count)\n    \n    return encoded_string"}
{"origin_topic": "检查一个字符串是否包含所有元音字母", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    v = ['a', 'e', 'i', 'o', 'u']\n    r = True\n    for c in v:\n        if c not in s.lower():\n            r = False\n            break\n    if r:\n        return True\n    else:\n        return False", "output": "def contains_all_vowels(text: str) -> bool:\n    \"\"\"Check if the input string contains all English vowels (a, e, i, o, u).\n\n    The check is case-insensitive. All five vowels must be present at least once\n    in the string for the function to return True.\n\n    Args:\n        text: The string to check for vowel presence.\n\n    Returns:\n        True if all vowels (a, e, i, o, u) are present in the string,\n        False otherwise.\n\n    Examples:\n        >>> contains_all_vowels(\"sequoia\")\n        True\n        >>> contains_all_vowels(\"hello world\")\n        False\n        >>> contains_all_vowels(\"AEIOU\")\n        True\n    \"\"\"\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    text_lower = text.lower()\n    \n    return vowels.issubset(text_lower)"}
{"origin_topic": "将字符串中的数字字符移除", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x == \"0\":\n            continue\n        elif x == \"1\":\n            continue\n        elif x == \"2\":\n            continue\n        elif x == \"3\":\n            continue\n        elif x == \"4\":\n            continue\n        elif x == \"5\":\n            continue\n        elif x == \"6\":\n            continue\n        elif x == \"7\":\n            continue\n        elif x == \"8\":\n            continue\n        elif x == \"9\":\n            continue\n        else:\n            b = b + x\n    return b", "output": "def filter_non_digits(input_string: str) -> str:\n    \"\"\"返回移除了所有数字字符的字符串。\n    \n    该函数遍历输入字符串，移除所有数字字符（0-9），\n    返回只包含非数字字符的新字符串。\n    \n    Args:\n        input_string: 需要处理的原始字符串\n        \n    Returns:\n        移除了所有数字字符的新字符串\n        \n    Examples:\n        >>> filter_non_digits(\"abc123def456\")\n        'abcdef'\n        >>> filter_non_digits(\"hello123\")\n        'hello'\n        >>> filter_non_digits(\"123456\")\n        ''\n    \"\"\"\n    filtered_chars = []\n    \n    for char in input_string:\n        if not char.isdigit():\n            filtered_chars.append(char)\n    \n    return ''.join(filtered_chars)"}
{"origin_topic": "将一个字符串中的元音字母替换为'*'", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    v = 'aeiouAEIOU'\n    r = ''\n    for c in s:\n        if c in v:\n            r = r + '*'\n        else:\n            r = r + c\n    return r", "output": "def replace_vowels_with_asterisk(text: str) -> str:\n    \"\"\"Replaces all vowels in the input string with asterisks.\n\n    Args:\n        text: The input string to process.\n\n    Returns:\n        A new string where all vowels (both lowercase and uppercase) are\n        replaced with '*' characters. Non-vowel characters remain unchanged.\n\n    Examples:\n        >>> replace_vowels_with_asterisk(\"Hello World\")\n        'H*ll* W*rld'\n        >>> replace_vowels_with_asterisk(\"AEIOUaeiou\")\n        '**********'\n        >>> replace_vowels_with_asterisk(\"xyz\")\n        'xyz'\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    result_chars = []\n\n    for character in text:\n        if character in vowels:\n            result_chars.append(\"*\")\n        else:\n            result_chars.append(character)\n\n    return \"\".join(result_chars)"}
{"origin_topic": "检查一个IP地址是否合法", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_ip(a):\n    if not isinstance(a, str):\n        return False\n    b = a.split('.')\n    if len(b) != 4:\n        return False\n    for x in b:\n        if not x.isdigit():\n            return False\n        y = int(x)\n        if y < 0 or y > 255:\n            return False\n        if x != str(int(x)):\n            return False\n    return True", "output": "def is_valid_ipv4_address(ip_string: str) -> bool:\n    \"\"\"Check if a string is a valid IPv4 address.\n\n    Args:\n        ip_string: The string to validate as an IPv4 address.\n\n    Returns:\n        True if the string is a valid IPv4 address, False otherwise.\n\n    A valid IPv4 address must:\n        - Be a string\n        - Contain exactly 4 octets separated by dots\n        - Each octet must be a decimal integer between 0 and 255\n        - No leading zeros (except for '0' itself)\n    \"\"\"\n    if not isinstance(ip_string, str):\n        return False\n\n    octets = ip_string.split('.')\n    if len(octets) != 4:\n        return False\n\n    for octet in octets:\n        # Check if octet consists only of digits\n        if not octet.isdigit():\n            return False\n\n        # Convert to integer and check range\n        octet_value = int(octet)\n        if octet_value < 0 or octet_value > 255:\n            return False\n\n        # Check for leading zeros (e.g., '001' is invalid)\n        if octet != str(octet_value):\n            return False\n\n    return True"}
{"origin_topic": "计算句子中的单词数量", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(x):\n    b = 0\n    c = 0\n    d = len(x)\n    while c < d:\n        e = False\n        while c < d and x[c] == ' ':\n            c = c + 1\n            e = True\n        if c < d:\n            while c < d and x[c] != ' ':\n                c = c + 1\n            b = b + 1\n    return b", "output": "def count_words(text: str) -> int:\n    \"\"\"Count the number of words in a string.\n\n    Words are defined as sequences of non-space characters separated by one or\n    more spaces. Leading, trailing, and multiple consecutive spaces are handled\n    correctly.\n\n    Args:\n        text: The input string to count words in.\n\n    Returns:\n        The number of words in the input string.\n\n    Examples:\n        >>> count_words(\"Hello world\")\n        2\n        >>> count_words(\"  Multiple   spaces   between   words  \")\n        4\n        >>> count_words(\"\")\n        0\n        >>> count_words(\"   \")\n        0\n    \"\"\"\n    word_count = 0\n    current_index = 0\n    text_length = len(text)\n\n    while current_index < text_length:\n        # Skip consecutive spaces\n        found_space = False\n        while current_index < text_length and text[current_index] == ' ':\n            current_index += 1\n            found_space = True\n\n        # If we're not at the end of the string, we've found a word\n        if current_index < text_length:\n            # Skip the current word (non-space characters)\n            while current_index < text_length and text[current_index] != ' ':\n                current_index += 1\n            word_count += 1\n\n    return word_count"}
{"origin_topic": "将字符串中的数字提取为列表", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = \"\"\n    for e in b:\n        if e.isdigit():\n            d = d + e\n        else:\n            if d:\n                c.append(int(d))\n                d = \"\"\n    if d:\n        c.append(int(d))\n    return c", "output": "from typing import List\n\n\ndef extract_numbers_from_string(input_string: str) -> List[int]:\n    \"\"\"Extracts all consecutive digit sequences from a string and returns them as integers.\n    \n    This function scans the input string character by character, accumulating consecutive\n    digits into temporary strings, then converting them to integers when non-digit\n    characters are encountered or at the end of the string.\n    \n    Args:\n        input_string: The string from which to extract numbers. Can contain any characters.\n        \n    Returns:\n        A list of integers extracted from the input string. Returns an empty list if\n        no digit sequences are found.\n        \n    Examples:\n        >>> extract_numbers_from_string(\"abc123def45gh6\")\n        [123, 45, 6]\n        >>> extract_numbers_from_string(\"no numbers here\")\n        []\n        >>> extract_numbers_from_string(\"123\")\n        [123]\n        >>> extract_numbers_from_string(\"1a2b3c\")\n        [1, 2, 3]\n    \"\"\"\n    extracted_numbers: List[int] = []\n    current_number_string: str = \"\"\n    \n    for character in input_string:\n        if character.isdigit():\n            current_number_string += character\n        else:\n            if current_number_string:\n                extracted_numbers.append(int(current_number_string))\n                current_number_string = \"\"\n    \n    # Handle any remaining digits at the end of the string\n    if current_number_string:\n        extracted_numbers.append(int(current_number_string))\n    \n    return extracted_numbers"}
{"origin_topic": "计算一个字符串中数字的总和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = 0\n    for d in b:\n        if d.isdigit():\n            e = int(d)\n            c = c + e\n        else:\n            f = 0\n            c = c + f\n    g = c\n    return g", "output": "def sum_digits_in_string(input_string: str) -> int:\n    \"\"\"计算字符串中所有数字字符的数值总和。\n    \n    遍历输入字符串中的每个字符，如果字符是数字则将其转换为整数并累加，\n    非数字字符将被忽略（计为0）。\n    \n    Args:\n        input_string: 需要处理的字符串，可能包含数字和非数字字符。\n        \n    Returns:\n        字符串中所有数字字符的数值总和。如果字符串中没有数字，返回0。\n        \n    Examples:\n        >>> sum_digits_in_string(\"abc123\")\n        6\n        >>> sum_digits_in_string(\"a1b2c3\")\n        6\n        >>> sum_digits_in_string(\"no digits\")\n        0\n    \"\"\"\n    total_sum = 0\n    \n    for character in input_string:\n        if character.isdigit():\n            digit_value = int(character)\n            total_sum += digit_value\n        # 非数字字符被隐式忽略（不加任何值）\n    \n    return total_sum"}
{"origin_topic": "检查一个字符串是否全为字母", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_string(x):\n    result = True\n    for a in x:\n        b = a.isalpha()\n        if b == False:\n            result = False\n            break\n    if result == True:\n        return True\n    else:\n        return False", "output": "from typing import Union, Iterable\n\n\ndef contains_only_alphabetic_characters(text: Union[str, Iterable[str]]) -> bool:\n    \"\"\"检查输入文本是否仅包含字母字符。\n    \n    遍历输入文本中的每个字符，检查其是否为字母字符（a-z, A-Z）。\n    如果发现任何非字母字符，立即返回False；否则返回True。\n    \n    Args:\n        text: 要检查的文本，可以是字符串或字符串的可迭代对象\n        \n    Returns:\n        bool: 如果文本中所有字符都是字母字符则返回True，否则返回False\n        \n    Examples:\n        >>> contains_only_alphabetic_characters(\"Hello\")\n        True\n        >>> contains_only_alphabetic_characters(\"Hello123\")\n        False\n        >>> contains_only_alphabetic_characters(\"\")\n        True\n    \"\"\"\n    for character in text:\n        if not character.isalpha():\n            return False\n    return True"}
{"origin_topic": "将一个数字四舍五入到两位小数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = int(b * 100 + 0.5) if b >= 0 else int(b * 100 - 0.5)\n    d = c / 100.0\n    return d", "output": "def round_to_two_decimals(value: float) -> float:\n    \"\"\"将浮点数四舍五入到两位小数。\n    \n    使用银行家舍入法（round half to even）的替代方案，通过乘以100后加0.5取整的方式\n    实现传统的四舍五入。处理正负数时采用不同的偏移量。\n    \n    Args:\n        value: 需要四舍五入的浮点数\n    \n    Returns:\n        四舍五入到两位小数的浮点数\n    \n    Examples:\n        >>> round_to_two_decimals(3.14159)\n        3.14\n        >>> round_to_two_decimals(2.675)\n        2.68\n        >>> round_to_two_decimals(-2.675)\n        -2.68\n    \"\"\"\n    # 将数值乘以100后，根据正负添加0.5或-0.5的偏移量，然后取整\n    if value >= 0:\n        scaled_value = int(value * 100 + 0.5)\n    else:\n        scaled_value = int(value * 100 - 0.5)\n    \n    # 将取整后的值除以100，恢复为两位小数\n    rounded_value = scaled_value / 100.0\n    \n    return rounded_value"}
{"origin_topic": "计算一个数字的二进制表示中1的个数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_ones(num):\n    a = 0\n    while num > 0:\n        b = num % 2\n        if b == 1:\n            a = a + 1\n        num = num // 2\n    while num < 0:\n        x = num & 1\n        if x == 1:\n            a = a + 1\n        num = num >> 1\n        if num == -1:\n            a = a + 1\n            break\n    return a", "output": "def count_set_bits(num: int) -> int:\n    \"\"\"Count the number of 1 bits in the binary representation of an integer.\n    \n    This function handles both positive and negative integers by using different\n    algorithms for each case. For positive numbers, it uses division by 2.\n    For negative numbers, it uses bitwise operations to avoid infinite loops.\n    \n    Args:\n        num: The integer whose set bits (1s) should be counted.\n    \n    Returns:\n        The number of 1 bits in the binary representation of the input.\n    \n    Examples:\n        >>> count_set_bits(5)  # binary: 101\n        2\n        >>> count_set_bits(-3)  # binary: ...11111101 (two's complement)\n        31  # for 32-bit integers\n    \"\"\"\n    if num == 0:\n        return 0\n    \n    set_bit_count = 0\n    \n    if num > 0:\n        # For positive numbers: repeatedly divide by 2 and count remainders of 1\n        current_number = num\n        while current_number > 0:\n            remainder = current_number % 2\n            if remainder == 1:\n                set_bit_count += 1\n            current_number //= 2\n    else:\n        # For negative numbers: use bitwise operations with two's complement\n        # This avoids infinite loops that would occur with right shift on negatives\n        current_number = num\n        while current_number < 0:\n            least_significant_bit = current_number & 1\n            if least_significant_bit == 1:\n                set_bit_count += 1\n            \n            # Right shift preserves sign bit for negative numbers\n            current_number >>= 1\n            \n            # Special case: -1 in two's complement is all 1s\n            if current_number == -1:\n                set_bit_count += 1\n                break\n    \n    return set_bit_count"}
{"origin_topic": "计算字符串的长度", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = 0\n    for y in b:\n        x = x + 1\n    return x", "output": "from typing import Sequence\n\n\ndef count_elements(sequence: Sequence) -> int:\n    \"\"\"Count the number of elements in a sequence.\n\n    Args:\n        sequence: A sequence of elements to count.\n\n    Returns:\n        The total number of elements in the sequence.\n\n    Examples:\n        >>> count_elements([1, 2, 3, 4])\n        4\n        >>> count_elements(\"hello\")\n        5\n        >>> count_elements((1, 2, 3))\n        3\n    \"\"\"\n    element_count = 0\n    for element in sequence:\n        element_count += 1\n    return element_count"}
{"origin_topic": "将字符串按单词首字母排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = s.split()\n    b = []\n    for x in a:\n        b.append(x)\n    c = []\n    for y in b:\n        d = y[0]\n        c.append(d)\n    e = []\n    for z in b:\n        e.append(z)\n    g = []\n    for h in range(len(e)):\n        i = e[h]\n        j = c[h]\n        g.append((j, i))\n    k = []\n    for l in g:\n        m = l[0]\n        n = l[1]\n        k.append((m, n))\n    o = []\n    for p in k:\n        q = p[0]\n        r = p[1]\n        o.append((q, r))\n    t = []\n    for u in o:\n        v = u[0]\n        w = u[1]\n        t.append((v, w))\n    srt = []\n    for idx in range(len(t)):\n        srt.append(t[idx])\n    srt.sort()\n    res = []\n    for item in srt:\n        res.append(item[1])\n    final = []\n    for word in res:\n        final.append(word)\n    out = \"\"\n    for idx in range(len(final)):\n        out = out + final[idx]\n        if idx != len(final) - 1:\n            out = out + \" \"\n    return out", "output": "from typing import List, Tuple\n\n\ndef extract_first_letters_and_sort_words(input_string: str) -> str:\n    \"\"\"\n    Extracts the first letter of each word, sorts words based on these letters,\n    and returns the sorted words as a space-separated string.\n\n    The function performs the following steps:\n    1. Splits the input string into individual words\n    2. Extracts the first letter of each word\n    3. Pairs each word with its first letter\n    4. Sorts the pairs alphabetically by first letter\n    5. Extracts the sorted words and joins them with spaces\n\n    Args:\n        input_string: A string containing space-separated words\n\n    Returns:\n        A string containing the input words sorted by their first letter,\n        joined with spaces\n\n    Example:\n        >>> extract_first_letters_and_sort_words(\"banana apple cherry\")\n        'apple banana cherry'\n    \"\"\"\n    # Split input string into words\n    words: List[str] = input_string.split()\n    \n    # Extract first letter of each word\n    first_letters: List[str] = [word[0] for word in words]\n    \n    # Create pairs of (first_letter, word)\n    word_letter_pairs: List[Tuple[str, str]] = list(zip(first_letters, words))\n    \n    # Sort pairs by first letter (primary) and word (secondary for stability)\n    sorted_pairs: List[Tuple[str, str]] = sorted(word_letter_pairs)\n    \n    # Extract sorted words from pairs\n    sorted_words: List[str] = [word for _, word in sorted_pairs]\n    \n    # Join sorted words with spaces\n    return \" \".join(sorted_words)"}
{"origin_topic": "将一个字符串中的大小写互换", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = \"\"\n    for x in a:\n        if x.islower():\n            b = b + x.upper()\n        else:\n            if x.isupper():\n                b = b + x.lower()\n            else:\n                b = b + x\n    return b", "output": "def transform_string_case(input_string: str) -> str:\n    \"\"\"Transforms the case of alphabetic characters in a string.\n    \n    Converts lowercase letters to uppercase and uppercase letters to lowercase.\n    Non-alphabetic characters remain unchanged.\n    \n    Args:\n        input_string: The string to transform.\n        \n    Returns:\n        A new string with transformed character cases.\n        \n    Examples:\n        >>> transform_string_case(\"Hello World!\")\n        'hELLO wORLD!'\n        >>> transform_string_case(\"Python 3.9\")\n        'pYTHON 3.9'\n    \"\"\"\n    transformed_chars = []\n    \n    for char in input_string:\n        if char.islower():\n            transformed_chars.append(char.upper())\n        elif char.isupper():\n            transformed_chars.append(char.lower())\n        else:\n            transformed_chars.append(char)\n    \n    return ''.join(transformed_chars)"}
{"origin_topic": "计算一个数字的各位数字之和", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def calculate_sum_of_digits(number):\n    total = 0\n    string_representation = str(number)\n    for character in string_representation:\n        if character.isdigit():\n            digit_value = int(character)\n            total = total + digit_value\n        else:\n            continue\n    return total", "output": "def calculate_sum_of_digits(number: int | str) -> int:\n    \"\"\"计算数字字符串或整数中所有数字的和。\n\n    该函数接受一个整数或数字字符串，返回其中所有数字字符的数值总和。\n    非数字字符会被自动忽略。\n\n    Args:\n        number: 输入的数字，可以是整数或字符串形式。\n\n    Returns:\n        输入中所有数字的和。\n\n    Examples:\n        >>> calculate_sum_of_digits(123)\n        6\n        >>> calculate_sum_of_digits(\"12a3\")\n        6\n        >>> calculate_sum_of_digits(\"\")\n        0\n\n    Raises:\n        TypeError: 如果输入既不是整数也不是字符串。\n    \"\"\"\n    if not isinstance(number, (int, str)):\n        raise TypeError(f\"输入必须是整数或字符串，但得到 {type(number).__name__}\")\n\n    digit_sum = 0\n    for char in str(number):\n        if char.isdigit():\n            digit_sum += int(char)\n    \n    return digit_sum"}
{"origin_topic": "计算数字的阶乘", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 1\n    for x in range(1, a + 1):\n        b = b * x\n    return b", "output": "def compute_factorial(number: int) -> int:\n    \"\"\"Computes the factorial of a given non-negative integer.\n\n    The factorial of a non-negative integer n is the product of all positive\n    integers less than or equal to n. For example: 5! = 5 × 4 × 3 × 2 × 1 = 120.\n\n    Args:\n        number: The non-negative integer for which to compute the factorial.\n\n    Returns:\n        The factorial of the input number.\n\n    Raises:\n        ValueError: If the input number is negative.\n    \"\"\"\n    if number < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers.\")\n    \n    result = 1\n    for current_value in range(1, number + 1):\n        result *= current_value\n    return result"}
{"origin_topic": "将一个日期字符串（如'2023-10-05'）转换为年月日三个整数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = s.split('-')\n    b = []\n    for x in a:\n        b.append(int(x))\n    y = b[0]\n    m = b[1]\n    d = b[2]\n    return y, m, d", "output": "from typing import Tuple\n\n\ndef parse_date_string(date_string: str) -> Tuple[int, int, int]:\n    \"\"\"Parse a date string in 'YYYY-MM-DD' format into its components.\n    \n    Args:\n        date_string: A string in the format 'YYYY-MM-DD' representing a date.\n        \n    Returns:\n        A tuple containing (year, month, day) as integers.\n        \n    Raises:\n        ValueError: If the date_string is not in the expected format or\n                    contains non-numeric components.\n    \"\"\"\n    date_components = date_string.split('-')\n    \n    if len(date_components) != 3:\n        raise ValueError(f\"Invalid date format. Expected 'YYYY-MM-DD', got '{date_string}'\")\n    \n    try:\n        year, month, day = [int(component) for component in date_components]\n    except ValueError as e:\n        raise ValueError(f\"Date components must be integers. Error: {e}\")\n    \n    return year, month, day"}
{"origin_topic": "将一个罗马数字转换为整数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def convert_roman_to_integer(s):\n    mapping = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    total_sum = 0\n    previous_value = 0\n    for i in range(len(s)):\n        current_char = s[i]\n        current_value = mapping.get(current_char, 0)\n        if previous_value < current_value:\n            total_sum = total_sum - previous_value\n            total_sum = total_sum + (current_value - previous_value)\n        else:\n            total_sum = total_sum + current_value\n        previous_value = current_value\n    return total_sum", "output": "def convert_roman_to_integer(roman_numeral: str) -> int:\n    \"\"\"Convert a Roman numeral string to its integer equivalent.\n    \n    This function follows the standard Roman numeral conversion rules where\n    smaller numerals preceding larger ones are subtracted rather than added.\n    \n    Args:\n        roman_numeral: A string containing valid Roman numeral characters\n                      (I, V, X, L, C, D, M). Input validation is not performed.\n    \n    Returns:\n        The integer value corresponding to the Roman numeral.\n    \n    Examples:\n        >>> convert_roman_to_integer(\"III\")\n        3\n        >>> convert_roman_to_integer(\"IV\")\n        4\n        >>> convert_roman_to_integer(\"MCMXCIV\")\n        1994\n    \"\"\"\n    roman_to_value = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000,\n    }\n    \n    total = 0\n    previous_value = 0\n    \n    for current_char in roman_numeral:\n        current_value = roman_to_value.get(current_char, 0)\n        \n        if previous_value < current_value:\n            # Subtract the previous value that was incorrectly added,\n            # then add the correct combined value (current - previous)\n            total += current_value - 2 * previous_value\n        else:\n            total += current_value\n            \n        previous_value = current_value\n    \n    return total"}
{"origin_topic": "从字符串中删除所有空格", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = \"\"\n    for d in b:\n        if d != \" \":\n            c = c + d\n    return c", "output": "def remove_spaces(input_string: str) -> str:\n    \"\"\"Removes all space characters from the input string.\n    \n    Args:\n        input_string: The string from which spaces will be removed.\n    \n    Returns:\n        A new string containing all characters from the input string \n        except space characters.\n    \n    Example:\n        >>> remove_spaces(\"hello world\")\n        'helloworld'\n        >>> remove_spaces(\"  test  string  \")\n        'teststring'\n    \"\"\"\n    result = \"\"\n    for character in input_string:\n        if character != \" \":\n            result += character\n    return result"}
{"origin_topic": "检查一个字符串中的括号是否匹配", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(s):\n    a = []\n    b = {')': '(', ']': '[', '}': '{'}\n    for x in s:\n        if x in b.values():\n            a.append(x)\n        elif x in b.keys():\n            if not a:\n                return False\n            y = a.pop()\n            if y != b[x]:\n                return False\n    return not a", "output": "from typing import Dict, List\n\n\ndef is_valid_parentheses(expression: str) -> bool:\n    \"\"\"检查括号表达式是否有效。\n\n    括号表达式有效的条件：\n    1. 每个开括号必须有对应的闭括号\n    2. 括号必须正确嵌套\n    3. 闭括号必须匹配最近的开括号类型\n\n    Args:\n        expression: 包含括号的字符串表达式，可能包含其他字符\n\n    Returns:\n        bool: 如果括号表达式有效返回True，否则返回False\n\n    Examples:\n        >>> is_valid_parentheses(\"()[]{}\")\n        True\n        >>> is_valid_parentheses(\"([{}])\")\n        True\n        >>> is_valid_parentheses(\"(]\")\n        False\n        >>> is_valid_parentheses(\"([)]\")\n        False\n        >>> is_valid_parentheses(\"\")\n        True\n    \"\"\"\n    stack: List[str] = []\n    bracket_pairs: Dict[str, str] = {')': '(', ']': '[', '}': '{'}\n\n    for char in expression:\n        if char in bracket_pairs.values():  # 开括号\n            stack.append(char)\n        elif char in bracket_pairs.keys():  # 闭括号\n            if not stack:  # 栈为空，没有对应的开括号\n                return False\n            \n            last_opening_bracket = stack.pop()\n            if last_opening_bracket != bracket_pairs[char]:\n                return False  # 括号类型不匹配\n\n    # 栈为空表示所有开括号都有对应的闭括号\n    return not stack"}
{"origin_topic": "验证括号字符串是否有效", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    x = []\n    for c in b:\n        if c == '(' or c == '{' or c == '[':\n            x.append(c)\n        else:\n            if not x:\n                return False\n            d = x.pop()\n            if c == ')' and d != '(':\n                return False\n            if c == '}' and d != '{':\n                return False\n            if c == ']' and d != '[':\n                return False\n    if x:\n        return False\n    else:\n        return True", "output": "from typing import List\n\n\ndef is_valid_parentheses(expression: str) -> bool:\n    \"\"\"检查括号表达式是否有效。\n\n    括号必须按正确的顺序闭合：\n    - 每个开括号必须有对应的闭括号\n    - 闭括号必须匹配最近未匹配的开括号类型\n\n    Args:\n        expression: 包含括号字符的字符串，允许的字符包括：\n                   '()', '{}', '[]'\n\n    Returns:\n        True 如果括号有效配对，否则 False\n\n    Examples:\n        >>> is_valid_parentheses(\"()[]{}\")\n        True\n        >>> is_valid_parentheses(\"([{}])\")\n        True\n        >>> is_valid_parentheses(\"(]\")\n        False\n        >>> is_valid_parentheses(\"([)]\")\n        False\n    \"\"\"\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    open_brackets_stack: List[str] = []\n\n    for char in expression:\n        if char in '({[':\n            # 开括号入栈\n            open_brackets_stack.append(char)\n        elif char in ')}]':\n            # 闭括号需要匹配栈顶元素\n            if not open_brackets_stack:\n                return False\n            \n            last_open_bracket = open_brackets_stack.pop()\n            if bracket_pairs[char] != last_open_bracket:\n                return False\n    \n    # 栈应为空，表示所有开括号都已匹配\n    return not open_brackets_stack"}
{"origin_topic": "统计一个字符串中每个字符的出现次数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def count_chars(s):\n    result = {}\n    for i in range(len(s)):\n        c = s[i]\n        if c in result:\n            result[c] = result[c] + 1\n        else:\n            result[c] = 1\n    return result", "output": "from typing import Dict\n\n\ndef count_character_frequencies(input_string: str) -> Dict[str, int]:\n    \"\"\"Count the frequency of each character in a given string.\n\n    Args:\n        input_string: The string to analyze for character frequencies.\n\n    Returns:\n        A dictionary where keys are characters from the input string and values\n        are the corresponding frequency counts.\n\n    Examples:\n        >>> count_character_frequencies(\"hello\")\n        {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n        >>> count_character_frequencies(\"aabbcc\")\n        {'a': 2, 'b': 2, 'c': 2}\n    \"\"\"\n    frequency_map: Dict[str, int] = {}\n    \n    for character in input_string:\n        if character in frequency_map:\n            frequency_map[character] += 1\n        else:\n            frequency_map[character] = 1\n    \n    return frequency_map"}
{"origin_topic": "计算一个数字的斐波那契数列第n项", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a = 0\n    b = 1\n    x = 2\n    while x <= n:\n        c = a + b\n        a = b\n        b = c\n        x = x + 1\n    return b", "output": "def fibonacci(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number.\n    \n    The Fibonacci sequence is defined as:\n    F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1\n    \n    Args:\n        n: The position in the Fibonacci sequence (non-negative integer).\n    \n    Returns:\n        The nth Fibonacci number.\n    \n    Raises:\n        ValueError: If n is negative.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    previous, current = 0, 1  # F(0) and F(1)\n    \n    for position in range(2, n + 1):\n        previous, current = current, previous + current\n    \n    return current"}
{"origin_topic": "将二进制字符串转换为十进制整数", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    x = len(a) - 1\n    for i in range(len(a)):\n        if a[i] == '1':\n            c = 1\n            for j in range(x - i):\n                c = c * 2\n            b = b + c\n        elif a[i] == '0':\n            d = 0\n            for k in range(x - i):\n                d = d * 2\n            b = b + d\n    return b", "output": "def binary_string_to_int(binary_str: str) -> int:\n    \"\"\"Convert a binary string to its integer representation.\n    \n    Args:\n        binary_str: A string containing only '0' and '1' characters.\n    \n    Returns:\n        The integer value represented by the binary string.\n    \n    Raises:\n        ValueError: If the input contains characters other than '0' or '1'.\n    \"\"\"\n    if not all(char in '01' for char in binary_str):\n        raise ValueError(\"Input must contain only '0' and '1' characters\")\n    \n    result = 0\n    str_length = len(binary_str)\n    \n    for position, char in enumerate(binary_str):\n        if char == '1':\n            # Calculate the value of this bit position\n            power = str_length - position - 1\n            bit_value = 1 << power  # Equivalent to 2^power\n            result += bit_value\n        # For '0' characters, no value is added (0 * 2^n = 0)\n    \n    return result"}
{"origin_topic": "将字符串拆分为单词列表并按字母顺序排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = 0\n    e = len(b)\n    while d < e:\n        f = ''\n        while d < e and b[d] != ' ':\n            f = f + b[d]\n            d = d + 1\n        if f:\n            c.append(f)\n        while d < e and b[d] == ' ':\n            d = d + 1\n    g = len(c)\n    h = 0\n    while h < g:\n        i = h + 1\n        while i < g:\n            if c[h] > c[i]:\n                j = c[h]\n                c[h] = c[i]\n                c[i] = j\n            i = i + 1\n        h = h + 1\n    return c", "output": "from typing import List\n\n\ndef sort_words_in_string(input_string: str) -> List[str]:\n    \"\"\"Extracts words from a string and returns them sorted alphabetically.\n    \n    Words are defined as sequences of non-space characters separated by spaces.\n    The function performs case-sensitive sorting based on Python's default\n    string comparison.\n    \n    Args:\n        input_string: The string containing words to be extracted and sorted.\n        \n    Returns:\n        A list of words sorted in alphabetical order.\n        \n    Examples:\n        >>> sort_words_in_string(\"hello world python\")\n        ['hello', 'python', 'world']\n        \n        >>> sort_words_in_string(\"  multiple   spaces   between   words  \")\n        ['between', 'multiple', 'spaces', 'words']\n    \"\"\"\n    if not input_string:\n        return []\n    \n    words = []\n    current_index = 0\n    string_length = len(input_string)\n    \n    # Extract words from the string\n    while current_index < string_length:\n        # Build current word\n        current_word = ''\n        while (current_index < string_length and \n               input_string[current_index] != ' '):\n            current_word += input_string[current_index]\n            current_index += 1\n        \n        # Add non-empty word to list\n        if current_word:\n            words.append(current_word)\n        \n        # Skip spaces between words\n        while (current_index < string_length and \n               input_string[current_index] == ' '):\n            current_index += 1\n    \n    # Sort words using bubble sort (as in original implementation)\n    word_count = len(words)\n    for i in range(word_count):\n        for j in range(i + 1, word_count):\n            if words[i] > words[j]:\n                # Swap words\n                words[i], words[j] = words[j], words[i]\n    \n    return words"}
{"origin_topic": "将一个字符串中的数字提取出来", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b:\n        if d == '0' or d == '1' or d == '2' or d == '3' or d == '4' or d == '5' or d == '6' or d == '7' or d == '8' or d == '9':\n            c.append(d)\n    e = ''\n    for f in c:\n        e = e + f\n    return e", "output": "from typing import List\n\n\ndef extract_digits(input_string: str) -> str:\n    \"\"\"Extracts all digit characters from the input string.\n    \n    Args:\n        input_string: The string from which to extract digits.\n        \n    Returns:\n        A string containing all digit characters found in the input,\n        in the order they appear. Returns an empty string if no digits\n        are found.\n        \n    Examples:\n        >>> extract_digits(\"abc123def456\")\n        '123456'\n        >>> extract_digits(\"no digits here\")\n        ''\n        >>> extract_digits(\"9876543210\")\n        '9876543210'\n    \"\"\"\n    digits: List[str] = []\n    \n    for character in input_string:\n        if character.isdigit():\n            digits.append(character)\n    \n    return ''.join(digits)"}
{"origin_topic": "从一个句子中提取所有大写字母", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    for d in b:\n        if d.isupper():\n            c.append(d)\n    e = []\n    for f in c:\n        e.append(f)\n    g = \"\"\n    for h in e:\n        g = g + h\n    return g", "output": "from typing import List\n\n\ndef extract_and_concatenate_uppercase_chars(input_string: str) -> str:\n    \"\"\"Extracts uppercase characters from a string and concatenates them.\n    \n    This function filters out all uppercase characters from the input string,\n    collects them in order, and returns them as a single concatenated string.\n    \n    Args:\n        input_string: The string from which to extract uppercase characters.\n        \n    Returns:\n        A string containing all uppercase characters from the input,\n        concatenated in the order they appeared.\n        \n    Examples:\n        >>> extract_and_concatenate_uppercase_chars(\"Hello World!\")\n        'HW'\n        >>> extract_and_concatenate_uppercase_chars(\"abc123\")\n        ''\n        >>> extract_and_concatenate_uppercase_chars(\"PYTHON Rocks!\")\n        'PYTHONR'\n    \"\"\"\n    uppercase_chars: List[str] = [\n        char for char in input_string if char.isupper()\n    ]\n    \n    return ''.join(uppercase_chars)"}
 {"origin_topic": "验证一个字符串是否为有效的电子邮件格式（简单检查，包含@和.）", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def check_email_format(input_string):\n    if input_string is None:\n        return False\n    if not isinstance(input_string, str):\n        return False\n    if len(input_string) == 0:\n        return False\n    found_at = False\n    found_dot = False\n    for character in input_string:\n        if character == '@':\n            found_at = True\n        if character == '.':\n            found_dot = True\n    if found_at and found_dot:\n        return True\n    else:\n        return False", "output": "\"\"\"Email format validation module.\"\"\"\n\nfrom typing import Optional\n\n\ndef is_valid_email_format(email_candidate: Optional[str]) -> bool:\n    \"\"\"Validates basic email format requirements.\n    \n    Checks if the input string contains both '@' and '.' characters,\n    which are minimal requirements for a valid email format.\n    \n    Args:\n        email_candidate: The string to validate as a potential email address.\n            Can be None.\n    \n    Returns:\n        True if the input is a non-empty string containing both '@' and '.' \n        characters, False otherwise.\n    \n    Examples:\n        >>> is_valid_email_format(\"test@example.com\")\n        True\n        >>> is_valid_email_format(\"invalid-email\")\n        False\n        >>> is_valid_email_format(None)\n        False\n        >>> is_valid_email_format(\"\")\n        False\n    \"\"\"\n    # Early return for invalid input types\n    if email_candidate is None:\n        return False\n    \n    if not isinstance(email_candidate, str):\n        return False\n    \n    # Early return for empty string\n    if not email_candidate:\n        return False\n    \n    # Check for required characters\n    has_at_sign = '@' in email_candidate\n    has_dot = '.' in email_candidate\n    \n    return has_at_sign and has_dot"}
{"origin_topic": "验证一个电子邮件地址的格式", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = 0\n    x = 0\n    if a.count(\"@\") != 1:\n        return False\n    else:\n        for i in range(len(a)):\n            if a[i] == \"@\":\n                b = i\n        if b == 0 or b == len(a) - 1:\n            return False\n        else:\n            for j in range(b):\n                if a[j] == \".\" and (j == 0 or j == b - 1):\n                    return False\n                if not (a[j].isalnum() or a[j] in \"._-\"):\n                    return False\n            for k in range(b + 1, len(a)):\n                if a[k] == \".\":\n                    x = k\n            if x == 0:\n                return False\n            else:\n                if x == b + 1 or x == len(a) - 1:\n                    return False\n                else:\n                    for m in range(b + 1, x):\n                        if not a[m].isalnum() or a[m] == \"-\":\n                            return False\n                    for n in range(x + 1, len(a)):\n                        if not a[n].isalpha():\n                            return False\n                    if len(a) - x - 1 < 2:\n                        return False\n    return True", "output": "\"\"\"Email address validation module.\n\nThis module provides a function to validate email addresses based on specific\nformatting rules.\n\"\"\"\n\nfrom typing import Union\n\n\ndef is_valid_email(email: str) -> bool:\n    \"\"\"Validates an email address according to specific formatting rules.\n\n    The validation rules are:\n    1. Must contain exactly one '@' character\n    2. '@' cannot be at the start or end of the string\n    3. Local part (before '@') rules:\n        - Can contain alphanumeric characters, dots, underscores, and hyphens\n        - Dot cannot be at the start or immediately before '@'\n    4. Domain part (after '@') rules:\n        - Must contain at least one dot\n        - Last dot must not be immediately after '@' or at the end\n        - Subdomain (between '@' and last dot) must contain only alphanumeric\n          characters and hyphens\n        - TLD (after last dot) must contain only alphabetic characters and\n          be at least 2 characters long\n\n    Args:\n        email: The email address string to validate.\n\n    Returns:\n        True if the email address is valid according to the rules,\n        False otherwise.\n    \"\"\"\n    # Rule 1: Exactly one '@' character\n    if email.count(\"@\") != 1:\n        return False\n\n    at_position = email.find(\"@\")\n    \n    # Rule 2: '@' cannot be at start or end\n    if at_position == 0 or at_position == len(email) - 1:\n        return False\n\n    # Validate local part (before '@')\n    local_part = email[:at_position]\n    if not _is_valid_local_part(local_part):\n        return False\n\n    # Validate domain part (after '@')\n    domain_part = email[at_position + 1:]\n    if not _is_valid_domain_part(domain_part):\n        return False\n\n    return True\n\n\ndef _is_valid_local_part(local_part: str) -> bool:\n    \"\"\"Validates the local part of an email address.\n\n    Args:\n        local_part: The string before the '@' character.\n\n    Returns:\n        True if the local part is valid, False otherwise.\n    \"\"\"\n    # Check each character in local part\n    for i, char in enumerate(local_part):\n        # Dot cannot be at start or immediately before '@'\n        if char == \".\" and (i == 0 or i == len(local_part) - 1):\n            return False\n        \n        # Only allow alphanumeric, dot, underscore, and hyphen\n        if not (char.isalnum() or char in \"._-\"):\n            return False\n    \n    return True\n\n\ndef _is_valid_domain_part(domain_part: str) -> bool:\n    \"\"\"Validates the domain part of an email address.\n\n    Args:\n        domain_part: The string after the '@' character.\n\n    Returns:\n        True if the domain part is valid, False otherwise.\n    \"\"\"\n    # Must contain at least one dot\n    last_dot_position = domain_part.rfind(\".\")\n    if last_dot_position == -1:\n        return False\n\n    # Last dot cannot be at start or end of domain part\n    if last_dot_position == 0 or last_dot_position == len(domain_part) - 1:\n        return False\n\n    # Validate subdomain (between '@' and last dot)\n    subdomain = domain_part[:last_dot_position]\n    if not _is_valid_subdomain(subdomain):\n        return False\n\n    # Validate TLD (after last dot)\n    tld = domain_part[last_dot_position + 1:]\n    if not _is_valid_tld(tld):\n        return False\n\n    return True\n\n\ndef _is_valid_subdomain(subdomain: str) -> bool:\n    \"\"\"Validates the subdomain portion of the domain.\n\n    Args:\n        subdomain: The string between '@' and the last dot.\n\n    Returns:\n        True if the subdomain is valid, False otherwise.\n    \"\"\"\n    # Subdomain must contain only alphanumeric characters and hyphens\n    for char in subdomain:\n        if not (char.isalnum() or char == \"-\"):\n            return False\n    return True\n\n\ndef _is_valid_tld(tld: str) -> bool:\n    \"\"\"Validates the top-level domain (TLD).\n\n    Args:\n        tld: The string after the last dot.\n\n    Returns:\n        True if the TLD is valid, False otherwise.\n    \"\"\"\n    # TLD must contain only alphabetic characters\n    if not all(char.isalpha() for char in tld):\n        return False\n    \n    # TLD must be at least 2 characters long\n    if len(tld) < 2:\n        return False\n    \n    return True"}
{"origin_topic": "将字符串中所有单词首字母大写", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = []\n    d = b.split()\n    for e in d:\n        f = \"\"\n        for g in range(len(e)):\n            if g == 0:\n                h = e[g].upper()\n                f = f + h\n            else:\n                i = e[g].lower()\n                f = f + i\n        c.append(f)\n    j = \" \".join(c)\n    return j", "output": "def format_title_case(text: str) -> str:\n    \"\"\"Convert a string to title case format.\n    \n    This function converts each word in the input string to title case,\n    where the first character is uppercase and remaining characters are lowercase.\n    Words are separated by whitespace.\n    \n    Args:\n        text: The input string to be formatted.\n        \n    Returns:\n        A new string with each word converted to title case.\n        \n    Examples:\n        >>> format_title_case(\"hello world\")\n        'Hello World'\n        >>> format_title_case(\"PYTHON programming\")\n        'Python Programming'\n    \"\"\"\n    formatted_words = []\n    words = text.split()\n    \n    for word in words:\n        formatted_word = \"\"\n        \n        for char_index, char in enumerate(word):\n            if char_index == 0:\n                formatted_word += char.upper()\n            else:\n                formatted_word += char.lower()\n                \n        formatted_words.append(formatted_word)\n    \n    return \" \".join(formatted_words)"}
{"origin_topic": "将句子中的单词按长度排序", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def a(b):\n    c = b.split()\n    d = {}\n    for e in c:\n        f = len(e)\n        if f not in d:\n            d[f] = []\n        d[f].append(e)\n    g = list(d.keys())\n    h = []\n    for i in range(len(g)):\n        j = g[i]\n        for k in range(i+1, len(g)):\n            l = g[k]\n            if j > l:\n                m = g[i]\n                g[i] = g[k]\n                g[k] = m\n    for n in g:\n        o = d[n]\n        for p in o:\n            h.append(p)\n    q = \"\"\n    for r in range(len(h)):\n        s = h[r]\n        q = q + s\n        if r != len(h) - 1:\n            q = q + \" \"\n    return q", "output": "from typing import Dict, List\n\n\ndef sort_words_by_length(text: str) -> str:\n    \"\"\"\n    Sort words in a string by their length in ascending order.\n\n    Words are grouped by length, then sorted groups are concatenated while\n    maintaining original order of words with the same length.\n\n    Args:\n        text: Input string containing words to be sorted.\n\n    Returns:\n        A new string with words sorted by length in ascending order.\n\n    Example:\n        >>> sort_words_by_length(\"hello world python code\")\n        'code hello world python'\n    \"\"\"\n    words = text.split()\n    length_to_words: Dict[int, List[str]] = {}\n\n    # Group words by their length\n    for word in words:\n        word_length = len(word)\n        if word_length not in length_to_words:\n            length_to_words[word_length] = []\n        length_to_words[word_length].append(word)\n\n    # Sort lengths in ascending order\n    sorted_lengths = sorted(length_to_words.keys())\n\n    # Flatten the grouped words while maintaining order within each group\n    sorted_words: List[str] = []\n    for length in sorted_lengths:\n        sorted_words.extend(length_to_words[length])\n\n    # Join words back into a single string\n    return \" \".join(sorted_words)"}
{"origin_topic": "接收用户输入并打印欢迎信息", "instruction": "请重构以下代码，使其符合 Google Style 规范并添加文档。", "input": "def f(a):\n    b = input()\n    x = \"欢迎\" + b + \"！\"\n    print(x)\n    return None", "output": "def greet_user(name: str) -> None:\n    \"\"\"向用户显示欢迎信息。\n    \n    该函数会请求用户输入姓名，然后输出个性化的欢迎信息。\n    \n    Args:\n        name: 用户的姓名。如果未提供，将通过标准输入获取。\n    \n    Returns:\n        None: 此函数不返回任何值，仅执行打印操作。\n    \n    Example:\n        >>> greet_user(\"Alice\")\n        欢迎Alice！\n    \"\"\"\n    if not name:\n        name = input(\"请输入您的姓名: \")\n    \n    greeting_message = f\"欢迎{name}！\"\n    print(greeting_message)"}
